######## activate.ts
// ACTIVATE command for pre-game lobby
import { Player } from './player.js';
import { promptForShip, promptForLevel, promptForEmail, promptForRegularOrTournament } from './pregame.js';
import { settings } from './settings.js';

/**
 * Handles the ACTIVATE <ship-name> command in pre-game mode.
 */
export function activateCommand(player: Player): void {
    if (!player.auth.authed) {
        promptForEmail(player, 0);
        //promptForLevel(player, 0);
    } else if (player.ship && player.ship.side === "NEUTRAL") {
        promptForLevel(player, 0);
    } else {
        if (settings.generated) {
            promptForShip(player, 0);
        } else {
            promptForRegularOrTournament(player, 0);
        }
    }
}

######## api/dto.ts
// DTOs + pure mappers; import ONLY types from game
import type { Side } from "../settings.js";
import type { Player } from "../player.js";
import type { Ship } from "../ship.js";
import type { Planet } from "../planet.js";
import type { Star } from "../star.js";
import type { Blackhole } from "../blackhole.js";

export type PositionDTO = Readonly<{ v: number; h: number }>;

export type PlayerDTO = Readonly<{
    name: string;
    side: Side;
    position: PositionDTO;
    condition: string;
    docked: boolean;
    shieldsUp: boolean;
    energy: number;
    damage: number;
    shieldEnergy: number;
    torpedoes: number;
    romulan?: Readonly<{ isRomulan: boolean; isRevealed: boolean; cloaked: boolean }>;
}>;

export type PlanetDTO = Readonly<{
    name?: string;
    side: Side;
    position: PositionDTO;
    isBase: boolean;
    builds: number;
    energy: number; // for bases: 0..1000 shields; for planets: whatever you store
}>;

export type BaseDTO = Readonly<{
    side: Side;
    position: PositionDTO;
    energy: number; // 0..1000
}>;

export type StarDTO = Readonly<{
    position: PositionDTO;
}>;

export type BlackholeDTO = Readonly<{
    position: PositionDTO;
}>;

export type SummaryDTO = Readonly<{
    timestamp: number;
    counts: Readonly<{
        players: number;
        ships: number;
        planets: number;
        stars: number;
        blackholes: number;
        federationShips: number;
        empireShips: number;
        federationBases: number;
        empireBases: number;
    }>;
}>;

// ---- Mappers (pure, lint-safe) ----

export function toPlayerDTO(p: Player & { ship: Ship }): Readonly<PlayerDTO> {
    const s = p.ship;
    return Object.freeze({
        name: s.name,
        side: s.side,
        position: Object.freeze({ v: s.position.v, h: s.position.h }),
        condition: s.condition,
        docked: s.docked,
        shieldsUp: s.shieldsUp,
        energy: s.energy,
        damage: s.damage,
        shieldEnergy: s.shieldEnergy,
        torpedoes: s.torpedoes,
        romulan: s.romulanStatus
            ? Object.freeze({
                isRomulan: !!s.romulanStatus.isRomulan,
                isRevealed: !!s.romulanStatus.isRevealed,
                cloaked: !!s.romulanStatus.cloaked,
            })
            : undefined,
    });
}

export function toPlanetDTO(pl: Planet): Readonly<PlanetDTO> {
    return Object.freeze({
        name: (pl as { name?: string }).name,
        side: pl.side,
        position: Object.freeze({ v: pl.position.v, h: pl.position.h }),
        isBase: !!pl.isBase,
        builds: pl.builds,
        energy: pl.energy,
    });
}

export function toBaseDTO(pl: Planet): Readonly<BaseDTO> {
    // Caller must ensure pl.isBase === true
    return Object.freeze({
        side: pl.side,
        position: Object.freeze({ v: pl.position.v, h: pl.position.h }),
        energy: pl.energy,
    });
}

export function toStarDTO(s: Star): Readonly<StarDTO> {
    return Object.freeze({
        position: Object.freeze({ v: s.position.v, h: s.position.h }),
    });
}

export function toBlackholeDTO(b: Blackhole): Readonly<BlackholeDTO> {
    return Object.freeze({
        position: Object.freeze({ v: b.position.v, h: b.position.h }),
    });
}

export function toSummaryDTO(args: {
    players: readonly Player[];
    planets: readonly Planet[];
    stars: readonly Star[];
    blackholes: readonly Blackhole[];
    federationBases: readonly Planet[];
    empireBases: readonly Planet[];
}): Readonly<SummaryDTO> {
    const { players, planets, stars, blackholes, federationBases, empireBases } = args;

    const ships = players.filter((p): p is Player & { ship: Ship } => Boolean(p.ship));
    const federationShips = ships.filter(p => p.ship.side === "FEDERATION").length;
    const empireShips = ships.filter(p => p.ship.side === "EMPIRE").length;

    return Object.freeze({
        timestamp: Date.now(),
        counts: Object.freeze({
            players: players.length,
            ships: ships.length,
            planets: planets.length,
            stars: stars.length,
            blackholes: blackholes.length,
            federationShips,
            empireShips,
            federationBases: federationBases.length,
            empireBases: empireBases.length,
        }),
    });
}

######## api/events.ts
// src/api/events.ts
import { Side } from "../settings.js";
import { Planet } from "../planet.js";
import { Player } from "../player.js";

// src/api/events.ts  (only the union shown here)
export type EventType =
    | "ship_moved"
    | "phaser"
    | "torpedo"
    | "planet_hit"
    | "planet_builds_changed"
    | "planet_energy_changed"
    | "planet_captured"
    | "base_built"
    | "planet_base_removed"
    | "base_destroyed"
    | "score_changed"
    | (string & {});


// Back-compat alias for code that still imports GameEventType
export type GameEventType = EventType;


type GridCoord = { v: number; h: number };

export type ShipMovedPayload = {
    // identity
    shipName: string;         // e.g., "ENTERPRISE"
    side: "FEDERATION" | "EMPIRE" | "ROMULAN" | string;

    // movement
    from: GridCoord;          // previous position
    to: GridCoord;            // new position
    distance: number;         // Chebyshev or steps moved (your choice)

    // optional niceties
    ts?: number;              // server time (added by hub anyway)
    meta?: Record<string, unknown>;
};

/** Minimal public shape we send to clients for a planet */
export type PlanetRef = {
    name: string;
    side: Side;
    position: { v: number; h: number };
    isBase: boolean;
    energy: number; // 0..1000 for bases; may be 0 for non-bases
    builds: number; // non-bases only; 0..N
};

/** Minimal attacker info (player ship), optional */
export type AttackerRef = {
    ship?: { name: string; side: Side } | null;
};

function planetRef(p: Planet): PlanetRef {
    return {
        name: p.name,
        side: p.side,
        position: { v: p.position.v, h: p.position.h },
        isBase: !!p.isBase,
        energy: p.energy ?? 0,
        builds: p.builds ?? 0,
    };
}

function attackerRef(by?: Player | null): AttackerRef | undefined {
    if (!by || !by.ship) return undefined;
    return { ship: { name: by.ship.name, side: by.ship.side } };
}

// Include both ts and t (alias) so clients reading either will work.
export type AnyEvent<T = unknown> = {
    id: number;       // monotonically increasing
    ts: number;       // epoch ms
    t: number;        // epoch ms (alias for ts, for older clients)
    type: EventType;  // event name
    payload: T;       // event payload
};

type Listener = (e: AnyEvent) => void;

export class EventHub {
    private seq = 0;
    private listeners = new Set<Listener>();
    private buffer: AnyEvent[] = [];
    private readonly maxBuffer: number;

    constructor(maxBuffer = 1000) {
        this.maxBuffer = Math.max(1, maxBuffer);
    }

    /** Emit an event and fan it out to subscribers. */
    emit<T = unknown>(evt: Omit<AnyEvent<T>, "id" | "ts" | "t">): AnyEvent<T> {
        const now = Date.now();
        const e: AnyEvent<T> = {
            id: ++this.seq,
            ts: now,
            t: now,               // keep alias in sync
            type: evt.type,
            payload: evt.payload,
        };
        this.buffer.push(e);
        if (this.buffer.length > this.maxBuffer) this.buffer.shift();
        for (const l of this.listeners) {
            try {
                l(e);
            } catch {
                /* ignore listener errors */
            }
        }
        return e;
    }

    /** Subscribe; returns an unsubscribe function. */
    subscribe(fn: Listener): () => void {
        this.listeners.add(fn);
        return () => this.listeners.delete(fn);
    }

    /**
     * Get a backlog of events newer than `sinceId`.
     * Optionally filter by event types (Array or Set).
     * Back-compat name retained.
     */
    getSince(sinceId?: number, types?: EventType[] | Set<EventType>): AnyEvent[] {
        let out = sinceId ? this.buffer.filter(e => e.id > sinceId) : [...this.buffer];
        if (types && (Array.isArray(types) ? types.length : (types as Set<EventType>).size)) {
            const set = Array.isArray(types) ? new Set(types) : (types as Set<EventType>);
            out = out.filter(e => set.has(e.type));
        }
        return out;
    }

    /**
     * Snapshot helper used by the API. Same semantics as getSince,
     * but accepts Set or Array and returns a copy.
     */
    snapshot(sinceId?: number, types?: EventType[] | Set<EventType>): AnyEvent[] {
        return this.getSince(sinceId, types);
    }

    /** Latest emitted event id (0 if none). */
    latestId(): number {
        return this.seq;
    }

    /** Convenience for clearing during tests. */
    clear(): void {
        this.buffer.length = 0;
        this.seq = 0;
    }
}


/** Emit when a planet takes a hit (phaser/torpedo) */
export function emitPlanetHit(options: {
    planet: Planet;
    weapon: "phaser" | "torpedo";
    damage: number;         // final applied damage (to hull/energy)
    crit?: boolean;
    destroyed?: boolean;    // planet base destroyed this volley
    shieldBefore?: number;  // (optional) raw shield/energy before
    shieldAfter?: number;   // (optional) raw shield/energy after
    by?: Player | null;     // optional attacker
}) {
    const {
        planet, weapon, damage, crit = false, destroyed = false,
        shieldBefore, shieldAfter, by
    } = options;

    gameEvents.emit({
        type: "planet_hit",
        payload: {
            planet: planetRef(planet),
            weapon,
            damage: Math.round(damage),
            crit,
            destroyed,
            shieldBefore,
            shieldAfter,
            by: attackerRef(by),
        },
    });
}

/** Emit when planet builds count changes (non-base planets) */
export function emitPlanetBuildsChanged(options: {
    planet: Planet;
    delta: number;             // +1/-1/etc.
    newBuilds: number;
    reason?: string;           // optional note: "phaser", "event", etc.
    by?: Player | null;
}) {
    const { planet, delta, newBuilds, reason, by } = options;

    gameEvents.emit({
        type: "planet_builds_changed",
        payload: {
            planet: planetRef(planet),
            delta,
            newBuilds,
            reason,
            by: attackerRef(by),
        },
    });
}

/** Emit when base energy (0..1000) changes (e.g., drain/collapse) */
export function emitPlanetEnergyChanged(options: {
    planet: Planet;
    prev: number;
    next: number;
    reason?: string;           // "phaser_drain", "torp_deflect", etc.
    by?: Player | null;
}) {
    const { planet, prev, next, reason, by } = options;

    gameEvents.emit({
        type: "planet_energy_changed",
        payload: {
            planet: planetRef(planet),
            prev,
            next,
            reason,
            by: attackerRef(by),
        },
    });
}

/** Emit when a base is constructed on a planet */
export function emitBaseBuilt(options: {
    planet: Planet;
    by?: Player | null;
}) {
    const { planet, by } = options;

    gameEvents.emit({
        type: "base_built",
        payload: {
            planet: planetRef(planet),
            by: attackerRef(by),
        },
    });
}

/** Emit when a base is destroyed / removed from the map */
export function emitBaseDestroyed(options: {
    planet: Planet;
    by?: Player | null;
    reason?: "combat" | "collapse" | "script" | string;
}) {
    const { planet, by, reason = "combat" } = options;

    gameEvents.emit({
        type: "base_destroyed",
        payload: {
            planet: planetRef(planet),
            by: attackerRef(by),
            reason,
        },
    });
}

/** Optional: side flips due to conquest/capture */
export function emitPlanetCaptured(options: {
    planet: Planet;
    prevSide: Side;
    nextSide: Side;
    by?: Player | null;
}) {
    const { planet, prevSide, nextSide, by } = options;

    gameEvents.emit({
        type: "planet_captured",
        payload: {
            planet: planetRef(planet),
            prevSide,
            nextSide,
            by: attackerRef(by),
        },
    });
}
/** When a planet becomes a base(makeBase). */
export function emitPlanetBaseCreated(p: {
    id?: string | number;
    name?: string;
    side: string;
    position: { v: number; h: number };
    energy: number;
    builds?: number;
}) {
    gameEvents.emit({
        type: "planet_base_created",
        payload: {
            id: p.id ?? null,
            name: p.name ?? null,
            side: p.side,
            position: p.position,
            energy: p.energy,
            builds: p.builds ?? 0,
        },
    });
}


/**
 * When a base is removed (either destroyed by combat or demoted/admin action).
 * reason: "destroyed" | "demoted" | "manual"
 */
export function emitBaseRemoved(p: {
    id?: string | number;
    name?: string;
    side: string;
    position: { v: number; h: number };
    energy: number;
    builds?: number;
}, opts?: {
    reason?: "destroyed" | "demoted" | "manual";
    byPlayerId?: string | number;
    byShipName?: string;
}) {
    gameEvents.emit({
        type: "planet_base_removed",
        payload: {
            id: p.id ?? null,
            name: p.name ?? null,
            side: p.side,            // note: we keep the side for FORTRAN parity
            position: p.position,
            energy: p.energy,
            builds: p.builds ?? 0,
            reason: opts?.reason ?? "destroyed",
            byPlayerId: opts?.byPlayerId ?? null,
            byShipName: opts?.byShipName ?? null,
        },
    });
}

// Single shared hub for the whole app.
export const gameEvents = new EventHub(2000);

######## api/pagination.ts
// Tiny, lint-safe pagination helper

export type PageParams = Readonly<{
    page?: number;      // 1-based
    pageSize?: number;  // max items per page
    maxPageSize?: number; // enforcement cap
}>;

export type PageResult<T> = Readonly<{
    page: number;
    pageSize: number;
    total: number;
    items: readonly T[];
}>;

export function paginate<T>(
    source: readonly T[],
    params: PageParams = {}
): PageResult<T> {
    const total = source.length;
    const maxPageSize = Math.max(1, params.maxPageSize ?? 500);
    const pageSize = Math.min(Math.max(1, params.pageSize ?? 50), maxPageSize);
    const page = Math.max(1, params.page ?? 1);

    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    const items = source.slice(start, end);

    return { page, pageSize, total, items };
}

######## api/provider.ts
// Read-only provider interface the API consumes (no game imports here)
import type {
    SummaryDTO,
    PlayerDTO,
    PlanetDTO,
    StarDTO,
    BlackholeDTO,
    BaseDTO,
} from "./dto.js";

export interface GameStateProvider {
    getSummary(): Readonly<SummaryDTO>;
    listPlayers(): readonly Readonly<PlayerDTO>[];
    listPlanets(): readonly Readonly<PlanetDTO>[];
    listStars(): readonly Readonly<StarDTO>[];
    listBlackholes(): readonly Readonly<BlackholeDTO>[];
    listBases(): readonly Readonly<BaseDTO>[];
}

######## api/server.ts
// src/api/server.ts
import express from "express";
import type { Request, Response } from "express";
import cors from "cors";

import type { GameStateProvider } from "./provider.js";
import { gameEvents, type EventType } from "./events.js";

/**
 * Start the read-only API server with a provider injected from the game process.
 * The API stays decoupled from game internals (no game imports here, only the event hub).
 */
export function startApiServer(provider: GameStateProvider, opts?: { port?: number }) {
    const app = express();
    app.use(cors());
    app.use(express.json());

    app.get("/api/health", (_req: Request, res: Response) => {
        res.json({ ok: true });
    });

    app.get("/api/summary", (_req: Request, res: Response) => {
        res.json(provider.getSummary());
    });

    app.get("/api/players", (_req: Request, res: Response) => {
        res.json(provider.listPlayers());
    });

    app.get("/api/planets", (_req: Request, res: Response) => {
        res.json(provider.listPlanets());
    });

    app.get("/api/stars", (_req: Request, res: Response) => {
        res.json(provider.listStars());
    });

    app.get("/api/blackholes", (_req: Request, res: Response) => {
        res.json(provider.listBlackholes());
    });

    app.get("/api/bases", (_req: Request, res: Response) => {
        res.json(provider.listBases());
    });

    /* -------------------------
     * LIVE EVENTS (SSE + snapshot)
     * ------------------------- */

    // GET /api/events
    //   ?types=phaser,torpedo      (optional filter)
    //   ?since=1234                (optional catch-up; or use Last-Event-ID)
    app.get("/api/events", (req, res) => {
        // SSE headers
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache, no-transform");
        res.setHeader("Connection", "keep-alive");
        res.flushHeaders?.();

        const typeParam = (req.query.types as string | undefined) ?? "";
        const typesArr = typeParam
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean) as EventType[];

        const sinceQs = req.query.since ? Number(req.query.since) : undefined;
        const sinceHeader = req.header("Last-Event-ID")
            ? Number(req.header("Last-Event-ID"))
            : undefined;
        const since = Number.isFinite(sinceQs)
            ? sinceQs
            : Number.isFinite(sinceHeader)
                ? sinceHeader
                : undefined;

        // Helper to write SSE event
        const send = (evt: any) => {
            res.write(`event: ${evt.type}\n`);
            res.write(`id: ${evt.id}\n`);
            res.write(`data: ${JSON.stringify(evt)}\n\n`);
        };

        // Initial replay (if any)
        const replay = gameEvents.getSince(since, typesArr.length ? typesArr : undefined);
        for (const evt of replay) send(evt);

        // Subscribe to new events
        const unsub = gameEvents.subscribe((evt) => {
            if (typesArr.length && !typesArr.includes(evt.type)) return;
            send(evt);
        });

        // Heartbeat
        const heartbeat = setInterval(() => res.write(`: ping ${Date.now()}\n\n`), 15000);

        // Cleanup
        req.on("close", () => {
            clearInterval(heartbeat);
            unsub();
        });
    });

    // GET /api/events/snapshot?since=123&types=a,b
    app.get("/api/events/snapshot", (req, res) => {
        const since = req.query.since ? Number(req.query.since) : undefined;

        const typeParam = (req.query.types as string | undefined) ?? "";
        const typesArr = typeParam
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean) as EventType[];

        const events = gameEvents.getSince(
            Number.isFinite(since) ? since : undefined,
            typesArr.length ? typesArr : undefined
        );

        // Compute latest id from the entire buffer, not just filtered set
        const globalLatest = gameEvents.getSince(undefined).slice(-1)[0]?.id ?? 0;

        res.json({
            latest: globalLatest,
            count: events.length,
            events,
        });
    });

    const port = Number(process.env.API_PORT ?? opts?.port ?? 3001);
    return app.listen(port, () => {
        console.log(`[api] listening on http://localhost:${port}`);
    });
}

######## api/sse.ts
// src/api/sse.ts
import { Router, type Request, type Response } from "express";
import { gameEvents, type AnyEvent } from "./events.js";

export const sseRouter = Router();

/**
 * GET /api/events
 *  - Live SSE stream.
 *  - Supports Last-Event-ID header or ?since=<id>
 *  - Filter by ?types=phaser,torpedo,planet_captured
 */
sseRouter.get("/events", (req: Request, res: Response) => {
    // CORS should be handled by your server.ts; this path only sets SSE headers
    res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
    res.setHeader("Cache-Control", "no-cache, no-transform");
    res.setHeader("Connection", "keep-alive");
    // allow proxies to stream
    res.flushHeaders?.();

    const sinceParam = req.query.since ? Number(req.query.since) : undefined;
    const lastIdHeader = req.header("Last-Event-ID");
    const since = Number.isFinite(sinceParam) ? sinceParam
        : lastIdHeader ? Number(lastIdHeader)
            : undefined;

    const typesParam = typeof req.query.types === "string" ? req.query.types : undefined;
    const types = typesParam ? (typesParam.split(",").map(s => s.trim()).filter(Boolean) as Array<AnyEvent["type"]>) : undefined;

    // 1) Send backlog (if any)
    const backlog = gameEvents.getSince(since, types);
    for (const e of backlog) writeEvent(res, e);

    // 2) Subscribe to live events
    const sub = gameEvents.subscribe((e) => {
        if (types && !types.includes(e.type)) return;
        writeEvent(res, e);
    });

    // 3) Keepalive
    const ping = setInterval(() => { res.write(`: ping ${Date.now()}\n\n`); }, 25_000);

    // 4) Cleanup
    req.on("close", () => {
        clearInterval(ping);
        sub();
    });
});

function writeEvent(res: Response, e: AnyEvent): void {
    res.write(`id: ${e.id}\n`);
    res.write(`event: ${String(e.type)}\n`);
    res.write(`data: ${JSON.stringify(e)}\n\n`);
}

######## bases.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";

export function basesCommand(player: Player, command: Command): void {
    const newArgs = ["BASES", ...command.args];
    listCommand(player, { ...command, args: newArgs });
}

######## blackhole.ts
import { findObjectAtPosition, Position } from './coords.js';
import { GRID_HEIGHT, GRID_WIDTH } from './settings.js';
import { blackholes } from './game.js';
import { getRandom } from './util/random.js';


export class Blackhole {
    position: Position;

    constructor(v: number, h: number) {
        this.position = { v, h };
    }

    static generate(count: number = 10): Blackhole[] {
        let attempts = 0;

        while (blackholes.length < count && attempts < 1000) {
            const v = Math.floor(getRandom() * GRID_HEIGHT) + 1;
            const h = Math.floor(getRandom() * GRID_WIDTH) + 1;

            if (!findObjectAtPosition(v, h)) {
                blackholes.push(new Blackhole(v, h));
            }

            attempts++;
        }
        return blackholes;
    }
}



######## bots/bot.ts
// bot.ts — simple role-aware AI pilots for NPC ships

import { Player } from "../player.js";
import { Planet } from "../planet.js";
import { bases, planets, players } from "../game.js";
import { settings } from "../settings.js";
import { chebyshev } from "../coords.js";
import { addPendingMessage } from "../communication.js";
import { applyPhaserDamage } from "../phaser.js";
import { torpedoDamage } from "../torpedo.js";

export type BotRole = "aggressor" | "defender" | "raider";

/** lightweight state stored on the Player (no `any`) */
type BotState = Readonly<{
    botRole: BotRole;
    nextPhaserAt: number;
    nextTorpAt: number;
}>;

type Target =
    | { kind: "ship"; player: Player; distance: number }
    | { kind: "base"; planet: Planet; distance: number }
    | { kind: "planet"; planet: Planet; distance: number };

const SEARCH_RANGE = 20;
const PHA_PHIT = 0.4;            // parity with PHACON-scaled value
const PHA_COOLDOWN_MS = 750;     // scaled by active count below
const TORP_COOLDOWN_MS = 1000;   // scaled by active count below

// ----- tiny util: FORTRAN-like dice (1..n) -----
function iran(n: number): number {
    return Math.floor(Math.random() * n) + 1;
}

// ----- attach & query bot state safely (no `any`) -----
const BOT_KEY = Symbol("botState");
declare module "../player.js" {
    interface Player {
        // hidden symbol property
        [BOT_KEY]?: BotState;
    }
}

function setBotState(p: Player, s: BotState): void {
    p[BOT_KEY] = s;
}

function getBotState(p: Player): BotState | undefined {
    return p[BOT_KEY];
}

// public: mark a player as a bot with a specific role
export function registerBot(player: Player, role: BotRole): void {
    const now = Date.now();
    setBotState(player, {
        botRole: role,
        nextPhaserAt: now,
        nextTorpAt: now,
    });
}

// public: convenience to create a bot out of an existing Player
export function makeAggressorBot(player: Player): void {
    registerBot(player, "aggressor");
}
export function makeDefenderBot(player: Player): void {
    registerBot(player, "defender");
}
export function makeRaiderBot(player: Player): void {
    registerBot(player, "raider");
}

// ----- role helpers -----
function weaponPreferenceForRole(role: BotRole): "phaser" | "torpedo" | "mixed" {
    if (role === "aggressor") return "torpedo";
    if (role === "defender") return "phaser";
    return "mixed"; // raider
}

function stepForRole(role: BotRole): number {
    if (role === "aggressor") return 4;
    if (role === "defender") return 2;
    return 3; // raider
}

function basePauseScale(): number {
    const active = players.filter(p => p.ship && p.ship.energy > 0).length;
    return Math.max(1, active + 1);
}

// ----- main tick for all bots -----
export function updateBots(): void {
    //console.log("updateBots");
    if (!settings.generated) return;
    //console.log("updateBots2");

    const now = Date.now();

    for (const p of players) {
        if (!p.ship) continue;
        const state = getBotState(p);
        if (!state) continue; // not a bot

        // 1) choose target in range
        const target = chooseTarget(p);
        if (!target) continue;

        // 2) movement: close distance (don’t enter target tile)
        const tpos =
            target.kind === "ship"
                ? (target.player.ship ? target.player.ship.position : null)
                : target.planet.position;
        if (tpos) moveToward(p, tpos, stepForRole(state.botRole));

        // 3) weapon selection: role + context
        const pref = weaponPreferenceForRole(state.botRole);
        const preferTorp =
            pref === "torpedo"
                ? Math.random() < 0.75
                : pref === "phaser"
                    ? Math.random() < 0.25
                    : target.kind === "ship"
                        ? Math.random() < 0.6
                        : Math.random() < 0.4;

        const canPhaser = now >= state.nextPhaserAt;
        const canTorp = now >= state.nextTorpAt;

        // fallback: pick whatever is ready
        let useTorpedo = preferTorp ? canTorp || !canPhaser : false;
        if (!preferTorp) {
            useTorpedo = canTorp && !canPhaser ? true : false;
        }
        // if neither available, skip this tick
        if (!canPhaser && !canTorp) continue;

        // 4) fire
        if (useTorpedo && canTorp) {
            fireBotTorpedo(p, target);
            const next = now + basePauseScale() * TORP_COOLDOWN_MS;
            setBotState(p, { ...state, nextTorpAt: next });
        } else if (canPhaser) {
            fireBotPhaser(p, target);
            const next = now + basePauseScale() * PHA_COOLDOWN_MS;
            setBotState(p, { ...state, nextPhaserAt: next });
        }
    }
}

// ----- target selection (role-aware weighting) -----
function chooseTarget(bot: Player): Target | null {
    if (!bot.ship) return null;
    const me = bot.ship;

    const enemySides: ReadonlyArray<typeof me.side> =
        me.side === "FEDERATION" ? ["EMPIRE"]
            : me.side === "EMPIRE" ? ["FEDERATION"]
                : ["FEDERATION", "EMPIRE"]; // neutral/romulan -> both

    const bpos = me.position;
    const candidates: Target[] = [];

    // enemy ships
    for (const p of players) {
        if (!p.ship || p === bot) continue;
        if (!enemySides.includes(p.ship.side)) continue;
        const d = chebyshev(p.ship.position, bpos);
        if (d <= SEARCH_RANGE) candidates.push({ kind: "ship", player: p, distance: d });
    }

    // enemy bases
    for (const side of enemySides) {
        const list = side === "FEDERATION" ? bases.federation : bases.empire;
        for (const base of list) {
            const d = chebyshev(base.position, bpos);
            if (d <= SEARCH_RANGE) candidates.push({ kind: "base", planet: base, distance: d });
        }
    }

    // enemy planets (non-bases)
    for (const pl of planets) {
        if (pl.isBase) continue;
        if (!enemySides.includes(pl.side)) continue;
        const d = chebyshev(pl.position, bpos);
        if (d <= SEARCH_RANGE) candidates.push({ kind: "planet", planet: pl, distance: d });
    }

    if (candidates.length === 0) return null;

    const role = getBotState(bot)?.botRole ?? "aggressor";

    const weight = (t: Target): number => {
        switch (role) {
            case "aggressor":
                return t.kind === "ship" ? 1.0 : t.kind === "base" ? 0.7 : 0.4;
            case "defender": {
                // prefer enemies close to our own bases
                if (t.kind === "ship" && t.player.ship) {
                    const nb = nearestFriendlyBase(bot, t.player.ship.position);
                    const dToBase = nb ? chebyshev(t.player.ship.position, nb.position) : 99;
                    return 1.0 + (20 - Math.min(20, dToBase)) * 0.03;
                }
                return t.kind === "base" ? 0.6 : 0.4;
            }
            case "raider":
                return t.kind === "base" ? 1.0 : t.kind === "planet" ? 0.9 : 0.5;
        }
    };

    candidates.sort((a, b) => {
        const wdiff = weight(b) - weight(a);
        if (wdiff !== 0) return wdiff;          // higher weight first
        return a.distance - b.distance;         // then nearest
    });

    return candidates[0] ?? null;
}

function nearestFriendlyBase(bot: Player, pos: { v: number; h: number }): Planet | null {
    const side = bot.ship?.side ?? "NEUTRAL";
    const list = side === "FEDERATION" ? bases.federation : side === "EMPIRE" ? bases.empire : [];
    let best: Planet | null = null;
    let bestD = Number.MAX_SAFE_INTEGER;
    for (const b of list) {
        const d = chebyshev(b.position, pos);
        if (d < bestD) { best = b; bestD = d; }
    }
    return best;
}

// ----- movement (grid steps; don’t enter target tile) -----
function moveToward(bot: Player, dest: { v: number; h: number }, maxSteps: number): void {
    if (!bot.ship) return;

    const from = bot.ship.position;
    const dv = dest.v - from.v;
    const dh = dest.h - from.h;
    const dist = Math.max(Math.abs(dv), Math.abs(dh));
    if (dist <= 1) return; // already adjacent, don’t move

    const steps = Math.min(maxSteps, Math.max(0, dist - 1));
    const sv = Math.sign(dv);
    const sh = Math.sign(dh);

    const diag = Math.min(steps, Math.min(Math.abs(dv), Math.abs(dh)));
    const rem = steps - diag;

    const extraV = Math.min(rem, Math.max(0, Math.abs(dv) - diag));
    const extraH = Math.min(rem, Math.max(0, Math.abs(dh) - diag));

    const v = from.v + sv * (diag + extraV);
    const h = from.h + sh * (diag + extraH);

    bot.ship.position = { v, h };
}

// ----- weapons -----
function fireBotPhaser(bot: Player, target: Target): void {
    if (!bot.ship) return;

    const tgt: Player | Planet =
        target.kind === "ship" ? target.player :
            target.kind === "base" ? target.planet :
                target.planet;

    const res = applyPhaserDamage(bot, tgt, PHA_PHIT);

    if (target.kind === "ship") {
        addPendingMessage(target.player, `${bot.ship.name} hits you with phasers for ${Math.round(res.hita)}.`);
    }
}

function fireBotTorpedo(bot: Player, target: Target): void {
    if (!bot.ship) return;

    if (target.kind === "ship") {
        torpedoDamage(bot, target.player);
    } else {
        torpedoDamage(bot, target.planet);
    }
}

// ----- optional speaking flavor -----
export function botChatterTick(): void {
    // very lightweight: a couple times per sweep
    for (const p of players) {
        const st = getBotState(p);
        if (!st || !p.ship) continue;
        if (iran(20) !== 1) continue;

        const line =
            st.botRole === "aggressor"
                ? "Target acquired. Moving to engage."
                : st.botRole === "defender"
                    ? "Holding defensive perimeter."
                    : "Hunting logistics targets.";

        addPendingMessage(p, `${p.ship.name}: ${line}`);
    }
}

######## bots/register.ts
// bots/spawn.ts
import { Player } from "../player.js";
import { Ship } from "../ship.js";
import { NullSocket } from "../util/nullsocket.js";
import { players, pointsManager } from "../game.js";
import { findEmptyLocation } from "../coords.js";
import { FEDERATION_SHIPS, EMPIRE_SHIPS, type Side } from "../settings.js";
export type BotRole = "aggressor" | "defender" | "raider" | "patrol";



export function registerBot(player: Player, role: BotRole): void {
    // attach role/state to the player or track in a Map
    // and make sure your main tick calls your bot loop
    (player as unknown as { botRole?: BotRole }).botRole = role;
}


function listTakenUppercase(): Set<string> {
    const taken = new Set<string>();
    for (const p of players) {
        const name = p.ship?.name;
        if (name) taken.add(name.toUpperCase());
    }
    return taken;
}

/**
 * Prefer a free roster name for the side.
 * If `preferred` is provided, it must be in the roster and free to be used.
 * Only synthesize a BOT-* name if the roster is fully taken.
 */
export function pickAvailableShipName(side: Side, preferred?: string): string {
    const roster = side === "FEDERATION" ? FEDERATION_SHIPS : EMPIRE_SHIPS;
    const taken = listTakenUppercase();

    // 1) Use a free roster name (PRIMARY path)
    for (const name of roster) {
        if (!taken.has(name.toUpperCase())) return name;
    }

    // 2) If roster is exhausted, allow a preferred name only if it's free and in roster (rare case)
    if (preferred) {
        const candidate = preferred.trim();
        if (
            candidate &&
            roster.some(r => r.toUpperCase() === candidate.toUpperCase()) &&
            !taken.has(candidate.toUpperCase())
        ) {
            return candidate;
        }
    }

    // 3) Last resort: synthesize a unique BOT-* name
    let i = 1;
    while (true) {
        const synth = `${side === "FEDERATION" ? "F" : "E"}-BOT-${i}`;
        if (!taken.has(synth.toUpperCase())) return synth;
        i += 1;
    }
}

export function spawnAndRegisterBot(
    role: BotRole,
    side: Side,
    preferredShipName?: string
): Player {
    const bot = new Player(new NullSocket());//, { isBot: true });

    // IMPORTANT: call pickAvailableShipName BEFORE pushing the player to `players`
    const shipName = pickAvailableShipName(side, preferredShipName);

    bot.ship = new Ship(bot);
    bot.ship.name = shipName;
    bot.ship.side = side;
    bot.ship.energy = 5000;
    bot.ship.shieldEnergy = 0;
    bot.ship.damage = 0;
    bot.ship.torpedoes = 10;

    bot.settings.name = shipName; // keep label in sync

    bot.ship.position = findEmptyLocation() ?? { v: 1, h: 1 };

    players.push(bot);

    (pointsManager as unknown as { incrementShipsCommissioned?(s: Side): void })
        .incrementShipsCommissioned?.(side);

    registerBot(bot, role);
    return bot;
}
######## build.ts
import { getCoordsFromCommandArgs, chebyshev, ocdefCoords } from "./coords.js";
import { planets } from "./game.js";
import { MAX_BUILDS_PER_PLANET, BUILD_DELAY_MIN_MS, BUILD_DELAY_RANGE, MAX_BASES_PER_TEAM } from "./settings.js";
import { putClientOnHold, releaseClient, sendOutputMessage, sendMessageToClient } from "./communication.js";
//import { starbasePhaserDefense } from "./base.js";
import { bases } from "./game.js";
import { Player } from "./player.js";
import { Command } from "./command.js";
import { gameEvents } from "./api/events.js";

export function buildCommand(player: Player, command: Command, done?: () => void): void {
    if (command.args.length < 2) {
        sendMessageToClient(player, "Usage: BUILD [A|R] <vpos> <hpos> — specify vertical and horizontal coordinates.");
        done?.();
        return;
    }
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to build.");
        done?.();
        return;
    }

    const { position: { v: targetV, h: targetH }, mode, error } =
        getCoordsFromCommandArgs(player, command.args, player.ship.position.v, player.ship.position.h, false);

    if (error) {
        sendMessageToClient(player, `${error} for mode ${mode}`);
        done?.();
        return;
    }

    if (chebyshev(player.ship.position, { v: targetV, h: targetH }) > 1) {
        sendMessageToClient(player, "BUILD failed: you must be adjacent (1 grid unit) to the target planet.");
        done?.();
        return;
    }

    const planet = planets.find(p => p.position.h === targetH && p.position.v === targetV);

    if (!planet) {
        const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v: targetV, h: targetH });
        sendMessageToClient(player, `No known planet at ${coords}. BUILD aborted.`);
        done?.();
        return;
    }

    if (planet.side === "NEUTRAL") {
        sendMessageToClient(player, "Planet not yet captured.");
        done?.();
        return;
    }

    if (planet.side !== player.ship.side) {
        sendMessageToClient(player, `BUILD denied: planet is held by the ${planet.side}.`);
        done?.();
        return;
    }

    if (planet.builds >= MAX_BUILDS_PER_PLANET) {
        sendMessageToClient(player, "BUILD limit reached: this planet is fully fortified.");
        done?.();
        return;
    }

    const delayMs = BUILD_DELAY_MIN_MS + Math.random() * BUILD_DELAY_RANGE;

    putClientOnHold(player, "Building...");
    const timer = setTimeout(() => {
        releaseClient(player);
        if (!player.ship) {
            sendMessageToClient(player, "You must be in a ship to build.");
            done?.();
            return;
        }

        planet.builds += 1;

        gameEvents.emit({
            type: "planet_builds_changed",
            payload: {
                planet: {
                    name: planet.name,
                    side: planet.side,
                    position: { v: planet.position.v, h: planet.position.h },
                    builds: planet.builds
                },
                by: {
                    shipName: player.ship!.name,
                    side: player.ship!.side
                }
            }
        });

        if (planet.builds === 5) {
            player.points.basesBuilt += 1;
        }
        if (planet.builds === MAX_BUILDS_PER_PLANET) {
            const teamBases = player.ship.side === "FEDERATION" ? bases.federation : bases.empire;
            if (teamBases.length >= MAX_BASES_PER_TEAM + 10) {  // TODO: remove the + 10
                sendMessageToClient(player, `Maximum number of ${player.ship.side} starbases already active.`);
                done?.();
                return;
            }

            planet.makeBase(player.ship.side);

            const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v: targetV, h: targetH });

            sendOutputMessage(player, {
                SHORT: `Base created.`,
                MEDIUM: `Starbase built at ${coords}.`,
                LONG: `Planet at ${coords} has been promoted to a fully operational starbase.`,
            });

            gameEvents.emit({
                type: "planet_base_created",
                payload: {
                    planet: {
                        name: planet.name,
                        side: planet.side,
                        position: { v: planet.position.v, h: planet.position.h },
                        energy: planet.energy,          // DEFAULT_BASE_ENERGY after makeBase()
                        builds: planet.builds
                    },
                    by: {
                        shipName: player.ship!.name,
                        side: player.ship!.side
                        // If you want, you can also include: ip: player.auth?.ip
                    }
                }
            });
        }
        else {
            const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v: targetV, h: targetH });

            sendOutputMessage(player, {
                SHORT: `+1 build.`,
                MEDIUM: `Now ${planet.builds} build${planet.builds === 1 ? "" : "s"}.`,
                LONG: `One build added. Planet at ${coords} now has ${planet.builds} build${planet.builds === 1 ? "" : "s"}.`,
            });
        }
        done?.();
    }, delayMs);
    player.currentCommandTimer = timer;
    //starbasePhaserDefense(player); TODO: Add starbase phaser defense
}

######## capture.ts
import { Command } from "./command.js";
import { CAPTURE_DELAY_MIN_MS } from "./settings.js";
import {
    sendMessageToClient,
    putClientOnHold,
    releaseClient,
    sendOutputMessage,
    sendMessageToOthers,
} from "./communication.js";
import { getCoordsFromCommandArgs, ocdefCoords, chebyshev } from "./coords.js";
import { Player } from "./player.js";
import { planets, pointsManager, players, blackholes, stars, checkEndGame } from "./game.js";
import { applyDamage } from "./torpedo.js"; // adjust path if your applyDamage lives elsewhere


//  import { starbasePhaserDefense } from "./phaser.js"; //TODO: verify this isn't a real part of classic game

export function captureCommand(player: Player, command: Command, done?: () => void): void {
    if (command.args.length < 2) {
        sendMessageToClient(
            player,
            "Usage: CAPTURE [A|R] <vpos> <hpos> — must specify coordinates of target planet. Example: CAPTURE 10 25\r\n"
        );
        done?.();
        return;
    }

    if (player.ship === null) {
        sendMessageToClient(player, "You must be in a ship to use the capture command.\r\n");
        done?.();
        return;
    }

    const { position: { v: targetV, h: targetH }, mode, error } = getCoordsFromCommandArgs(
        player,
        command.args,
        player.ship.position.v,
        player.ship.position.h,
        false
    );

    if (error) {
        sendMessageToClient(player, `${error} for mode ${mode}\r\n`);
        done?.();
        return;
    }

    const planet = planets.find(p => p.position.h === targetH && p.position.v === targetV);
    if (!planet) {
        const shipAtTarget = players.some(p => p.ship && p.ship.position.h === targetH && p.ship.position.v === targetV);
        const blackHoleAtTarget = blackholes.some(bh => bh.position.h === targetH && bh.position.v === targetV);
        const starAtTarget = stars.some(star => star.position.h === targetH && star.position.v === targetV);

        if (shipAtTarget || blackHoleAtTarget || starAtTarget) {
            sendMessageToClient(player, "Capture THAT??  You have GOT to be kidding!!!\r\n");
            done?.();
            return;
        } else {
            sendMessageToClient(player, `No planet at those coordinates, Captain.\r\n`);
            done?.();
            return;
        }
    }

    if (planet.isBase && planet.side !== player.ship.side) {
        sendMessageToClient(player, `Captain, the enemy refuses our surrender ultimatum!\r\n`);
        done?.();
        return;
    }

    if (chebyshev(player.ship.position, { v: targetV, h: targetH }) > 1) {
        sendMessageToClient(player, `${player.ship.name} not adjacent to planet.\r\n`);
        done?.();
        return;
    }

    if (planet.side === player.ship.side) {
        const val = Math.random();
        if (val < 0.33) {
            sendMessageToClient(player, `Planet already captured, sir.\r\n`);
        } else if (val < 0.66) {
            sendMessageToClient(player, `But Captain, he's already on our side!\r\n`);
        } else {
            sendMessageToClient(player, `Captain, are you feeling well?\r\nWe are orbiting a FEDERATION planet!\r\n`);
        }
        done?.();
        return;
    }

    if (planet.captureLock.status) {
        sendMessageToClient(player, `The planet's government refuses to surrender.\r\n`);
        done?.();
        return;
    }

    // removed via Harris reported bug
    // if (player.ship.shieldsUp && player.ship.shieldEnergy > 0) {
    //     sendMessageToClient(player, "CAPTURE denied: shields must be lowered.");
    //     done?.();
    //     return;
    // }

    const hit = 50 + (planet.builds * 30);
    const captureDelayMs = planet.builds * 1000 + CAPTURE_DELAY_MIN_MS;

    if (planet.side !== "NEUTRAL" && planet.side !== player.ship.side) {
        const energyCost = planet.builds * 50;

        if (player.ship.energy < energyCost) {
            sendMessageToClient(player, `Insufficient energy: ${energyCost} required to CAPTURE this planet.\r\n`);
            done?.();
            return;
        }

        player.ship.energy -= energyCost;
    }

    const coords = ocdefCoords(player.settings.ocdef,
        player.ship!.position,
        { v: targetV, h: targetH });

    planet.captureLock = {
        status: true,
        time: Date.now(),
    };

    putClientOnHold(player, `${player.ship.name} capturing ${planet.side} planet ${coords}...`);

    const timer = setTimeout(() => {
        planet.captureLock.status = false;   // Reset capture lock status
        releaseClient(player);

        //const phaserDamage = 50 + (30 * buildLevel);
        // applyPhaserShipDamage(player, { x: planet.position.x, y: planet.position.y, side: planet.side }, phaserDamage);
        //TODO: add this back in

        if (!player.ship) {
            done?.();
            return;
        }
        const oldSide = planet.side;
        planet.builds = 0;
        planet.isBase = false;
        planet.side = player.ship.side;
        planet.captureLock.status = false;

        let othersMsg = `${player.ship!.name} has captured planet at ${coords}.`;
        if (planet.side === "NEUTRAL") {
            othersMsg = `${player.ship!.name} has captured a neutral planet at ${coords}.`;
        } else {
            othersMsg = `${player.ship!.name} has captured a planet at ${coords} from the ${oldSide}.`;
        }

        pointsManager.addPlanetsCaptured(1, player, player.ship!.side);

        sendMessageToOthers(player, othersMsg);
        sendOutputMessage(player, {
            SHORT: `captured.`,
            MEDIUM: `captured.`,
            LONG: `captured.`,
        });

        const res = applyDamage(planet, player, hit, Math.random());

        // Message only if something actually landed
        if (res.hita > 0) {
            sendMessageToClient(
                player,
                `Planetary resistance hit your ship for ${Math.round(res.hita)} damage.`
            );
        }

        // If the capture backlash killed the player, advance endgame checks
        if (res.isDestroyed) {
            checkEndGame();
        }

        done?.();
    }, captureDelayMs);

    player.currentCommandTimer = timer;
}

######## command.ts
import { Player } from './player.js';
import { promoteCommand } from './util/admin.js';
import { usersCommand } from './users.js';
import { moveCommand } from './move.js';
import { helpCommand } from './help.js';
import { shieldCommand } from './shield.js';
import { radioCommand } from './radio.js';
import { planetsCommand } from './planets.js';
import { captureCommand } from './capture.js';
import { buildCommand } from './build.js';
import { dockCommand } from './dock.js';
import { shortRangeScanCommand } from './srs.js';
import { statusCommand } from './status.js';
import { pointsCommand } from './points.js';
import { summaryCommand } from './summary.js';
import { listCommand } from './list.js';
import { basesCommand } from './bases.js';
import { targetsCommand } from './targets.js';
import { tellCommand } from './tell.js';
import { setCommand } from './set.js';
import { phaserCommand } from './phaser.js';
import { newsCommand } from './news.js';
import { torpedoCommand } from './torpedo.js';
import { repairCommand } from './repair.js';
import { scanCommand } from './scan.js';
import { timeCommand } from './time.js';
import { tractorCommand } from './tractor.js';
import { impulseCommand } from './move.js';
import { energyCommand } from './energy.js';
import { damagesCommand } from './damage.js';
import { typeCommand } from './type.js';
import { gripeCommand } from './gripe.js';
import { quitCommand } from './quit.js';
import { restartCommand } from './util/restart.js';
import { clearCommand } from './util/clear.js';
import { sendMessageToClient } from './communication.js';
import { oveCommand } from './ove.js';
import { tweakCommand } from './tweak.js';
import { matchesPattern } from './util/util.js';
import { processTimeConsumingMove } from './game.js';

interface TokenizedInput {
    tokens: string[][];
}

// --- Command Class ---

export type CommandHandler = (player: Player, command: Command, done?: () => void) => void;

export class Command {
    constructor(
        public key: string,
        public args: string[],
        public raw: string,
    ) {
        this.key = key;
        this.args = args;
        this.raw = raw;
    }
}

// --- Command Registry ---

const decwarCommands = new Map<string, CommandHandler>([
    ["BAses", basesCommand],
    ["BUild", buildCommand],
    ["CApture", captureCommand],
    ["CLear", clearCommand],
    ["DAmages", damagesCommand],
    ["DOck", dockCommand],
    // //["UD", defaultHandler],
    ["Energy", energyCommand],
    ["GRipe", gripeCommand],
    ["Help", helpCommand],
    ["?", helpCommand],
    ["Impulse", impulseCommand],
    ["LIst", listCommand],
    ["Move", moveCommand],
    ["News", newsCommand],
    ["PHasers", phaserCommand],
    ["PLanets", planetsCommand],
    ["POints", pointsCommand],
    ["PRomote", promoteCommand],
    ["Quit", quitCommand],
    ["RAdio", radioCommand],
    ["REpair", repairCommand],
    ["RStart", restartCommand],
    ["SCan", scanCommand],
    ["SEt", setCommand],
    ["SHield", shieldCommand],
    ["SRscan", shortRangeScanCommand],
    ["STatus", statusCommand],
    ["SUmmary", summaryCommand],
    ["TArgets", targetsCommand],
    ["TEll", tellCommand],
    ["TIme", timeCommand],
    ["TOrpedo", torpedoCommand],
    ["TRactor", tractorCommand],
    ["TYpe", typeCommand],
    ["Users", usersCommand],
    ["Over", oveCommand],
    ["TWeak", tweakCommand]
]);

// --- Tokenization ---

export function tokenize(input: string): TokenizedInput {
    const commandPart = input.replace(/;/g, ' ; ');

    const rawCommands = commandPart
        .split("/")
        .map(cmd => cmd.trim())
        .filter(Boolean);

    const commands = rawCommands.map(cmd =>
        cmd
            .split(/[\s,]+/)
            .map(token => token.trim())
            .filter(Boolean)
    );

    return {
        tokens: commands
    };
}

export function queueCommands(player: Player, input: string): void {
    const parsed = tokenize(input);
    if (!parsed.tokens.length) return;

    for (const commandTokens of parsed.tokens) {
        player.commandQueue.push(commandTokens.join(" "));
    }

    processNextCommand(player);
}

export function processNextCommand(player: Player): void {

    if (player.processingCommand || player.commandQueue.length === 0) {
        sendMessageToClient(player, "", false, true);
        return;
    }

    const raw = player.commandQueue.shift();
    if (!raw) return;

    const tokens = raw.split(/\s+/);
    const commandKey = tokens[0].toUpperCase();
    const commandObject = new Command(commandKey, tokens.slice(1), raw);

    const matchedCommand = [...decwarCommands.entries()].find(
        ([key]) => matchesPattern(commandKey, key)
    )?.[1];

    if (!matchedCommand) {
        sendMessageToClient(player, `Unknown command: ${commandKey}`);
        return processNextCommand(player);
    }

    player.processingCommand = true;

    // Check arity to support legacy sync commands
    if (matchedCommand.length < 3) {
        matchedCommand(player, commandObject);
        player.processingCommand = false;
        //sendAllPendingMessages()
        processNextCommand(player);
    } else {
        matchedCommand(player, commandObject, () => {
            //gameSettings.timeConsumingMoves++;  PUT BACK TODO
            player.processingCommand = false;
            processNextCommand(player);
            processTimeConsumingMove(player);
        });
    }
}
######## communication.ts
import { players } from "./game.js";
import { chebyshev } from "./coords.js";
import { Player } from "./player.js";
import { Planet } from "./planet.js";

export type OutputVariants = {
    SHORT: string;
    MEDIUM: string;
    LONG: string;
};

export function addPendingMessage(player: Player, message: string): void {
    player.pendingMessages.push(message);
}

export function sendPendingMessages(player: Player): void {
    sendMessageToClient(player, '\r\n', false, false);
    const len = player.pendingMessages.length;
    for (let i = 0; i < len; i++) {
        const message = player.pendingMessages[i];
        if (i === len - 1) {
            sendMessageToClient(player, message, true, true);
        } else {
            sendMessageToClient(player, message, true, false);
        }
    }
    player.pendingMessages = [];
}

export function sendAllPendingMessages(): void {
    for (const player of players) {
        if (player.pendingMessages.length > 0) {
            sendPendingMessages(player);
        }
    }
}

export function sendMessageToClient(
    player: Player,
    message: string,
    returns = true,  // put return in output
    command = false   // if command then print prompt after
): void {
    if (!player.socket) return; // bots don't have a socket
    try {
        //player.socket.write('\r\x1b[K');

        if (returns) player.socket.write(`${message}\r\n`);
        else player.socket.write(`${message}`);
        if (command && !player.isOnHold) player.socket.write(`${player.getPrompt()}${player.inputBuffer}`);
    } catch (err: unknown) {
        console.error('Error in sendMessageToClient:', err instanceof Error ? err.message : String(err));
    }
}

export function sendMessageToOthers(player: Player | Planet, message: string, range: number = 10): void {
    let origin = { v: 0, h: 0 };
    if (player instanceof Player && player.ship) {
        origin = player.ship.position;
    } else if (player instanceof Planet) {
        origin = player.position;
    }

    for (const other of players) {
        if (other === player || !other.ship || !other.radioOn) continue;

        if (chebyshev(origin, other.ship.position) <= range) {
            sendMessageToClient(other, "\r\n" + message, true, true);
        }
    }
}

export function sendMessageToOthersWithFormat(
    origin: Player,
    formatter: (recipient: Player) => string
): void {
    players.forEach((recipient) => {
        if (recipient !== origin && recipient.ship) {
            const msg = formatter(recipient);
            addPendingMessage(recipient, msg);
        }
    });
}

export function sendOutputMessage(player: Player, variants: OutputVariants): void {
    const level = player.settings.output;
    const message = variants[level] ?? variants.LONG;
    sendMessageToClient(player, message);
}

// export function safeBroadcastMessage(
//     message: string,
//     returns = true,
//     command = true
// ): void {
//     for (const [socket, clientState] of clients.entries()) {
//         try {
//             socket.write('\r\x1b[K');
//             if (returns) socket.write(`${message}\r\n`);
//             else socket.write(`${message}`);
//             if (command) socket.write(` ${clientState.inputBuffer}`);
//         } catch (err: unknown) {
//             console.error('Error in safeBroadcastMessage:', err instanceof Error ? err.message : String(err));
//         }
//     }
// }

export function putClientOnHold(player: Player, message: string): void {
    player.isOnHold = true;
    if (message !== "") {
        sendMessageToClient(player, message, false, false);
    }
}

export function releaseClient(player: Player, message: string | null = null): void {
    player.isOnHold = false;
    if (message) {
        sendMessageToClient(player, message);
    }
}
######## coords.ts
import { players, planets, blackholes, stars } from "./game.js";
import { Planet } from "./planet.js";
import { Blackhole } from "./blackhole.js";
import { Star } from "./star.js";
import { Player } from "./player.js";
import { Ship } from "./ship.js";
import { GRID_HEIGHT, GRID_WIDTH, OCDEF, CoordMode } from "./settings.js";
import { sendMessageToClient } from "./communication.js";

export type Position = {
    v: number;
    h: number;
}

export function chebyshev(a: Position, b: Position): number {
    return Math.max(Math.abs(a.v - b.v), Math.abs(a.h - b.h));
}

/**
 * Finds a Planet, BlackHole, or Ship at the given (v, h) position.
 * Returns { v, h, obj } if found, otherwise null.
 */
export function findObjectAtPosition(
    v: number,
    h: number,
    ignoreBlackholes: boolean = false
): { v: number; h: number; obj: Ship | Planet | Star | Blackhole } | null {
    for (const player of players) {
        if (player.ship && player.ship.position.v === v && player.ship.position.h === h) {
            return { v, h, obj: player.ship };
        }
    }

    for (const planet of planets) {
        if (planet.position.v === v && planet.position.h === h) {
            return { v, h, obj: planet };
        }
    }

    for (const star of stars) {
        if (star.position.v === v && star.position.h === h) {
            return { v, h, obj: star };
        }
    }
    if (!ignoreBlackholes) {
        for (const bh of blackholes) {
            if (bh.position.v === v && bh.position.h === h) {
                return { v, h, obj: bh };
            }
        }
    }
    return null;
}

export function findEmptyLocation(): Position | null {
    for (let attempts = 0; attempts < 1000; attempts++) {
        const v = Math.floor(Math.random() * GRID_HEIGHT) + 1;
        const h = Math.floor(Math.random() * GRID_WIDTH) + 1;

        if (!findObjectAtPosition(v, h)) {
            return { v, h };
        }
    }
    return null; // fallback if map is saturated
}

export interface ParsedCoords {
    position: Position;
    cursor: number;
    mode: CoordMode;
    error?: string;
}

/**
 * Parses coordinates from a command's argument list.
 * - Allows optional mode prefix ("A", "R", or "C").
 * - Returns absolute coordinates with mode info.
 * - If COMPUTED is used but not allowed, returns an error.
 */
export function getCoordsFromCommandArgs(
    player: Player,
    args: string[],
    currentV: number,
    currentH: number,
    allowComputed: boolean = false
): ParsedCoords {
    let cursor = 0;
    let mode: CoordMode = "ABSOLUTE";

    const modeArg = args[0]?.toUpperCase();
    if (modeArg === "R" || modeArg === "RELATIVE") {
        mode = "RELATIVE";
        cursor++;
    } else if (modeArg === "A" || modeArg === "ABSOLUTE") {
        mode = "ABSOLUTE";
        cursor++;
    } else if (modeArg === "C" || modeArg === "COMPUTED") {
        if (!allowComputed) {
            return { position: { v: 0, h: 0 }, cursor, mode: "COMPUTED", error: "COMPUTED coordinates are not allowed for this command." };
        }
        mode = "COMPUTED";
        cursor++;
    } else {
        if (player.settings.icdef) {
            mode = player.settings.icdef;
        }
    }

    if (mode === "COMPUTED") {
        const shipArg = args[cursor];
        return getComputedCoordsFromCommandArg(player, shipArg, cursor, mode);
    }

    const v = parseInt(args[cursor++], 10);
    const h = parseInt(args[cursor++], 10);

    if (Number.isNaN(h) || Number.isNaN(v)) {
        return { position: { v: 0, h: 0 }, cursor, mode, error: "Invalid coordinates." };
    }

    const resultV = mode === "RELATIVE" ? currentV + v : v;
    const resultH = mode === "RELATIVE" ? currentH + h : h;
    return {
        position: { v: resultV, h: resultH },
        cursor,
        mode,
        error: undefined
    };
}

function getComputedCoordsFromCommandArg(player: Player, shipArg: string, cursor: number, mode: CoordMode) {
    if (!shipArg) {
        return { position: { v: 0, h: 0 }, cursor, mode, error: "Ship name required for COMPUTED coordinates." };
    }
    if (!player.ship!.isDeviceOperational("computer")) {
        sendMessageToClient(player, "COMPUTER MALFUNCTION — unable to compute target coordinates.");
        return { position: { v: 0, h: 0 }, cursor, mode, error: "COMPUTER MALFUNCTION — unable to compute target coordinates." };
    }
    cursor++;

    const ship = Ship.findShipByPartialName(shipArg);
    if (!ship) {
        const shipName = Ship.findShipByPartialName(shipArg);
        if (shipName) {
            return { position: { v: 0, h: 0 }, cursor, mode, error: `Ship ${shipName} not in game.` };
        } else {
            return { position: { v: 0, h: 0 }, cursor, mode, error: `Unknown computed target ${shipArg}.` };
        }
    }
    return { position: { v: ship.position.v, h: ship.position.h }, cursor, mode, error: undefined };
}

export function ocdefCoords(
    ocdef: OCDEF,
    source: Position,
    location: Position
): string {
    const abs = `${location.v}-${location.h}`;
    const relV = location.v - source.v;
    const relH = location.h - source.h;
    const rel = `${relV >= 0 ? "+" : ""}${relV} ${relH >= 0 ? "+" : ""}${relH}`;

    switch (ocdef) {
        case "RELATIVE":
            return rel;
        case "BOTH":
            return `${abs} (${rel})`;
        case "ABSOLUTE":
        default:
            return abs;
    }
}

// Bresenham line generator
export function* bresenhamLine(v0: number, h0: number, v1: number, h1: number) {
    const dh = Math.abs(h1 - h0),
        dv = Math.abs(v1 - v0),
        sh = h0 < h1 ? 1 : -1,
        sv = v0 < v1 ? 1 : -1;
    let err = dh - dv;

    while (true) {
        yield { h: h0, v: v0 };
        if (h0 === h1 && v0 === v1) break;
        const e2 = err * 2;
        if (e2 > -dv) { err -= dv; h0 += sh; }
        if (e2 < dh) { err += dh; v0 += sv; }
    }
}

export function isAdjacent(pos1: Position, pos2: Position): boolean {
    const dv = Math.abs(pos1.v - pos2.v);
    const dh = Math.abs(pos1.h - pos2.h);
    return (dh <= 1 && dv <= 1) && !(dh === 0 && dv === 0);
}

export function getTrailingPosition(origin: Position, destination: Position): Position | null {
    // Sort origin's adjacent positions by distance to destination
    const sortedOriginAdjacents = getAdjacentPositions(origin)
        .filter(pos => isInBounds(pos.v, pos.h) && !findObjectAtPosition(pos.v, pos.h))
        .sort((a, b) => distance(b, destination) - distance(a, destination)); // trailing = farther from destination

    if (sortedOriginAdjacents.length > 0) {
        const result = sortedOriginAdjacents[0];
        if (isInBounds(result.v, result.h)) { // Explicit check for clarity
            return result;
        }
        // If somehow not in bounds (shouldn't happen), proceed to fallback
    }

    // Fallback: try positions around the destination
    const sortedDestinationAdjacents = getAdjacentPositions(destination)
        .filter(pos => isInBounds(pos.v, pos.h) && !findObjectAtPosition(pos.v, pos.h))
        .sort((a, b) => distance(a, origin) - distance(b, origin)); // prefer closer to the line from origin to destination

    if (sortedDestinationAdjacents.length > 0) {
        const result = sortedDestinationAdjacents[0];
        if (isInBounds(result.v, result.h)) { // Explicit check for clarity
            return result;
        }
        // If somehow not in bounds (shouldn't happen), return null
    }

    // No valid trailing position found
    return null;
}

function distance(a: Position, b: Position): number {    // is thislegit? why
    return Math.hypot(a.v - b.v, a.h - b.h);
}

function getAdjacentPositions(pos: Position): Position[] {
    const deltas = [
        { v: 0, h: -1 }, // up
        { v: 0, h: 1 },  // down
        { v: -1, h: 0 }, // left
        { v: 1, h: 0 },  // right
        { v: -1, h: -1 }, // up-left
        { v: 1, h: -1 },  // up-right
        { v: -1, h: 1 },  // down-left
        { v: 1, h: 1 },   // down-right
    ];
    return deltas.map(delta => ({ v: pos.v + delta.v, h: pos.h + delta.h }));
}

export function isInBounds(v: number, h: number): boolean {
    return h >= 1 && h <= GRID_WIDTH && v >= 1 && v <= GRID_HEIGHT;
}
######## damage.ts
import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';
import { Player } from './player.js';
import { Ship } from './ship.js';


export function damagesCommand(player: Player, command: Command): void {
    if (!player.ship) return;
    const devices = player.ship.devices;
    const args = command.args.map(a => a.toUpperCase());

    // Device mappings: token to full name and device key
    const deviceMappings: { [key: string]: { name: string; key: keyof Ship['devices']; minLength: number } } = {
        'WARP': { name: 'Warp', key: 'warp', minLength: 1 },
        'IMPULSE': { name: 'Impulse', key: 'impulse', minLength: 1 },
        'TORPEDO': { name: 'Torpedo', key: 'torpedo', minLength: 2 },
        'PHASER': { name: 'Phasers', key: 'phaser', minLength: 1 },
        'SHIELD': { name: 'Shields', key: 'shield', minLength: 1 },
        'COMPUTER': { name: 'Computer', key: 'computer', minLength: 1 },
        'RADIO': { name: 'Radio', key: 'radio', minLength: 1 },
        'TRACTOR': { name: 'Tractor', key: 'tractor', minLength: 2 },
        'LIFESUPPORT': { name: 'Life Sup', key: 'lifeSupport', minLength: 1 }
    };

    // Deduplicate args array to avoid duplicate device reports
    const seenArgs = new Set<string>();
    let args2 = args.filter(arg => {
        if (seenArgs.has(arg)) return false;
        seenArgs.add(arg);
        return true;
    });
    let showAll = false;
    let hasDamage = false;

    if (args2.length == 0) {
        args2 = ["W", "I", "TO", "P", "S", "C", "R", "TR", "L"];
    } else {
        showAll = true;
    }

    const output: string[] = [];
    for (const arg of args2) {
        const matchedDevice = Object.entries(deviceMappings).find(([fullToken, { minLength }]) =>
            arg.length >= minLength && fullToken.startsWith(arg)
        );
        if (matchedDevice) {
            const { name, key } = matchedDevice[1];
            const damage = devices[key as keyof typeof devices];
            //const damage = Math.random() * 300;  test
            if ((damage <= 0 && showAll) || damage > 0)
                output.push(`${name.padEnd(11)}${damage.toFixed(1).padStart(7)}`);
            if (damage > 0) hasDamage = true;
        }
    }
    if (!hasDamage) {
        sendMessageToClient(player, 'All systems operational.\r\n');
        return;
    } else {
        // Output header and aligned lines
        output.unshift('');
        output.unshift('Device       Damage');
        output.push('');
        output.forEach(line => sendMessageToClient(player, line));
    }
    return;


    // // General damage report
    // const reportLines: string[] = [];
    // for (const { name, key } of Object.values(deviceMappings)) {
    //     const damage = devices[key as keyof typeof devices];
    //     if (damage > 0) {
    //         reportLines.push(`${name.padEnd(16)}${damage.toFixed(0).padStart(6)}`);
    //     }
    // }
    // if (reportLines.length === 0) {
    //     sendMessageToClient(player, 'All systems operational.');
    // } else {
    //     sendMessageToClient(player, 'Damage Report:');
    //     sendMessageToClient(player, 'Device           Damage');
    //     reportLines.forEach(line => sendMessageToClient(player, line));
    // }
}
######## db/user-records.ts
import { ScanSetting, PromptSetting, OCDEF, ICDEF, OutputSetting } from "../settings.js";
import flatfilePkg from 'flat-file-db';
import { Player } from "../player.js";

const flatfile = (flatfilePkg as { default?: typeof flatfilePkg }).default || flatfilePkg;
const db = flatfile('playerSettings.db');

type Settings = {
    scan: ScanSetting;
    prompt: PromptSetting;
    ocdef: OCDEF;
    icdef: ICDEF;
    output: OutputSetting;
};

let dbOpen = false;


db.on('open', () => {
    dbOpen = true;
});


export function getPlayerSettings(player: Player): Settings | null {
    if (!dbOpen || !player.auth.email) {
        return null;
    }

    const settings = player.settings;//db.get(player.auth.email);
    if (settings) {
        //player.settings = settings;
        return player.settings;
    } else {
        return null;
    }
}

export function setPlayerSettings(player: Player): void {
    if (!dbOpen || !player.auth.email) {
        return;
    }

    db.put(player.auth.email, player.settings);
}

######## dock.ts
import { Command } from "./command.js";
import { Player } from "./player.js";
import { putClientOnHold, sendMessageToClient, releaseClient } from "./communication.js";
import { planets } from "./game.js";
import { statusCommand } from "./status.js";
import { MAX_SHIP_ENERGY, MAX_SHIELD_ENERGY, MAX_TORPEDOES, DOCK_DELAY_MIN_MS, DOCK_DELAY_RANGE } from "./settings.js";
import { isAdjacent } from "./coords.js";

export function dockCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to dock.");
        done?.();
        return;
    }

    if (player.ship.docked) {
        sendMessageToClient(player, "You are already docked.");
        done?.();
        return;
    }

    // if (player.ship.shieldsUp && player.ship.shieldEnergy > 0) {
    //     sendMessageToClient(player, "Shields must be down to dock.");
    //     done?.();
    //     return;
    // }

    let isBase = false;
    let nearPlanet = false;

    const side = player.ship.side;

    for (const planet of planets) {
        if (planet.side === side && isAdjacent(player.ship.position, planet.position)) {
            nearPlanet = true;
            if (planet.isBase) {
                isBase = true;
            }
            break;
        }
    }

    if (!nearPlanet) {
        sendMessageToClient(player, "No friendly base or captured planet nearby to dock.");
        done?.();
        return;
    }

    const showStatus = command.args.length > 0 && "STATUS".startsWith(command.args[0].toUpperCase());
    if (command.args.length > 0 && !showStatus) {
        sendMessageToClient(player, "Invalid command. Use 'STATUS' to show status.");
        done?.();
        return;
    }

    const statusArgs = showStatus ? command.args.slice(1).map(a => a.toUpperCase()) : [];

    const delayMs = DOCK_DELAY_MIN_MS + Math.random() * DOCK_DELAY_RANGE;
    putClientOnHold(player, "Docking...");

    const timer = setTimeout(() => {
        releaseClient(player);

        if (!player.ship) {
            sendMessageToClient(player, "You must be in a ship to dock.");
            done?.();
            return;
        }

        const ship = player.ship;
        const wasFullyRepaired =
            ship.energy >= MAX_SHIP_ENERGY &&
            ship.shieldEnergy >= MAX_SHIELD_ENERGY &&
            ship.torpedoes >= MAX_TORPEDOES &&
            ship.damage <= 0;

        // Dock status
        // Apply refills
        const wasAlreadyDocked = ship.docked;
        ship.docked = true;
        ship.condition = "GREEN";

        // Repair / refuel rates
        const energyGain = isBase ? 1000 : 500;
        const shieldGain = isBase ? 500 : 250;
        const torpGain = isBase ? 10 : 5;
        const damageRepair = isBase ? 100 : 50;
        const dockedBonus = isBase ? 200 : 100;

        ship.energy = Math.min(MAX_SHIP_ENERGY, ship.energy + energyGain);
        ship.shieldEnergy = Math.min(MAX_SHIELD_ENERGY, ship.shieldEnergy + shieldGain);
        ship.shieldsUp = false;
        ship.torpedoes = Math.min(MAX_TORPEDOES, ship.torpedoes + torpGain);
        ship.damage = Math.max(0, ship.damage - damageRepair - (wasAlreadyDocked ? dockedBonus : 0));
        ship.devices.lifeSupport = 0;

        // Messages
        if (wasFullyRepaired) {
            sendMessageToClient(player, "Docking has no effect. Ship fully supplied.");
        } else {
            sendMessageToClient(player, "Docking complete. Supplies replenished.");
        }

        sendMessageToClient(player, "Ship condition is now GREEN.");

        if (showStatus) {
            statusCommand(player, {
                ...command,
                args: statusArgs,
            });
        }
        //TODO STATUS
        done?.();
    }, delayMs);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player); TODO: Add starbase phaser defense
}
######## energy.ts
import { sendMessageToClient, sendOutputMessage } from "./communication.js";
import { Player } from "./player.js";
import { Command } from "./command.js";
import { players } from "./game.js";
import { Ship } from "./ship.js";
import { chebyshev } from "./coords.js";
import { MAX_SHIP_ENERGY } from "./settings.js";

/**
 * ENERGY <shipName> <units>
 * Transfers energy to an adjacent allied ship, losing 10% in transit.
 */
export function energyCommand(player: Player, command: Command): void {
    const args = command.args;

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use ENERGY.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    if (args.length < 2) {
        sendMessageToClient(player, 'Usage: ENERGY <shipName> <amount>');
        return;
    }

    const targetInput = args[0].toUpperCase();
    const requested = parseInt(args[1], 10);
    if (isNaN(requested) || requested <= 0) {
        sendMessageToClient(player, 'Invalid energy amount.');
        return;
    }

    if (player.ship.energy < requested) {
        sendMessageToClient(player, 'Insufficient energy to transfer.');
        return;
    }

    // Match alive players with partial ship name match
    const name = Ship.resolveShipName(targetInput);
    if (!name) {
        sendMessageToClient(player, `No ship found matching "${targetInput}".`);
        return;
    }

    const matches = [...players].filter(p => p.ship && p.ship.name.toUpperCase() === name);

    if (matches.length === 0) {
        sendMessageToClient(player, `Ship "${targetInput}" not in service.`);
        return;
    } else if (matches.length > 1) {
        const names = matches.map(p => p.ship ? p.ship.name : "Unknown").join(', ');
        sendMessageToClient(player, `Ambiguous ship name "${targetInput}". Matches: ${names}`);
        return;
    }

    const target = matches[0];

    if (target.ship) {

        // Check adjacency
        if (chebyshev(player.ship.position, target.ship.position) > 1) {
            sendMessageToClient(player, `Target ${target.ship.name} is not adjacent.`);
            return;
        }

        // Energy transfer math
        const availableRoom = MAX_SHIP_ENERGY - target.ship.energy;
        if (availableRoom <= 0) {
            sendMessageToClient(player, `${target.ship.name} cannot accept more energy.`);
            return;
        }

        const sendAmount = Math.min(requested, availableRoom);
        player.ship.energy -= sendAmount;
        const received = Math.floor(sendAmount * 0.9);
        target.ship.energy += received;

        // Sender output
        sendOutputMessage(player, {
            SHORT: `ENERGY: ${sendAmount} → ${target.ship.name} (${received} recv)`,
            MEDIUM: `Transferred ${sendAmount} units to ${target.ship.name}; they received ${received} (10% lost).\nYour energy: ${player.ship.energy}\nTheir energy: ${target.ship.energy}`,
            LONG: `Energy transfer complete.\n${sendAmount} units sent to ${target.ship.name}.\n${target.ship.name} received ${received} units (10% lost in transmission).\nYour remaining energy: ${player.ship.energy}`
        });

        // Target output
        sendOutputMessage(target, {
            SHORT: `${received} ENERGY UNITS FROM ${player.ship.name}`,
            MEDIUM: `${received} units of energy received from ${player.ship.name}.`,
            LONG: `Incoming energy transfer from ${player.ship.name}.\nReceived ${received} units of energy.`
        });

    } {
        sendMessageToClient(player, `${name} ship not found.`);
        return;
    }
}

######## game.ts
import { Blackhole } from "./blackhole.js";
import { Planet } from "./planet.js";
import { Player } from "./player.js";
import { Star } from "./star.js";
import { setRandomSeed } from './util/random.js';
import { PointsManager } from "./points.js";
import { settings, INACTIVITY_TIMEOUT } from "./settings.js";
import { updateRomulan, maybeSpawnRomulan } from "./romulan.js";
import { sendAllPendingMessages, sendMessageToClient } from "./communication.js";
import net from "net";
import { chebyshev } from "./coords.js";
import { pointsCommand } from "./points.js";
import { basphaFireOnce } from "./starbase_phasers.js";
import { planetPhaserDefense } from "./phaser.js";
import { baseEnergyRegeneration } from "./planet.js";
export const SHIP_FATAL_DAMAGE = 25000;  // adjusted for fortran derived code
import { romulanApproachTick } from "./romulan.js";

// bot imports
import { updateBots, botChatterTick } from "./bots/bot.js";
import { spawnAndRegisterBot } from "./bots/register.js";




export const players: Player[] = [];
export const limbo: Player[] = [];
export let planets: Planet[] = [];
export const bases = {
    federation: [] as Planet[],
    empire: [] as Planet[],
};
export const stars: Star[] = [];
export const blackholes: Blackhole[] = [];
export const stardate: number = 0;
export const pointsManager: PointsManager = new PointsManager();

export const PLANET_PHASER_RANGE = 2; // Fortran pdist <= 2


// mark existing player objects as bots
// spawnAndRegisterBot("aggressor", "FEDERATION", "BOT-KIRK");
// spawnAndRegisterBot("defender", "EMPIRE", "BOT-KOL");





export function generateGalaxy(seed?: string): void {
    if (!seed) {
        seed = settings.tournamentSeed;
    }
    setRandomSeed(seed);

    //     nstar = int(51 * ran(0)) * 5 + 100
    //     nhole = int(41.0 * ran(0) + 10)
    //    c-- nplnet = int(20.0 + ran(0) * 61.0)
    //     nplnet = 60 ! ALWAYS insert max. # of planets

    const nstar = Math.floor(51 * Math.random()) * 5 + 100;
    const nhole = Math.floor(41 * Math.random() + 10);
    const nplnet = 60;

    planets = Planet.generate(nplnet);
    Planet.generateBases();  // 10 each
    Star.generate(nstar);
    if (settings.blackholes) {
        Blackhole.generate(nhole);
    }
    console.log(nstar, nhole, nplnet);
    settings.generated = true;


    // bot testing, TODO remove later

    //  if (process.env.SPAWN_BOTS === "1") {
    // spawnAndRegisterBot("aggressor", "FEDERATION", "BOT-KIRK");
    // spawnAndRegisterBot("defender", "EMPIRE", "BOT-KOL");
    //  }
}

// export function processTimeConsumingMove(player: Player) {
//     if (!player.ship) return;
//     if (player.ship.side == "FEDERATION") {
//         settings.teamTurns.federation += 1;
//     } else if (player.ship.side == "EMPIRE") {
//         settings.teamTurns.empire += 1;
//     } else if (player.ship.side == "ROMULAN") {
//         settings.teamTurns.romulan += 1;
//     }

//     player.stardate += 1;
//     settings.dotime += 1;
//     const numply = players.length;

//     // Perform periodic actions if dotime >= numply (mirrors if (dotime .lt. numply) goto 3501)
//     if (settings.dotime >= numply) {
//         settings.dotime = 0; // Reset dotime (mirrors dotime = 0)

//         // Periodic actions (mirrors basbld, baspha, plnatk, romdrv)
//         baseEnergyRegeneration(player); // Mirrors BASBLD
//         performPlanetOrBaseAttacks(true); // Mirrors BASPHA (enemy bases)
//         performPlanetOrBaseAttacks(false); // Mirrors PLNATK (neutral/enemy planets)
//         updateRomulan(); // Mirrors romdrv (partially)
//         if (settings.romulans) {
//             maybeSpawnRomulan(); // Mirrors romdrv (Romulan spawning)
//         }
//     }

//     for (const player of players) {
//         player.updateLifeSupport();
//     }
// }
export function processTimeConsumingMove(player: Player) {
    if (!player.ship) return;

    // Team turn bookkeeping
    if (player.ship.side === "FEDERATION") {
        settings.teamTurns.federation += 1;
    } else if (player.ship.side === "EMPIRE") {
        settings.teamTurns.empire += 1;
    } else if (player.ship.side === "ROMULAN") {
        settings.teamTurns.romulan += 1;
    }

    player.stardate += 1;
    settings.dotime += 1;

    // ACTIVE human players only (exclude Romulan), never 0; fatal threshold
    const numply = Math.max(
        1,
        players.filter(p =>
            p?.ship &&
            p.ship.side !== "ROMULAN" &&
            p.ship.energy > 0 &&
            p.ship.damage < SHIP_FATAL_DAMAGE
        ).length
    );

    // Once per full sweep of players
    if (settings.dotime >= numply) {
        settings.dotime = 0; // reset sweep

        // === Defense & regen in DECWAR order ===
        basphaFireOnce(player, numply);     // BASPHA (enemy bases fire once)
        planetPhaserDefense(player);        // PLNATK (planet auto-phasers)
        baseEnergyRegeneration(player);     // BASBLD (after defenses)
        // ======================================

        // Romulan driver (spawn + behavior), gated at sweep boundary
        if (settings.romulans) {
            updateRomulan();         // ROMDRV weapon logic (fires if cooldowns ready)
            romulanApproachTick();   // approach/steering
            maybeSpawnRomulan();     // ROMDRV spawn cadence
        }

        // If bots should act once per sweep, keep these here:
        updateBots();
        botChatterTick();
    } else {
        // If bots should act every time-consuming move instead, keep them here:
        // updateBots();
        // botChatterTick();
    }

    // Life support upkeep for everyone
    for (const p of players) p.updateLifeSupport();
}



function updateGame(): void {
    checkForDisconnectedPlayers();
    checkForInactivity();
    releaseStalePlanetCaptureLocks()
    if (settings.blackholes) {
        checkForBlackholes();
    }


    //testing remove todo
    updateBots();
    botChatterTick(); // optional flavor

    setTimeout(updateGame, 1000);
}
updateGame();

function releaseStalePlanetCaptureLocks() {
    const now = Date.now();
    for (const planet of planets) {
        if (planet.captureLock.status === true &&
            (now - planet.captureLock.time > 10000)
        ) {
            planet.captureLock.status = false;
        }
    }
}



function checkForPendingMessages(): void {
    sendAllPendingMessages();
    setTimeout(checkForPendingMessages, 30);
}
setTimeout(checkForPendingMessages, 1000);


function checkForInactivity() {
    for (const player of players) {
        if (!player.ship) continue;

        const inactiveTime = Date.now() - player.lastActivity;

        if (inactiveTime >= INACTIVITY_TIMEOUT) {
            sendMessageToClient(player, "Captain, you have been inactive for too long. You have been removed from the game.");
            removePlayerFromGame(player);

        }
    }
}


// function planetOrBasePhaserDamage(distance: number, target: Player): number {
//     let baseHit = Math.pow(0.9 + 0.02 * Math.random(), distance); // Fortran: pwr(0.9–0.92, id)
//     if (target.ship && (target.ship.devices.phaser > 0 || target.ship.devices.computer > 0)) {
//         baseHit *= 0.8; // Fortran: hit *= 0.8 if damaged
//     }
//     return baseHit;
// }

export function performPlanetOrBaseAttacks(base: boolean = false): void {
    for (const planet of planets) {
        if (planet.isBase !== base) continue; // Bases if base=true, planets if base=false
        if (planet.side === "NEUTRAL") {
            if (!base && Math.random() < 0.5) continue;
        }

        for (const player of players) {
            if (!player.ship) continue;
            if (player.ship.side === planet.side) continue;
            if (player.ship.romulanStatus.cloaked) continue;

            const range = chebyshev(planet.position, player.ship.position);
            const maxRange = base ? 4 : 2; // 4 sectors for bases, 2 for planets
            if (range > maxRange) continue;
            //const phit = base ? 200 : 100; // 200 energy for bases, 100 for planets


            // DO_DAMANGE
            // calcShipFromPlanetPhaserDamage(phit, planet, player);
        }
    }
}

function checkForDisconnectedPlayers() {
    for (const player of players) {
        if (!isSocketLive(player.socket)) {
            removePlayerFromGame(player);
        }
    }
}

export function isSocketLive(socket: net.Socket): boolean {
    return (!socket.destroyed && socket.writable && socket.readable);
}

export function checkEndGame(): void {
    // From 1978 docs:
    // This routine is called whenever a base or planet is destroyed
    // to see if the game is over. (all the planets gone, and one
    // side's bases).  If so, the appropriate message is printed out
    // and the job is returned to monitor level.

    if (settings.winner != null || !settings.generated) return;

    const fedPlanetsExist = planets.some(p => p.side === "FEDERATION" && !p.isBase);
    const empPlanetsExist = planets.some(p => p.side === "EMPIRE" && !p.isBase);

    if (fedPlanetsExist || empPlanetsExist) {
        return;
    }

    const fedBasesExist = bases.federation.length > 0;
    const empBasesExist = bases.empire.length > 0;

    if (!empBasesExist && fedBasesExist) {
        settings.winner = "FEDERATION";
    } else if (!fedBasesExist && empBasesExist) {
        settings.winner = "EMPIRE";
    } else if (!empBasesExist && !fedBasesExist) {
        settings.winner = "NEUTRAL";
    } else {
        return;
    }
    console.log(settings.winner);

    let message = ``;
    if (settings.winner) {
        message += `\r\nTHE WAR IS OVER!!!\r\n`;
        if (settings.winner === "NEUTRAL") {
            message += `The entire known galaxy has been depopulated.\r\n`;
        } else {
            if (settings.winner === "FEDERATION") {
                message += `The Federation has successfully repelled the Klingon hordes!!\r\n`;
            } else {
                message += `The Klingon Empire is VICTORIOUS!!!\r\n`;
            }
        }

        for (let i = players.length - 1; i >= 0; i--) {
            const player = players[i];
            removePlayerFromGame(player);
            if (!player.ship) continue;

            if (settings.winner === "FEDERATION" && player.ship.side === "FEDERATION") {
                message += `Congratulations. Freedom again reigns the galaxy.\r\n`;
            } else if (settings.winner === "EMPIRE" && player.ship.side === "EMPIRE") {
                message += `The Empire salutes you. Begin slave operations immediately.\r\n`;
            } else if (settings.winner === "FEDERATION" && player.ship.side === "EMPIRE") {
                message += `The Empire has fallen. Initiate self-destruction procedure.\r\n`;
            } else if (settings.winner === "EMPIRE" && player.ship.side === "FEDERATION") {
                message += `Please proceed to the nearest Klingon slave planet."\r\n`;
            }

            sendMessageToClient(player, message);
            pointsCommand(player, { key: 'POINTS', args: ['all'], raw: 'points all' });
            sendMessageToClient(player, "", true, true);

        }
        settings.generated = false;
        settings.winner = null;
        settings.gameNumber += 1;
    }
}


export function checkForBlackholes(): void {
    for (const player of players) {
        const ship = player.ship;
        if (!ship) continue;
        const { v, h } = ship.position;

        // if that ship happens to be on a black‑hole sector…
        if (blackholes.some(bh => bh.position.v === v && bh.position.h === h)) {
            sendMessageToClient(player,
                "\r\nYou have fallen into a black hole. Your ship is crushed and annihilated.");
            removePlayerFromGame(player);
            sendMessageToClient(player, "", true, true);
        }
    }
}

export function removePlayerFromGame(player: Player): void {
    // Remove from global players list
    const idx = players.findIndex(p => p === player);
    if (idx !== -1) players.splice(idx, 1);
    // Remove ship from destroyedShips list if present
    // const shipIdx = destroyedShips.indexOf(player.ship.name ?? "");
    // if (shipIdx !== -1) destroyedShips.splice(shipIdx, 1);
    // Close their socket
    // playerCache.push(player);
    // player.socket?.end();
    // player.socket?.destroy();
}

// function getHitProbability(distance: number): number {
//     const maxProb = 0.65; // 65% at 0 sectors
//     const minProb = 0.05; // 5% at max range (4 for bases, 2 for planets)
//     const maxRange = 4; // or 2 for planets
//     return minProb + (maxProb - minProb) * (1 - distance / maxRange);
// }


######## gripe.ts
import { sendMessageToClient } from './communication.js';
import { Player } from './player.js';
import { players, limbo, stardate, blackholes } from './game.js';
import { Blackhole } from './blackhole.js';
import * as fs from 'fs';


//export function gripeCommand(player: Player, command: Command, done?: () => void): void {
export function gripeCommand(player: Player): void {
    if (player.ship && player.ship.condition == "RED") {
        sendMessageToClient(player, 'You are not permitted to GRIPE\nwhile under RED alert!');
        return;
    }
    player.currentPrompt = "Enter gripe, end with ^Z\r\n";
    //sendMessageToClient(player, player.currentPrompt, true, false);
    if (player.ship) {
        swapBackholeForPlayer(player);
    }
    player.multiLine = true;
    player.callBack = (pl, resp) => {
        pl.multiLine = false;
        const nowMs = Date.now();
        const currentDateTime = new Date(nowMs).toLocaleString('en-US', {
            hour12: false
        });
        fs.appendFileSync('DECWAR.GRP', `${currentDateTime} ${stardate} ${pl.ship?.name || 'Unknown'}: ${resp}\r\n`);
        if (limbo.includes(player) && player.ship) {
            swapPlayerForBackhole(player);
        }
        sendMessageToClient(player, 'Your gripe has been noted.', true, true);
    }
}

export function swapBackholeForPlayer(player: Player): void {
    if (!player.ship) {
        return;
    }
    const { v, h } = player.ship.position;

    // 1. Create and store the new black hole
    const bh = new Blackhole(v, h);
    blackholes.push(bh);
    limbo.push(player);

    // 2. Remove player from global players list
    const index = players.indexOf(player);
    if (index !== -1) {
        players.splice(index, 1);
    }
}

export function swapPlayerForBackhole(player: Player): void {
    if (!player.ship) {
        return;
    }
    const { v, h } = player.ship.position;

    // Find the black hole at the player's location
    const blackHoleIndex = blackholes.findIndex(bh => bh.position.v === v && bh.position.h === h);

    // If a black hole is found, remove it
    if (blackHoleIndex !== -1) {
        blackholes.splice(blackHoleIndex, 1);
    }
    const index = limbo.indexOf(player);
    if (index !== -1) {
        limbo.splice(index, 1);
    }
    players.push(player);
}

######## help.ts
import { sendMessageToClient } from "./communication.js";
import { Command } from "./command.js";
import { Player } from "./player.js";
import fs from 'fs';
import path from 'path';

const helpData = loadHelpData();
const helpCommands = getHelpCommands();
const pgCommands = ['CTl-c', 'INTRO', 'HInts', 'INput', 'Output', 'PAuses', 'PRegame'];

export function helpCommand(player: Player, command: Command): void {

    const arg = command.args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use HELP.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;


    const condition = player.ship.computeCondition();
    if (condition === 'RED') {
        sendMessageToClient(player, 'You cannot get HELP while under RED alert!');
        return;
    }

    if (!arg) {
        sendMessageToClient(player, `For a list of commands type HELP *`);
        sendMessageToClient(player, `For help on a particular command type HELP command\r\n`);
        sendMessageToClient(player, `Besides commands, help is also available for:\r\n`);
        sendMessageToClient(player, `CTL-C     INTRO     HInts     INput     Output    PAuses`);
        sendMessageToClient(player, `PRegame\r\n`);
        sendMessageToClient(player, `Upper case letters mark the shortest acceptable abbreviation.\r\n`);
    } else if (arg === '*') {
        const cmds = helpCommands;
        const lines: string[] = [];
        for (let i = 0; i < cmds.length; i += 7) {
            const row = cmds.slice(i, i + 7)
                .map(cmd => cmd.padEnd(10, ' '))
                .join('');
            lines.push(row.trimEnd());
        }

        sendMessageToClient(player, `Commands are:\r\n`);
        for (const line of lines) {
            sendMessageToClient(player, line);
        }
    } else {
        const cmd = findCommandForArg(arg, helpCommands);
        if (helpData[cmd]) {
            sendMessageToClient(player, helpData[cmd]);
        } else {
            const pgcmd = findCommandForArg(arg, pgCommands);
            console.log(">>" + pgcmd);
            if (helpData[pgcmd]) {
                sendMessageToClient(player, helpData[pgcmd]);
            } else {
                sendMessageToClient(player, `No help available for "${arg}".`);
            }
        }
    }
}

/**
 * Reads the DECWAR help file and splits it into a map from
 * COMMAND → its full help text.
 *
 * Commands are recognized by lines starting with ".COMMAND".
 */
export function loadHelpData(): Record<string, string> {
    const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/DECWAR.HLP');
    const raw = fs.readFileSync(filePath, 'utf8');
    const lines = raw.split(/\r?\n/);

    const helpData: Record<string, string> = {};
    let currentCmd: string | null = null;
    let buffer: string[] = [];

    for (const line of lines) {
        const match = line.match(/^\.(\S+)\s*$/);
        if (match) {
            if (currentCmd) {
                helpData[currentCmd] = buffer.join('\n').trim();
            }
            currentCmd = match[1].toUpperCase();
            buffer = [];
        } else if (currentCmd) {
            buffer.push(line + '\r'); // Add CR for Telnet formatting
        }
    }

    if (currentCmd) {
        helpData[currentCmd] = buffer.join('\n').trim();
    }
    return helpData;
}
export function getHelpCommands(): string[] {
    const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/DECWAR.HLP');
    const raw = fs.readFileSync(filePath, 'utf8');
    const lines = raw.split(/\r?\n/);

    const commands: string[] = [];
    const syntaxRegex = /^Syntax:\s+([A-Za-z]+)(?:\s|$)/;

    for (const line of lines) {
        const match = line.match(syntaxRegex);
        if (match) {
            const cmd = match[1];
            if (!commands.includes(cmd)) {
                commands.push(cmd);
            }
        }
    }
    return commands;
}

function findCommandForArg(arg: string, commands: string[]): string {
    // Normalize the argument for matching
    const argUpper = arg.toUpperCase();

    for (const helpCommand of commands) {
        // The canonical command, e.g., "TRACTOR"
        const cmdUpper = helpCommand.toUpperCase();

        // Find the uppercase prefix (e.g., "TR" in "TRactor")
        const match = helpCommand.match(/^([A-Z]+)/);
        if (!match) continue;
        const prefix = match[1];
        const rest = helpCommand.slice(prefix.length);

        // The arg must start with the prefix
        if (!argUpper.startsWith(prefix)) continue;

        // Now, argUpper after the prefix must be a subset (in order) of the rest (case-insensitive)
        const argRest = argUpper.slice(prefix.length);
        let restIdx = 0;
        let matched = true;
        for (let i = 0; i < argRest.length; ++i) {
            const ch = argRest[i];
            // Find ch in rest, in order
            restIdx = rest.toUpperCase().indexOf(ch, restIdx);
            if (restIdx === -1) {
                matched = false;
                break;
            }
            restIdx += 1;
        }
        if (matched) {
            return cmdUpper;
        }
    }
    return "";
}
######## list.ts
// Fully FORTRAN-faithful LIST command for DECWAR
import { Player } from './player.js';
import { Command } from './command.js';
import {
    players,
    planets,
    bases,
} from './game.js';
import { sendMessageToClient } from './communication.js';
import { Planet } from './planet.js';
import { Ship } from './ship.js';
import { chebyshev } from './coords.js';
import { DEFAULT_SCAN_RANGE, MAX_SHIELD_ENERGY, OutputSetting, SYMBOL_BASE_FED, SYMBOL_BASE_EMP, INITIAL_BASE_STRENGTH, Side } from './settings.js';
import { teamMemory } from './memory.js';

type ListClause = {
    objectFilters: string[];
    sideFilters: string[];
    rangeFilters: (string | number)[];
    locationFilters: { vpos: number; hpos: number }[];
    modes: string[];
    controlKeywords: string[];
    shipNames: string[];
};

type ParseSuccess = {
    ok: true;
    clauses: ListClause[];
};

type ParseError = {
    ok: false;
    error: string;
};

type ParseResult = ParseSuccess | ParseError;

const OBJECT_FILTERS = ["SHIPS", "BASES", "PLANETS", "PORTS"];
const SIDE_FILTERS = ["FEDERATION", "HUMAN", "EMPIRE", "KLINGON", "FRIENDLY", "ENEMY", "TARGETS", "NEUTRAL", "CAPTURED"];
const MODES = ["LIST", "SUMMARY"];
const CONTROL_KEYWORDS = ["AND", "&"];
const RANGE_KEYWORDS = ["CLOSEST", "ALL"];

export function listCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, false);
}

export function listCommandHelper(player: Player, command: Command, onlySummarize: boolean = false): void {
    const result: ParseResult = parseListCommand(command.raw);
    let ship: Ship;
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use LIST.");
        return;
    } else {
        ship = player.ship;
    }

    if (!result.ok) {
        sendMessageToClient(player, result.error);
        return;
    }

    const outputMode: OutputSetting = player.settings.output ?? "LONG";

    for (const clause of result.clauses) {
        if (clause.objectFilters.length == 0) {
            clause.objectFilters = ["SHIPS", "BASES", "PLANETS"];
        }

        let range = DEFAULT_SCAN_RANGE;
        let explicitRange = false;
        let allShips: Ship[] = [];
        let allBases: Planet[] = [];
        let allPlanets: Planet[] = [];
        const outputLines: string[] = [];

        if (clause.rangeFilters.length > 0) {
            const numericRanges = clause.rangeFilters.filter(r => typeof r === "number") as number[];
            if (numericRanges.length > 0) {
                range = Math.max(...numericRanges);
                explicitRange = true;
            }
            if (clause.rangeFilters.includes("ALL")) { //needed?
                range = Infinity;
            }
        }

        if (!explicitRange) {
            clause.rangeFilters.push("ALL");
            range = Infinity;
        }

        // filter by objects first

        if (clause.objectFilters.includes("SHIPS")) {
            allShips = players.map(p => p.ship).filter((ship): ship is Ship => ship !== null);
        }
        if (
            clause.objectFilters.includes("BASES") ||
            clause.objectFilters.includes("PORTS")) {
            allBases = [...bases.federation, ...bases.empire];
        }
        if (clause.objectFilters.includes("PLANETS") ||
            clause.objectFilters.includes("PORTS")) {
            allPlanets = [...planets];
        }

        allPlanets = dedup(allPlanets, [...bases.federation, ...bases.empire]);

        // filters by side
        if (allShips.length > 0) {
            const filter = new Set(clause.sideFilters);
            allShips = allShips.filter(ship => isSideMatch(player, filter, ship));
        }

        if (allBases.length > 0) {
            const filter = new Set(clause.sideFilters);
            allBases = allBases.filter(base => isSideMatch(player, filter, base));
        }

        if (allPlanets.length > 0) {
            const filter = new Set(clause.sideFilters);
            allPlanets = allPlanets.filter(planet => isSideMatch(player, filter, planet));
        }

        // filters by range
        if (clause.rangeFilters.length > 0) {
            if (clause.rangeFilters.includes("CLOSEST")) {
                if (allShips.length > 0) {
                    const closestShip = allShips.reduce((a, b) =>
                    // Find the closest ship to player.ship, but skip player.ship itself
                    (a === player.ship ? b : b === player.ship ? a :
                        (chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b))
                    );
                    allShips = [closestShip];
                }
                if (allBases.length > 0) {
                    const closestBase = allBases.reduce((a, b) =>
                        chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b
                    );
                    allBases = [closestBase];
                }
                if (allPlanets.length > 0) {
                    const closestPlanet = allPlanets.reduce((a, b) =>
                        chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b
                    );
                    allPlanets = [closestPlanet];
                }
            }
        }

        // filter by range
        if (range !== Infinity) {
            allShips = allShips.filter(ship => chebyshev(ship.position, ship.position) <= range);
            allBases = allBases.filter(base => chebyshev(ship.position, base.position) <= range);
            allPlanets = allPlanets.filter(planet => chebyshev(ship.position, planet.position) <= range);
        }

        // filter by location

        // If there are any location filters, filter objects to those locations
        if (clause.locationFilters.length > 0) {
            // For ships, match if their position matches any location filter
            allShips = allShips.filter(ship =>
                clause.locationFilters.some(loc =>
                    ship.position.h === loc.hpos && ship.position.v === loc.vpos
                )
            );
            // For bases, match if their x/y matches any location filter
            allBases = allBases.filter(base =>
                clause.locationFilters.some(loc =>
                    base.position.h === loc.hpos && base.position.v === loc.vpos
                )
            );
            // For planets, match if their position matches any location filter
            allPlanets = allPlanets.filter(planet =>
                clause.locationFilters.some(loc =>
                    planet.position.h === loc.hpos && planet.position.v === loc.vpos
                )
            );
        }

        const summarize = clause.modes.includes("SUMMARY");

        // Show full object listings (as in 2.2 LIST default)
        const finalShips = [];
        const finalBases = [];
        const finalPlanets = [];
        let needReturn = false;

        const qualifier = explicitRange ? "in specified range" : "in game";

        for (const ship of allShips) {
            const line = formatShipLine(ship, outputMode, player);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalShips.push(ship);
            }
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const shipSummary: ListSummary = summarizeShips(finalShips);
            printSummary(shipSummary, "ships", qualifier, outputLines);
            if (finalShips.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        for (const base of allBases) {
            const line = formatBaseLine(base, outputMode, player);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalBases.push(base);
            }
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const baseSummary: ListSummary = summarizeBases(finalBases);
            printSummary(baseSummary, "bases", qualifier, outputLines);
            if (finalBases.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        for (const planet of allPlanets) {
            const line = formatPlanetLine(planet, outputMode, player);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalPlanets.push(planet);
            }
        }


        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const planetSummary: ListSummary = summarizePlanets(finalPlanets);
            printSummary(planetSummary, "planets", qualifier, outputLines);
            if (finalPlanets.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (outputLines.length === 0) {
            sendMessageToClient(player, "Nothing matches your LIST criteria.");
        } else {
            for (const line of outputLines) {
                sendMessageToClient(player, line);
            }
        }

    }

}

function formatShipLine(ship: Ship, mode: OutputSetting, viewer: Player): string | null {
    if (ship.romulanStatus.isRomulan && ship.romulanStatus.cloaked) {
        return null;
    }
    if (!viewer.ship) {
        return null;
    }

    let isOutOfRange = false;
    const distance = chebyshev(ship.position, viewer.ship.position);

    if (distance > DEFAULT_SCAN_RANGE && ship.side !== viewer.ship.side) isOutOfRange = true;
    //const { v, h } = ship.position;
    const flag = (ship.side !== viewer.ship.side) ? "*" : " ";

    let coord = 'out of range';
    const name = ship.name ?? '??';
    let fullName = (name[0].toUpperCase() + name.slice(1).toLowerCase()).padEnd(12);
    let percent = "%";
    const shieldPct = (ship.shieldEnergy / MAX_SHIELD_ENERGY) * 100;
    let shieldDisplay = `+${shieldPct.toFixed(0)}${percent}`.padStart(7);


    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = name[0].toUpperCase().padEnd(3);
        percent = " ";
    }

    if (!isOutOfRange) {
        coord = `${formatCoordsForPlayer2(ship.position.v, ship.position.h, viewer)}`;
        if (mode === "SHORT" || mode === "MEDIUM") {
            shieldDisplay = `+${shieldPct.toFixed(1)}${percent}`.padStart(9);
        } else {
            coord = `@${coord}`;
        }
    } else {
        shieldDisplay = '';
    }

    if (mode === "SHORT" || mode === "MEDIUM") {
        return `${flag}${fullName}${coord} ${shieldDisplay}`;
    } else {
        return `${flag}${fullName}${coord}${shieldDisplay}`;
    }
}

function formatBaseLine(base: Planet, mode: OutputSetting, viewer: Player): string | null {
    if (!viewer.ship) {
        return null;
    }
    const distance = chebyshev(viewer.ship.position, viewer.ship.position);
    if (distance > DEFAULT_SCAN_RANGE && base.side !== viewer.ship.side) {
        const memory = viewer.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
        if (!memory.has(`${base.position.v},${base.position.h}`)) {
            return null;
        }
    }

    const name = base.side.slice(0, 3).charAt(0).toUpperCase() + base.side.slice(1, 3).toLowerCase();
    const isEnemy = base.side !== viewer.ship.side;
    const flag = isEnemy ? "*" : " ";
    let fullName;
    let percent;

    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = (base.side === "FEDERATION" ? SYMBOL_BASE_FED : base.side === "EMPIRE" ? SYMBOL_BASE_EMP : base.side.slice(0, 3)).padEnd(3);
        percent = " ";
    } else {
        fullName = ((name[0].toUpperCase() + name.slice(1).toLowerCase()) + " Base").padEnd(12);
        percent = "%";
    }

    const coord = `${formatCoordsForPlayer2(base.position.v, base.position.h, viewer)}`;
    //const delta = `${dx >= 0 ? "+" : ""}${dx},${dy >= 0 ? "+" : ""}${dy}`.padStart(9);
    const shieldPct = (base.energy / INITIAL_BASE_STRENGTH) * 100;
    let shieldDisplay = `+${shieldPct.toFixed(1)}${percent}`.padStart(9);
    if (mode === "SHORT" || mode === "MEDIUM") {
        shieldDisplay = `${shieldPct.toFixed(0)}${percent}`.padStart(8);
        return `${flag}${fullName}${coord}${shieldDisplay}`;
    } else {
        return `${flag}${fullName}@${coord}${shieldDisplay}`;
    }
}

function formatPlanetLine(planet: Planet, mode: OutputSetting, viewer: Player): string | null {
    if (!viewer.ship) {
        return null;
    }
    const distance = chebyshev(planet.position, viewer.ship.position);
    if (distance > DEFAULT_SCAN_RANGE) {
        const memory = viewer.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
        if (!memory.has(`${planet.position.v},${planet.position.h}`)) {
            return null;
        }
    }

    const name = planet.side.slice(0, 3).charAt(0).toUpperCase() + planet.side.slice(1, 3).toLowerCase() + " planet";
    const isEnemy = planet.side !== viewer.ship.side && planet.side !== "NEUTRAL";
    let flag;
    if (isEnemy) {
        flag = "*";
    } else if (planet.side === "NEUTRAL") {
        flag = " ";
    } else {
        flag = "-";
    }

    let fullName, builds;
    let coord = `${formatCoordsForPlayer2(planet.position.v, planet.position.h, viewer)}`
    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = "@";
        builds = (planet.builds + "").padStart(6);
        if (planet.builds == 0) builds = "";
        return ` ${flag}${fullName} ${coord}${builds}`;
    } else {
        builds = planet.builds + " builds".padStart(5);
        fullName = name.padEnd(12);
        const pad = (viewer.settings.ocdef !== "BOTH") ? 10 : 18;
        coord = coord.padEnd(pad);
        if (planet.builds == 0) builds = "";
        const sep = (viewer.settings.ocdef === "RELATIVE") ? "" : "@";
        return `${flag}${fullName}${sep}${coord}${builds}`;
    }
}

export function parseListCommand(input: string): ParseResult {
    try {
        const tokens = tokenize(input.toUpperCase());
        const clauses: ListClause[] = [];
        let current: ListClause = emptyClause();

        while (tokens.length > 0) {
            const token = tokens[0];

            if (matchesKeyword(token, CONTROL_KEYWORDS)) {
                tokens.shift();
                clauses.push(current);
                current = emptyClause();
            } else if (matchesKeyword(token, OBJECT_FILTERS)) {
                current.objectFilters.push(matchAndShift(tokens, OBJECT_FILTERS)!);
            } else if (matchesKeyword(token, SIDE_FILTERS)) {
                current.sideFilters.push(matchAndShift(tokens, SIDE_FILTERS)!);
            } else if (matchesKeyword(token, MODES)) {
                current.modes.push(matchAndShift(tokens, MODES)!);
            } else if (matchesKeyword(token, RANGE_KEYWORDS)) {
                current.rangeFilters.push(matchAndShift(tokens, RANGE_KEYWORDS)!);
            } else if (!isNaN(Number(token))) {
                const vpos = Number(tokens.shift());
                if (tokens.length > 0 && /^[0-9]+$/.test(tokens[0])) {
                    const hpos = Number(tokens.shift());
                    current.locationFilters.push({ vpos, hpos });
                } else {
                    current.rangeFilters.push(vpos);
                }
            } else if (/^[A-Z]+$/.test(token)) {
                current.shipNames.push(tokens.shift()!);
            } else {
                return { ok: false, error: "Unknown token: " + token };
            }
        }

        clauses.push(current);
        return { ok: true, clauses };
    } catch (e: unknown) {
        return { ok: false, error: e instanceof Error ? e.message : "Unexpected parsing error" };
    }
}

function emptyClause(): ListClause {
    return {
        objectFilters: [],
        sideFilters: [],
        rangeFilters: [],
        locationFilters: [],
        modes: [],
        controlKeywords: [],
        shipNames: [],
    };
}

function tokenize(input: string): string[] {
    return input.trim().split(/\s+/);
}

function matchesKeyword(token: string, options: string[]): boolean {
    return options.some(opt => opt.startsWith(token));
}

function matchAndShift(tokens: string[], options: string[]): string | null {
    const token = tokens[0];
    const match = options.find(opt => opt.startsWith(token));
    if (match) {
        tokens.shift();
        return match;
    }
    return null;
}

//isSideMatch(player, ship.side, filter, ship));

function isSideMatch(player: Player, filter: Set<string>, target: Ship | Planet): boolean {
    if (!player.ship) {
        return false;
    }
    const playerSide = player.ship.side;
    const targetSide = target.side;

    if (filter.size === 0) return true;

    if (filter.has("CAPTURED")) {
        if (target instanceof Planet) {
            if (target.side === "NEUTRAL") return false;
        } else {
            return false;
        }
    }
    if (filter.has("HUMAN") || filter.has("FEDERATION")) {
        if (targetSide === "EMPIRE" || targetSide === "ROMULAN" || targetSide === "NEUTRAL") return false;
    }
    if (filter.has("KLINGON") || filter.has("EMPIRE")) {
        if (targetSide === "FEDERATION" || targetSide === "ROMULAN" || targetSide === "NEUTRAL") return false;
    }
    if (filter.has("FRIENDLY") && (playerSide !== targetSide || targetSide === "NEUTRAL")) return false;

    if (filter.has("ENEMY") || filter.has("TARGETS")) {
        if ((playerSide === targetSide) || targetSide === "NEUTRAL" as Side) return false;
    }
    if (filter.has("NEUTRAL") && (targetSide as Side) !== "NEUTRAL") return false;

    return true;
}

export function formatCoordsForPlayer2(
    targetV: number,
    targetH: number,
    player: Player
): string {
    if (!player.ship) {
        return "";
    }
    const abs = `${targetV.toString().padStart(2, ' ')}-${targetH.toString().padStart(2, ' ')}`;
    const relV = targetV - player.ship.position.v;
    const relH = targetH - player.ship.position.h;

    // Format with sign only for non-zero
    const formatRel = (num: number) => {
        if (num === 0) return "0";
        return (num > 0 ? "+" : "") + num;
    };

    const rel = `${formatRel(relV)},${formatRel(relH).padStart(3)}`.padStart(7);


    //@48-70 -10, +5
    switch (player.settings.ocdef) {
        case "RELATIVE":
            return rel;
        case "BOTH":
            return `${abs} ${rel}`;
        case "ABSOLUTE":
        default:
            return abs;
    }
}

function dedup(planets: Planet[], bases: Planet[]): Planet[] {
    // Create a Set of base coordinates as "y-x" strings for fast lookup
    const baseCoords = new Set(bases.map(b => `${b.position.v}-${b.position.h}`));
    // Filter out any planet whose coords match a base
    return planets.filter(p => !baseCoords.has(`${p.position.v}-${p.position.h}`));
}

function printSummary(summary: ListSummary, label: string, qualifier: string, outputLines: string[]): void {
    if (summary.FEDERATION > 0) outputLines.push(summary.FEDERATION + ` Federation ${label} ${qualifier}`);
    if (summary.EMPIRE > 0) outputLines.push(summary.EMPIRE + ` Empire ${label} ${qualifier}`);
    if (summary.ROMULAN > 0) outputLines.push(summary.ROMULAN + ` Romulan ${label} ${qualifier}`);
    if (summary.NEUTRAL > 0) outputLines.push(summary.NEUTRAL + ` Neutral ${label} ${qualifier}`);
}


export function summaryCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, true);
}

export interface ListSummary {
    FEDERATION: number;
    EMPIRE: number;
    ROMULAN: number;
    NEUTRAL: number;
}

/**
 * Counts ships by side (FEDERATION, EMPIRE, ROMULAN) from the provided array.
 * Assumes all ships in the array are vetted and valid.
 * @param ships - Array of Player objects representing ships to count.
 * @returns A ShipSummary object containing counts of ships by side.
 */
export function summarizeShips(ships: Ship[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const ship of ships) {
        if (ship.romulanStatus?.isRomulan) {
            summary.ROMULAN += 1;
        } else if (ship.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (ship.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        }
    }

    return summary;
}


/**
 * Counts bases by side (FEDERATION, EMPIRE) from the provided array.
 * Assumes all bases in the array are vetted and valid.
 * @param bases - Array of Base objects to count.
 * @returns A BaseSummary object containing counts of bases by side.
 */
export function summarizeBases(bases: Planet[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const base of bases) {
        if (base.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (base.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        }
    }

    return summary;
}

/**
 * Counts planets by side (FEDERATION, EMPIRE, NEUTRAL) from the provided array.
 * Assumes all planets in the array are vetted and valid, with no base overlaps.
 * @param planets - Array of Planet objects to count.
 * @returns A PlanetSummary object containing counts of planets by side.
 */
export function summarizePlanets(planets: Planet[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const planet of planets) {
        if (planet.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (planet.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        } else if (planet.side === 'NEUTRAL') {
            summary.NEUTRAL += 1;
        }
    }

    return summary;
}
######## memory.ts
import { Player } from "./player.js";
import { Planet } from "./planet.js";


export const teamMemory = {
    federation: new Map<string, Planet>(),
    empire: new Map<string, Planet>()
};

// export function addBaseToMemory(player: Player, base: Base): void {
//     const memory = player.ship.side === "FEDERATION" ? teamBaseMemory.federation : teamBaseMemory.empire;
//     memory.bases.set(`${base.y},${base.x}`, base);
// }

export function addPlanetToMemory(player: Player, planet: Planet): void {
    if (!player.ship) return;

    const memory = player.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
    memory.set(`${planet.position.v},${planet.position.h}`, planet);
}

// export function removeBaseFromMemory(base: Base): void {
//     teamMemory.federation.bases.delete(`${base.y},${base.x}`);
//     teamMemory.empire.bases.delete(`${base.y},${base.x}`);
// }

export function removePlanetFromMemory(planet: Planet): void {
    teamMemory.federation.delete(`${planet.position.v},${planet.position.h}`);
    teamMemory.empire.delete(`${planet.position.v},${planet.position.h}`);
}

// export function isBaseInMemory(player: Player, base: Base): boolean {
//     const memory = player.ship.side === "FEDERATION" ? teamBaseMemory.federation : teamBaseMemory.empire;
//     return memory.bases.has(`${base.y},${base.x}`);
// }

export function isPlanetInMemory(player: Player, planet: Planet): boolean {
    if (!player.ship) return false;
    const memory = player.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
    return memory.has(`${planet.position.v},${planet.position.h}`);
}
######## move.ts
import {
    sendMessageToClient,
    putClientOnHold,
    releaseClient,
    sendOutputMessage,
    addPendingMessage
} from "./communication.js";
import { Ship, applyDeviceDamage } from "./ship.js";
import { bresenhamLine } from "./coords.js";
import { GRID_WIDTH, GRID_HEIGHT, WARP_DELAY_MIN_MS, WARP_DELAY_RANGE, IMPULSE_DELAY_MS, IMPULSE_DELAY_RANGE } from "./settings.js";
import { isInBounds, getCoordsFromCommandArgs, findObjectAtPosition, ocdefCoords, isAdjacent, getTrailingPosition } from "./coords.js";
import { Player } from "./player.js";
import { Command } from "./command.js";
import { gameEvents } from "./api/events.js";
import { ShipMovedPayload } from "./api/events.js";

import { disconnectTractor } from "./tractor.js";

export function moveCommand(player: Player, command: Command, done?: () => void): void {

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        done?.();
        return;
    }

    const args = command.args;
    const ship = player.ship;

    if (!player.ship.isDeviceOperational("warp")) {
        done?.();
        return;
    }

    if (!args.length) {
        sendMessageToClient(player, "Usage: MOVE/IMPULSE [A|R|C] <vpos> <hpos> OR MOVE C <ship>");
        done?.();
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        args,
        ship.position.v,
        ship.position.h,
        true
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "MOVE > BAD COORD",
            MEDIUM: `Bad MOVE input (${mode})`,
            LONG: `Invalid MOVE command: ${error} in ${mode}`
        });
        done?.();
        return;
    }

    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "MOVE > OUT OF BOUNDS",
            MEDIUM: "Invalid MOVE target sector.",
            LONG: `Target sector must be within 1–${GRID_WIDTH}.`
        });
        done?.();
        return;
    }

    const startV = ship.position.v;
    const startH = ship.position.h;
    const dv = Math.abs(targetVInput - startV);
    const dh = Math.abs(targetHInput - startH);
    const warp = Math.max(dv, dh);

    if (warp === 0) {
        sendOutputMessage(player, {
            SHORT: "MOVE > SAME",
            MEDIUM: "Already there.",
            LONG: "You're already at that position."
        });
        done?.();
        return;
    }

    if (warp > 6) {
        sendOutputMessage(player, {
            SHORT: "MOVE > WARP MAX",
            MEDIUM: "Warp too far. Max 6.",
            LONG: "Warp factor too high. Maximum warp is 6 sectors."
        });
        done?.();
        return;
    }

    maybeDamageFromWarp(ship, warp);

    let multiplier = 1;
    if (ship.shieldsUp) {
        multiplier = 2;
    }
    if (ship.tractorPartner) {
        multiplier = 3;
    }

    const energyCost = warp * warp * multiplier;

    if (ship.energy < energyCost) {
        sendOutputMessage(player, {
            SHORT: `MOVE > NO E`,
            MEDIUM: `Energy too low: need ${energyCost}`,
            LONG: `Not enough energy. Needed: ${energyCost}, Available: ${ship.energy}`
        });
        done?.();
        return;
    }

    if (ship.docked) {
        ship.docked = false;
        sendMessageToClient(player, "You have undocked from the base.");
    }

    // —— Collision Detection ——  
    const destination = { v: targetVInput, h: targetHInput };
    let prevPoint = { v: startV, h: startH };
    let collisionDetected = false;

    for (const pt of bresenhamLine(startV, startH, destination.v, destination.h)) {
        const { v, h } = pt;
        if (v === startV && h === startH) continue;

        if (findObjectAtPosition(v, h)) {
            destination.h = prevPoint.h;
            destination.v = prevPoint.v;
            collisionDetected = true;
            break;
        }

        prevPoint = pt;
    }

    const originalEnergy = ship.energy;
    ship.energy -= energyCost;
    //updateShipCondition(player);  TODO    

    maybeMisnavigate(player, destination);

    const delayMs = WARP_DELAY_MIN_MS + Math.random() * WARP_DELAY_RANGE;
    const formattedTarget = ocdefCoords(player.settings.ocdef, player.ship.position, { v: destination.v, h: destination.h });

    putClientOnHold(player, `Warping to ${formattedTarget} (warp ${warp})...`);

    const message = collisionDetected
        ? "Navigation Officer: Collision averted, Captain!"
        : `${ship.name} now in sector ${formattedTarget}.`;

    const timer = setTimeout(() => {
        // Check again just before moving
        if (findObjectAtPosition(destination.v, destination.h)) {
            releaseClient(player);
            ship.energy = originalEnergy;
            sendMessageToClient(player, "Warp aborted: sector is now occupied.");
        } else {
            releaseClient(player);
            const from = { v: ship.position.v, h: ship.position.h };
            ship.position = { v: destination.v, h: destination.h };
            const to = { v: destination.v, h: destination.h };

            // add if emitting todo
            gameEvents.emit<ShipMovedPayload>({
                type: "ship_moved",
                payload: {
                    shipName: ship.name,
                    side: ship.side,
                    from,
                    to,
                    distance: Math.max(Math.abs(to.v - from.v), Math.abs(to.h - from.h)),
                },
            });

            sendMessageToClient(player, message);
            if (ship.tractorPartner) tractorShip(ship);
        }
        done?.();
    }, delayMs);
    player.currentCommandTimer = timer;
    //starbasePhaserDefense(player); TODO
}

function maybeDamageFromWarp(ship: Ship, warpDistance: number): void {
    if (warpDistance <= 4) return;

    if (warpDistance >= 5) {
        sendMessageToClient(ship.player, `Warning: warp factor ${warpDistance} may damage engines`);
        let damage = 0;
        if (warpDistance === 5 && Math.random() < 0.2) {
            damage = 100;
        } else if (warpDistance >= 6 && Math.random() < 0.5) {
            damage = 200;
        }

        if (damage > 0) {
            const status = damage >= 300 ? "destroyed" : "damaged";
            applyDeviceDamage(ship, damage, ["warp"]);
            sendMessageToClient(ship.player, `Warp engines ${status}`);
        }
    }
}

export function impulseCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        done?.();
        return;
    }

    const ship = player.ship;

    if (!ship.isDeviceOperational("impulse")) {
        done?.();
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        command.args,
        ship.position.v,
        ship.position.h,
        false // COMPUTED not allowed for IMPULSE
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "IMP > BAD COORD",
            MEDIUM: `Bad IMPULSE input (${mode})`,
            LONG: `Invalid IMPULSE command: ${error} in ${mode}`
        });
        done?.();
        return;
    }

    const destination = { v: targetVInput, h: targetHInput };

    // DECWAR: only cardinal directions allowed
    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "IMP > RANGE",
            MEDIUM: "Not in bounds.",
            LONG: "IMPULSE move must be to a sector within the grid."
        });
        done?.();
        return;
    }

    // DECWAR: only cardinal directions allowed
    if (!isAdjacent(ship.position, destination)) {
        sendOutputMessage(player, {
            SHORT: "IMP > RANGE",
            MEDIUM: "Not adjacent.",
            LONG: "IMPULSE move must be to an adjacent sector."
        });
        done?.();
        return;
    }

    if (findObjectAtPosition(destination.v, destination.h)) {
        sendOutputMessage(player, {
            SHORT: "IMP > OCCUPIED",
            MEDIUM: "Impulse failed: blocked.",
            LONG: "IMPULSE failed: destination sector is occupied."
        });
        done?.();
        return;
    }

    let energyCost = 1;
    if (ship.shieldsUp) {
        energyCost *= 2;
    }
    // TODO tractor?

    if (ship.energy < energyCost) {
        sendOutputMessage(player, {
            SHORT: "IMP > NO E",
            MEDIUM: "Not enough energy.",
            LONG: "IMPULSE failed: not enough energy."
        });
        done?.();
        return;
    }

    if (ship.docked) {
        ship.docked = false;
        sendMessageToClient(player, "You have undocked.");
    }

    ship.energy -= energyCost;

    // updateShipCondition(player);  TODO

    maybeMisnavigate(player, destination);  // TODO TEST

    putClientOnHold(player, "Impulse power...");


    const delayMs = IMPULSE_DELAY_MS + Math.random() * IMPULSE_DELAY_RANGE;

    const timer = setTimeout(() => {
        releaseClient(player);
        if (findObjectAtPosition(destination.v, destination.h)) {
            sendOutputMessage(player, {
                SHORT: "IMP > NOW BLOCKED",
                MEDIUM: "Impulse failed: now occupied.",
                LONG: "IMPULSE failed: destination sector is now occupied."
            });
            done?.();
            return;
        }

        const coords = ocdefCoords(player.settings.ocdef, ship.position, destination);
        ship.position = destination;
        sendMessageToClient(player, `IMPULSE complete to sector ${coords}`);

        tractorShip(ship);
        done?.();
    }, delayMs);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player);  TODO
}

function maybeMisnavigate(player: Player, destination: { v: number; h: number }): void {
    if (!player.ship) return;
    const ship = player.ship;

    if (ship.devices.computer >= 300) {
        sendMessageToClient(player, "Navigation is inexact: computer inoperative.");

        const offsetV = Math.floor(Math.random() * 3) - 1;
        const offsetH = Math.floor(Math.random() * 3) - 1; // -1 to +1

        destination.v = Math.max(1, Math.min(GRID_HEIGHT, destination.v + offsetV));
        destination.h = Math.max(1, Math.min(GRID_WIDTH, destination.h + offsetH));
    }
}

function tractorShip(ship: Ship): void {
    if (!ship.tractorPartner) return;

    const trailingPosition = getTrailingPosition(ship.position, ship.tractorPartner.position);
    if (!trailingPosition) {
        disconnectTractor(ship);
    } else {
        ship.tractorPartner.position = trailingPosition;
        const coords = ocdefCoords(ship.tractorPartner.player.settings.ocdef, ship.tractorPartner.position, trailingPosition);
        sendMessageToClient(ship.tractorPartner.player, `${ship.name} has moved to ${coords}.`);
        addPendingMessage(ship.tractorPartner.player, `You were tractored to @${trailingPosition.v}-${trailingPosition.h}}.`);
    }
}


######## news.ts
import { sendMessageToClient } from './communication.js';
import { Player } from './player.js';
import fs from 'fs';
import path from 'path';

let newsLog: string[] = [];

export function newsCommand(player: Player): void {
    if (newsLog.length === 0) {
        const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/news.txt');
        const raw = fs.readFileSync(filePath, 'utf8');
        newsLog = raw.split(/\r?\n/);
    }

    if (newsLog.length === 0) {
        sendMessageToClient(player, "No news at this time.");
        return;
    }

    for (const line of newsLog) {
        sendMessageToClient(player, `${line}`);
    }
    sendMessageToClient(player, "");
}

######## nova.ts
import { sendMessageToClient, sendMessageToOthersWithFormat } from "./communication.js";
import { players, stars, pointsManager, removePlayerFromGame, planets, bases, checkEndGame } from "./game.js";
import { Player } from "./player.js";
import { ocdefCoords, isAdjacent } from "./coords.js";
import { disconnectTractorWithReason } from "./tractor.js";
import { Planet } from "./planet.js";
import { Blackhole } from "./blackhole.js";
import { Ship } from "./ship.js";

// Check if a position is within the galaxy (Fortran: ingal)
function isInGalaxy(v: number, h: number): boolean {
    // Assuming galaxy is 0–99 for both v and h (adjust based on your game)
    return v >= 0 && v <= 99 && h >= 0 && h <= 99;
}

// Check if a position is empty or contains a black hole (Fortran: dispc)
function getPositionType(v: number, h: number): string {
    // Check for black hole (adjust based on your game's black hole representation)
    if (planets.some(p => p.position.v === v && p.position.h === h && p instanceof Blackhole)) {
        return "BLACK_HOLE";
    }
    // Check if occupied by ship, planet, or base
    if (
        players.some(p => p.ship && p.ship.position.v === v && p.ship.position.h === h) ||
        planets.some(p => p.position.v === v && p.position.h === h) ||
        bases.federation.some(b => b.position.v === v && b.position.h === h) ||
        bases.empire.some(b => b.position.v === v && b.position.h === h)
    ) {
        return "OCCUPIED";
    }
    return "EMPTY";
}

// Displace a ship or base to a new position (Fortran: setdsp)
function displaceObject(obj: Ship | Planet, newV: number, newH: number): void {
    if (obj instanceof Ship) {
        obj.position.v = newV;
        obj.position.h = newH;
        obj.condition = "RED";
        obj.docked = false; // Fortran: docked(j) = .FALSE.
    } else if (obj instanceof Planet) {
        obj.position.v = newV;
        obj.position.h = newH;
        // If obj is a base, update its location in the bases array
        if (obj.isBase) {
            // Find the base in the correct base array and update its position
            const baseArray = obj.side === "FEDERATION" ? bases.federation : bases.empire;
            const baseIndex = baseArray.findIndex(b => b === obj);
            if (baseIndex !== -1) {
                baseArray[baseIndex].position.v = newV;
                baseArray[baseIndex].position.h = newH;
            }
        }
    }
}

export function triggerNovaAt(player: Player, v: number, h: number): void {
    if (!player.ship) return;

    communicateNova(player, v, h);

    const directions = [
        { disV: -1, disH: 0 }, // Up
        { disV: 1, disH: 0 },  // Down
        { disV: 0, disH: -1 }, // Left
        { disV: 0, disH: 1 },  // Right
    ];

    // Handle ships
    for (const other of players) {
        if (!other.ship) continue;

        if (isAdjacent(other.ship.position, { v, h })) {
            const damage = 1000 + Math.random() * 2000;
            applyNovaDamageShip(player, other, damage, v, h);

            // Find tractoring player (if any)
            const tractoringShip = other.ship.tractorPartner

            // Attempt displacement (Fortran: JUMP)
            const oldV = other.ship.position.v;
            const oldH = other.ship.position.h;

            for (const { disV, disH } of directions) {
                const newV = oldV + disV;
                const newH = oldH + disH;

                if (!isInGalaxy(newV, newH)) continue;
                if (!isAdjacent({ v: oldV, h: oldH }, { v: newV, h: newH })) continue;

                const posType = getPositionType(newV, newH);
                if (posType === "BLACK_HOLE") {
                    destroyShipByNova(other, newV, newH);
                    sendMessageToClient(other, `Your ship was displaced into a black hole at ${newV}-${newH} by a nova!`);
                    if (player !== other && player.ship) {
                        pointsManager.addEnemiesDestroyed(1, player, player.ship.side);
                    }
                    if (tractoringShip) {
                        disconnectTractorWithReason(tractoringShip, `Target destroyed by black hole at ${newV}-${newH}`);
                    }
                    break;
                } else if (posType === "EMPTY") {
                    displaceObject(other.ship, newV, newH);
                    sendMessageToClient(other, `Your ship was displaced to ${newV}-${newH} by a nova!`);
                    break;
                }
            }
            // Removed: if (!displaced) { disconnectTractorWithReason(other.ship, "nova"); }
        }
    }

    // Handle planets and bases
    for (const planet of planets) {
        if (isAdjacent(planet.position, { v, h })) {
            if (planet.isBase) {
                const side = planet.side;
                if (side !== "FEDERATION" && side !== "EMPIRE") continue;
                const basesArray = side === "FEDERATION" ? bases.federation : bases.empire;
                const base = basesArray.find(b => b.position.v === planet.position.v && b.position.h === planet.position.h);
                if (!base) continue;

                const oldV = base.position.v;
                const oldH = base.position.h;

                for (const { disV, disH } of directions) {
                    const newV = oldV + disV;
                    const newH = oldH + disH;

                    if (!isInGalaxy(newV, newH)) continue;
                    if (!isAdjacent({ v: oldV, h: oldH }, { v: newV, h: newH })) continue;

                    const posType = getPositionType(newV, newH);
                    if (posType === "BLACK_HOLE") {
                        base.energy = 0;
                        planet.isBase = false;
                        basesArray.splice(basesArray.indexOf(base), 1);
                        sendMessageToClient(player, `Base at ${oldV}-${oldH} was displaced into a black hole at ${newV}-${newH} by a nova!`);
                        if (player.ship.side !== side) {
                            pointsManager.addDamageToBases(10000, player, player.ship.side);
                        } else {
                            pointsManager.addDamageToBases(-10000, player, player.ship.side);
                        }
                        checkEndGame();
                        break;
                    } else if (posType === "EMPTY") {
                        displaceObject(base, newV, newH);
                        planet.position.v = newV;
                        planet.position.h = newH;
                        sendMessageToClient(player, `Base at ${oldV}-${oldH} was displaced to ${newV}-${newH} by a nova!`);
                        break;
                    }
                }
            }

            applyNovaDamagePlanet(player, planet, v, h);
        }
    }

    removeStarAt(v, h);
    pointsManager.addStarsDestroyed(1, player, player.ship.side);

    let time = 300;
    for (const star of stars.slice()) {
        if (isAdjacent(star.position, { v, h }) && Math.random() < 0.8) {
            setTimeout(() => {
                triggerNovaAt(player, star.position.v, star.position.h);
            }, time);
            time += 200;
        }
    }
}

function communicateNova(player: Player, v: number, h: number): void {
    if (!player.ship) return;
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });

    const shooterMsg = player.settings.output === "SHORT"
        ? `NOVA @${coords}`
        : `A nova has detonated at ${coords}!`;
    sendMessageToClient(player, shooterMsg);

    sendMessageToOthersWithFormat(player, (recipient) => {
        const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
        return recipient.settings.output === "SHORT"
            ? `NOVA @${formatted}`
            : `A nova has detonated at ${formatted}!`;
    });
}

function applyNovaDamageShip(attacker: Player, player: Player, damage: number, v: number, h: number): void {
    if (!player.ship) return;
    player.ship.energy = Math.max(0, player.ship.energy - damage);
    player.ship.damage += damage / 2;
    player.ship.condition = "RED";

    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });
    const msg = player.settings.output === "SHORT"
        ? `HIT -${Math.round(damage)}`
        : `You were hit by a nova at ${coords} for ${Math.round(damage)} damage!`;
    sendMessageToClient(player, msg);

    if (player.ship.energy <= 0 || player.ship.damage >= 2500) {
        if (attacker !== player && attacker.ship) {
            pointsManager.addEnemiesDestroyed(1, attacker, attacker.ship.side);
        }
        destroyShipByNova(player, v, h);
    }
}

function applyNovaDamagePlanet(player: Player, planet: Planet, v: number, h: number): void {
    if (!player.ship) return;

    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });
    let msg: string;
    let destroyed = false;

    if (planet.isBase) {
        const side = planet.side;
        if (side !== "FEDERATION" && side !== "EMPIRE") return;
        const basesArray = side === "FEDERATION" ? bases.federation : bases.empire;
        const baseIndex = basesArray.findIndex(b => b.position.v === planet.position.v && b.position.h === planet.position.h);
        if (baseIndex === -1) return;

        const base = basesArray[baseIndex];
        const wasUndamaged = base.energy === 1000;
        const damage = 300 + (Math.random() * 200 - 100);
        base.energy = Math.max(0, base.energy - damage);

        const ihita = damage * 8 + Math.random() * 1000;
        if (player.ship.side !== side) {
            pointsManager.addDamageToBases(ihita, player, player.ship.side);
        } else {
            pointsManager.addDamageToBases(-ihita, player, player.ship.side);
        }

        if (wasUndamaged) {
            msg = player.settings.output === "SHORT"
                ? `BASE DST @${coords}`
                : `Base at ${coords} is under attack by a nova!`;
            sendMessageToClient(player, msg);
            sendMessageToOthersWithFormat(player, (recipient) => {
                const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
                return recipient.settings.output === "SHORT"
                    ? `BASE DST @${formatted}`
                    : `Base at ${formatted} is under attack by a nova!`;
            });
        }

        if (base.energy <= 0) {
            destroyed = true;
            planet.isBase = false;
            if (player.ship.side !== side) {
                pointsManager.addDamageToBases(10000, player, player.ship.side);
            } else {
                pointsManager.addDamageToBases(-10000, player, player.ship.side);
            }
            basesArray.splice(baseIndex, 1);
            checkEndGame();
        }

        msg = player.settings.output === "SHORT"
            ? destroyed ? `BASE X @${coords}` : `BASE HIT -${Math.round(damage)} @${coords}`
            : destroyed
                ? `Base at ${coords} was destroyed by a nova!`
                : `Base at ${coords} was hit by a nova for ${Math.round(damage)} damage!`;
        sendMessageToClient(player, msg);

        sendMessageToOthersWithFormat(player, (recipient) => {
            const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
            return recipient.settings.output === "SHORT"
                ? destroyed ? `BASE X @${formatted}` : `BASE HIT -${Math.round(damage)} @${formatted}`
                : destroyed
                    ? `Base at ${formatted} was destroyed by a nova!`
                    : `Base at ${formatted} was hit by a nova for ${Math.round(damage)} damage!`;
        });
    } else {
        planet.builds = Math.max(0, planet.builds - 3);

        if (planet.builds <= 0) {
            destroyed = true;
            pointsManager.addPlanetsDestroyed(1, player, player.ship.side);
            const planetIndex = planets.findIndex(p => p.position.v === v && p.position.h === h);
            if (planetIndex !== -1) {
                planets.splice(planetIndex, 1);
            }
            const basesArray = planet.side === "FEDERATION" ? bases.federation : bases.empire;
            const baseIndex = basesArray.findIndex(base => base.position.v === v && base.position.h === h);
            if (baseIndex !== -1) {
                basesArray.splice(baseIndex, 1);
            }
            planet.isBase = false;
            checkEndGame();
        }

        msg = player.settings.output === "SHORT"
            ? `PLNT HIT -3 @${coords}`
            : destroyed
                ? `Planet at ${coords} was destroyed by a nova!`
                : `Planet at ${coords} lost 3 builds due to a nova!`;
        sendMessageToClient(player, msg);

        sendMessageToOthersWithFormat(player, (recipient) => {
            const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
            return recipient.settings.output === "SHORT"
                ? `PLNT HIT -3 @${formatted}`
                : destroyed
                    ? `Planet at ${formatted} was destroyed by a nova!`
                    : `Planet at ${formatted} lost 3 builds due to a nova!`;
        });
    }
}

function destroyShipByNova(player: Player, v: number, h: number): void {
    if (!player.ship) return;

    sendMessageToClient(player, `Your ship was destroyed by a nova explosion!`);
    const name = player.ship.name ?? "Unknown";

    sendMessageToOthersWithFormat(player, (recipient) => {
        const coords = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
        return formatNovaKillMessage(name, coords, recipient.settings.output);
    });

    removePlayerFromGame(player);
}

function formatNovaKillMessage(name: string, coords: string, output: "SHORT" | "MEDIUM" | "LONG"): string {
    switch (output) {
        case "SHORT":
            return `${name[0]} > X @${coords}`;
        case "MEDIUM":
            return `${name} destroyed by nova @${coords}`;
        case "LONG":
        default:
            return `${name} was destroyed by a nova at ${coords}`;
    }
}

function removeStarAt(v: number, h: number): void {
    const index = stars.findIndex(star => star.position.v === v && star.position.h === h);
    if (index !== -1) {
        stars.splice(index, 1);
    }
}
######## ove.ts
import {
    sendMessageToClient,
    sendOutputMessage
} from "./communication.js";

import { GRID_WIDTH } from "./settings.js";
import { isInBounds, getCoordsFromCommandArgs } from "./coords.js";
import { Player } from "./player.js";
import { Command } from "./command.js";



export function oveCommand(player: Player, command: Command): void {

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        return;
    }

    const args = command.args;
    const ship = player.ship;

    if (!player.ship.isDeviceOperational("warp")) {
        return;
    }

    if (!args.length) {
        sendMessageToClient(player, "Usage: MOVE/IMPULSE [A|R|C] <vpos> <hpos> OR MOVE C <ship>");
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        args,
        ship.position.v,
        ship.position.h,
        true
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "MOVE > BAD COORD",
            MEDIUM: `Bad MOVE input (${mode})`,
            LONG: `Invalid MOVE command: ${error} in ${mode}`
        });
        return;
    }

    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "MOVE > OUT OF BOUNDS",
            MEDIUM: "Invalid MOVE target sector.",
            LONG: `Target sector must be within 1–${GRID_WIDTH}.`
        });
        return;
    }

    player.ship.position = { v: targetVInput, h: targetHInput };
    sendMessageToClient(player, `OVER to sector ${targetVInput}-${targetHInput}`);
}

######## phaser.ts
import { Player } from './player.js';
import { Command } from './command.js';
import {
    OutputSetting,
    STARBASE_PHASER_RANGE,
    MAX_SHIELD_ENERGY
} from './settings.js';
import { sendMessageToClient, addPendingMessage, sendOutputMessage } from './communication.js';
import { chebyshev, ocdefCoords, getCoordsFromCommandArgs } from './coords.js';
import { Planet } from './planet.js';
import { players, planets, bases, removePlayerFromGame, checkEndGame, pointsManager } from './game.js';
import { handleUndockForAllShipsAfterPortDestruction } from './ship.js';
import { SHIP_FATAL_DAMAGE, PLANET_PHASER_RANGE } from './game.js';
import { gameEvents } from './api/events.js';

import type { Side } from "./settings.js";

type ScoringAPI = {
    addDamageToEnemies?(amount: number, source: Player, side: Side): void;
    addDamageToBases?(amount: number, source: Player, side: Side): void;
    addEnemiesDestroyed?(count: number, source: Player, side: Side): void;
    addPlanetsCaptured?(count: number, player: Player, side: Side): void;
    incrementShipsCommissioned?(side: Side): void;
};



export function phaserCommand(player: Player, command: Command): void {
    if (!player.ship) {
        sendMessageToClient(player, "You cannot fire phasers — you have no ship.");
        return;
    }

    let args = command.args;
    const now = Date.now();
    const [ph1, ph2] = player.ship.cooldowns.phasersAvailableAt;
    const bankIndex = ph1 <= ph2 ? 0 : 1;
    let energy = NaN;

    if (!player.ship.isDeviceOperational("phaser")) return;

    if (now < player.ship.cooldowns.phasersAvailableAt[bankIndex]) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > RCHG"); break;
            case "MEDIUM": sendMessageToClient(player, "Phasers unavailable — recharging."); break;
            case "LONG": sendMessageToClient(player, "Both phaser banks are currently recharging."); break;
        }
        return;
    }

    // Parse arguments
    if (command.args.length === 2) {
        args = [player.settings.icdef, ...command.args];  // v h
    } else if (command.args.length === 3) { // either energy v h, or mode v h
        energy = parseInt(command.args[0], 10);
        if (!Number.isNaN(energy)) {
            args[0] = player.settings.icdef // remove energy and treat as normal
        }
    } else if (command.args.length === 4) { // mode energy v h
        energy = parseInt(command.args[1], 10);
        if (Number.isNaN(energy)) {
            switch (player.settings.output) {
                case "SHORT":
                    sendMessageToClient(player, "PH > BAD E");
                    break;
                case "MEDIUM":
                    sendMessageToClient(player, "Invalid phaser energy input.");
                    break;
                case "LONG":
                default:
                    sendMessageToClient(player, "Bad energy value provided. Phaser command aborted.");
                    break;
            }
            return;
        } else {
            args = command.args.slice(0, 1).concat(command.args.slice(2));
        }
    }

    if (Number.isNaN(energy)) {
        energy = 200;
    }
    energy = Math.min(Math.max(energy, 50), 500);

    const shieldPenalty = player.ship.shieldsUp ? 200 : 0;
    if (shieldPenalty > 0) {
        switch (player.settings.output) {
            case "LONG": sendMessageToClient(player, "High speed shield control activated."); break;
        }
    }

    const totalEnergyCost = energy + shieldPenalty;
    if (player.ship.energy < totalEnergyCost) {
        const e = player.ship.energy.toFixed(1);
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, `PH > NO E ${e}`); break;
            case "MEDIUM": sendMessageToClient(player, `Insufficient energy: ${e}`); break;
            case "LONG": sendMessageToClient(player, `Insufficient energy to fire phasers. Available energy: ${e}`); break;
        }
        return;
    }

    const { position: { v: targetV, h: targetH } } = getCoordsFromCommandArgs(player, args, player.ship.position.v, player.ship.position.h, true);
    const distance = chebyshev(player.ship.position, { v: targetV, h: targetH });

    if (distance > 10) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > RANGE"); break;
            case "MEDIUM": sendMessageToClient(player, "Target exceeds phaser range."); break;
            case "LONG": sendMessageToClient(player, "Target out of phaser range (maximum 10 sectors)."); break;
        }
        return;
    }

    player.ship.energy -= totalEnergyCost;
    player.ship.condition = "RED";

    const target = players.find(p => p.ship && p.ship.position.h === targetH && p.ship.position.v === targetV) ||
        planets.find(p => p.position.h === targetH && p.position.v === targetV && p.isBase);
    if (!target) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > MISS"); break;
            case "MEDIUM": sendMessageToClient(player, "No target present."); break;
            case "LONG": sendMessageToClient(player, "No valid target at that location for phaser strike."); break;
        }
        return;
    }
    const targetSide = target instanceof Planet ? target.side : target.ship?.side;  //TODO
    if (targetSide === player.ship.side) {
        sendMessageToClient(player, "Cannot fire phasers at a friendly target.");
        return;
    }

    // Phaser hit calculation (adapted from phadam)
    let phit = energy;
    const distFactor = Math.pow(0.9 + 0.02 * Math.random(), distance); // pwr(0.9-0.92, id)
    if (player.ship.devices.phaser > 0 || player.ship.devices.computer > 0) {
        phit *= 0.8; // Damaged phasers/computer reduce hit by 20%
    }
    phit *= distFactor;

    // Apply damage
    const result = applyPhaserDamage(player, target, phit);

    // Update points
    if (result.hita > 0) {
        if (target instanceof Player && target.ship && target.ship.romulanStatus.isRomulan) {
            pointsManager.addDamageToRomulans(result.hita, player, player.ship.side);
        } else if (target instanceof Planet && target.isBase) {
            pointsManager.addDamageToBases(result.hita, player, player.ship.side);
        } else {
            pointsManager.addDamageToEnemies(result.hita, player, player.ship.side);
        }
    }
    if (result.checkEndGame) {
        checkEndGame();
    }
}
export function applyPhaserDamage(
    attacker: Player,
    target: Player | Planet,
    phit: number
): { hita: number; critdv: number; critdm: number; klflg: number; checkEndGame: boolean } {
    if (!attacker.ship) {
        return { hita: 0, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };
    }

    // Spend energy & normalize phit like PHACON
    const { phit: phitUsed } = preparePhaserShot(attacker, phit);

    let hita = phitUsed;
    let critdv = 0;
    let critdm = 0;
    let klflg = 0;
    let checkEndGame = false;

    // Non-base planet behavior (unchanged)
    if (target instanceof Planet && !target.isBase) {
        if (Math.random() < 0.25) {
            if (target.builds > 0) {
                target.builds = Math.max(0, target.builds - 1);
                hita = 1;
                const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, target.position);
                sendOutputMessage(attacker, {
                    SHORT: `Planet hit @${coords}: Builds -1`,
                    MEDIUM: `Phaser hit reduced builds on planet at ${coords} by 1 (now ${target.builds}).`,
                    LONG: `Phasers damaged planetary installations at ${coords}, reducing builds by 1 to ${target.builds}. Cannot destroy planet.`
                });
            } else {
                hita = 0;
                sendMessageToClient(attacker, `Planet at full vulnerability; phasers cannot destroy it.`);
            }
        } else {
            hita = 0;
            sendMessageToClient(attacker, `Phaser hit on planet had no effect on installations.`);
        }
        return { hita, critdv, critdm, klflg, checkEndGame };
    }

    // --- PHADAM-parity shield/absorption/drain + final damage ---------
    const attackerPos = attacker.ship.position;
    const targetPos = (target instanceof Player && target.ship) ? target.ship.position : (target as Planet).position;
    const distance = chebyshev(attackerPos, targetPos);

    const shooterDamaged =
        !!(attacker.ship?.devices?.phaser > 0) || !!(attacker.ship?.devices?.computer > 0);

    // Shield "energy" and max for the target
    let rawShieldEnergy: number;
    let rawShieldMax: number;
    const targetIsBase = target instanceof Planet && target.isBase;

    if (target instanceof Player && target.ship) {
        rawShieldEnergy = target.ship.shieldEnergy;
        rawShieldMax = MAX_SHIELD_ENERGY;
    } else {
        rawShieldEnergy = (target as Planet).energy; // bases use 0..1000 scale
        rawShieldMax = 1000;
    }

    // Snapshot previous shield % (0..1000) before modification
    const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
    const toPct = (energy: number, max: number) => (max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0);
    const prevShieldPct = toPct(rawShieldEnergy, rawShieldMax);

    const core = phadamCore({
        targetIsBase,
        rawShieldEnergy,
        rawShieldMax,
        distance,
        shooterDamaged,
        phit: phitUsed,
    });

    hita = core.hita;

    // Write back updated shields/energy (post-drain)
    if (target instanceof Player && target.ship) {
        target.ship.shieldEnergy = core.newShieldEnergy;
    } else {
        (target as Planet).energy = core.newShieldEnergy; // for bases: % store (0..1000)
    }

    // --- Base collapse crit/kill BEFORE hull damage --------------------
    let baseKilledNow = false;
    if (targetIsBase) {
        const newShieldPct = toPct(core.newShieldEnergy, rawShieldMax); // post-drain, pre-hull
        if (prevShieldPct > 0 && newShieldPct === 0) {
            const rana = Math.random();
            const extra = 50 + Math.floor(100 * rana); // 50..149
            (target as Planet).energy = Math.max(0, (target as Planet).energy - extra);
            critdm = Math.max(critdm, 1);

            if (Math.random() < 0.10 || (target as Planet).energy <= 0) {
                klflg = 1;



                // ✅ BASE KILL BONUS (+/-10000), guarded
                if (attacker.ship) {
                    const atkSide = attacker.ship.side;
                    const tgtSide = (target as Planet).side;
                    const sign = (atkSide !== tgtSide) ? 1 : -1;

                    (pointsManager as unknown as ScoringAPI)
                        .addDamageToBases?.(10000 * sign, attacker, atkSide);
                }

                const baseArray = target.side === "FEDERATION" ? bases.federation : bases.empire;
                const idx = baseArray.indexOf(target);
                if (idx !== -1) baseArray.splice(idx, 1);
                (target as Planet).isBase = false;
                (target as Planet).builds = 0;
                (target as Planet).energy = 0;
                handleUndockForAllShipsAfterPortDestruction(target as Planet);
                checkEndGame = true;
                baseKilledNow = true; // don't also apply hull
            }
        }
    }

    // --- Ship device crit + jitter BEFORE hull (ships only) ------------
    if (!baseKilledNow && target instanceof Player && target.ship && Math.random() < CRIT_CHANCE) {
        const crit = applyShipCriticalParity(target, hita);
        hita = crit.hita;
        critdv = crit.critdv;
        critdm = Math.max(critdm, crit.critdm);

        const deviceKeys = Object.keys(target.ship.devices);
        const deviceName = deviceKeys[critdv]?.toUpperCase?.() ?? "DEVICE";
        addPendingMessage(target, `CRITICAL HIT: ${deviceName} damaged by ${critdm}!`);
    }

    // --- Apply damage to hull/energy (skip if base just died) ----------
    if (!baseKilledNow) {
        if (target instanceof Player && target.ship) {
            target.ship.energy -= hita;
            target.ship.damage += hita / 2;
        } else if (target instanceof Planet) {
            target.energy -= hita;
        }
    }

    // --- Destruction check (ship threshold parity = 25000) -------------
    const isDestroyed =
        (target instanceof Player && target.ship && (target.ship.energy <= 0 || target.ship.damage >= SHIP_FATAL_DAMAGE)) ||
        (target instanceof Planet && target.isBase && target.energy <= 0);

    if (isDestroyed && !baseKilledNow) {
        klflg = 1;
        if (target instanceof Player) {
            // ✅ SHIP KILL BONUS (+/-5000), guarded
            if (attacker.ship) {
                const atkSide = attacker.ship.side;
                const tgtSide = (target as Player).ship?.side;
                const sign = (tgtSide && atkSide !== tgtSide) ? 1 : -1;

                (pointsManager as unknown as ScoringAPI)
                    .addDamageToEnemies?.(5000 * sign, attacker, atkSide);
            }

            removePlayerFromGame(target);
            if (attacker.ship) {
                pointsManager.addEnemiesDestroyed(1, attacker, attacker.ship.side);
            }
        } else {
            // (base path for energy <= 0 that wasn't killed in collapse branch)
            // ✅ BASE KILL BONUS (+/-10000), guarded
            if (attacker.ship) {
                const atkSide = attacker.ship.side;
                const tgtSide = (target as Planet).side;
                const sign = (atkSide !== tgtSide) ? 1 : -1;

                (pointsManager as unknown as ScoringAPI)
                    .addDamageToBases?.(10000 * sign, attacker, atkSide);
            }

            const baseArray = target.side === "FEDERATION" ? bases.federation : bases.empire;
            const idx = baseArray.indexOf(target);
            if (idx !== -1) baseArray.splice(idx, 1);
            target.isBase = false;
            target.builds = 0;
            target.energy = 0;
            handleUndockForAllShipsAfterPortDestruction(target);
            checkEndGame = true;
            gameEvents.emit({
                type: "planet_base_removed",
                payload: {
                    planet: {
                        name: target.name,
                        previousSide: target.side,
                        position: { ...target.position }
                    },
                    reason: "collapse_phaser"
                }
            });
        }
    }

    // --- Scoring: award DAMAGE POINTS from the actual applied hit -------------
    if (attacker.ship && hita > 0) {
        const atkSide = attacker.ship.side;

        // Base damage (+/- based on friend/foe)
        if (target instanceof Planet && target.isBase) {
            const sign = atkSide !== target.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI)
                .addDamageToBases?.(Math.round(hita) * sign, attacker, atkSide);
        }
        // Ship damage (+/- based on friend/foe)
        else if (target instanceof Player && target.ship) {
            const sign = atkSide !== target.ship.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI)
                .addDamageToEnemies?.(Math.round(hita) * sign, attacker, atkSide);
        }
    }

    // --- Messaging -----------------------------------------------------
    const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, targetPos);
    sendOutputMessage(attacker, {
        SHORT: `Phaser hit @${coords}: ${Math.round(hita)}`,
        MEDIUM: `Phaser hit on target at ${coords} for ${Math.round(hita)} damage.`,
        LONG: `Phasers struck target at ${coords}, inflicting ${Math.round(hita)} damage. Critical: ${critdm > 0 ? 'Yes' : 'No'}.`
    });

    if (target instanceof Player) {
        addPendingMessage(target, `Phaser hit from ${attacker.ship.name} for ${Math.round(hita)} damage!`);
    }

    return { hita, critdv, critdm, klflg, checkEndGame };
}

// --- Add this helper near your combat utilities ----------------------

/**
 * PHADAM-parity core: shield absorption + shield drain + final damage.
 * Uses Fortran shield scale 0..1000 internally and converts back.
 */
// Core phaser/torpedo damage math — PHADAM parity
// Inputs:
//  - targetIsBase: bases always treated as “shielded” in powfac
//  - rawShieldEnergy: current shield/energy store of target
//  - rawShieldMax: MAX_SHIELD_ENERGY for ships, 1000 for bases
//  - distance: Chebyshev distance between attacker and target
//  - shooterDamaged: attacker phaser/computer damaged -> penalty
//  - phit: caller-provided “power” (PHACON uses 200; BASPHA uses 200/numply; planets use 50+30*builds / numply)
//
// Returns:
//  - hita: hull/energy damage to apply AFTER shield absorption
//  - newShieldEnergy: updated shield store (same units as input)
export function phadamCore(opts: {
    targetIsBase: boolean;
    rawShieldEnergy: number;
    rawShieldMax: number;
    distance: number;
    shooterDamaged: boolean;
    phit: number;
}): { hita: number; newShieldEnergy: number } {
    const {
        targetIsBase,
        rawShieldEnergy,
        rawShieldMax,
        distance,
        shooterDamaged,
        phit,
    } = opts;

    // helpers for 0..1000 “percent” shield math
    const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
    const toPct = (energy: number, max: number) => (max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0);
    const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

    let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

    // powfac starts at 80, halves if target has shields up OR is a base
    let powfac = 80;
    if (targetIsBase || shieldPct > 0) powfac = 40;

    // distance falloff: (0.9 + 0.02*rand)^distance
    const base = 0.9 + 0.02 * Math.random();
    let hit = Math.pow(base, Math.max(0, distance));

    // attacker device penalty
    if (shooterDamaged) hit *= 0.8;

    // local hita before scaling
    const localHita = hit;

    // Amount that penetrates shields
    if (shieldPct > 0) {
        // portion that gets through
        hit = (1000 - shieldPct) * localHita * 0.001;

        // shield drain: (localHita * powfac * phit * max(shield%*0.001, 0.1) + 10) * 0.03
        const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
        const drain = (localHita * powfac * phit * absorptionFactor + 10) * 0.03;

        shieldPct = clamp(shieldPct - drain, 0, 1000);
    } else {
        // no shields — full localHita goes through
        // (hit already equals localHita here)
    }

    // final hull/energy damage
    const hita = Math.max(0, hit * powfac * phit);

    // write back shields in caller’s units
    const newShieldEnergy = fromPct(shieldPct, rawShieldMax);

    return { hita, newShieldEnergy };
}


// --- Optional tiny helper if you don't already have one --------------
// function distanceBetween(a: { x: number; y: number }, b: { x: number; y: number }) {
//     const dx = a.x - b.x;
//     const dy = a.y - b.y;
//     return Math.hypot(dx, dy);
// }


export function starbasePhaserDefense(triggeringPlayer: Player): void {

    // function starbasePhaserDamage(distance: number, target: Player): number {
    //     let baseHit = Math.pow(0.9 + 0.02 * Math.random(), distance); // Fortran: pwr(0.9–0.92, id)
    //     if (target.ship && (target.ship.devices.phaser > 0 || target.ship.devices.computer > 0)) {
    //         baseHit *= 0.8; // Fortran: hit *= 0.8 if damaged
    //     }
    //     return baseHit;
    // }
    if (!triggeringPlayer.ship) return;
    const isRomulan = triggeringPlayer.ship.romulanStatus?.isRomulan ?? false;

    const targetSides: ("FEDERATION" | "EMPIRE")[] = isRomulan
        ? ["FEDERATION", "EMPIRE"]
        : triggeringPlayer.ship.side === "FEDERATION"
            ? ["EMPIRE"]
            : ["FEDERATION"];

    for (const side of targetSides) {
        const sideBases = side === "FEDERATION" ? bases.federation : bases.empire;

        for (const base of sideBases) {
            if (base.energy <= 0) continue;

            for (const player of players) {
                if (!player.ship) continue;
                if (player.ship.romulanStatus?.cloaked) continue;
                if (player.ship.side === side && !player.ship.romulanStatus?.isRomulan) continue;

                const distance = chebyshev(player.ship.position, base.position);
                if (distance > STARBASE_PHASER_RANGE) continue;

                // const baseHit = starbasePhaserDamage(distance, player);
                // const powfac = player.ship.shieldsUp ? 40 : 80; // Fortran: powfac halved if shields up
                // const phit = 0.4; // 200 energy equivalent (200/500)

                addPendingMessage(player, `\r\n** ALERT ** Starbase at ${base.position.v}-${base.position.h} opens fire!`);
                addPendingMessage(player, `You are under automatic phaser attack from enemy starbase!`);
                // DO_DAMANGE

                // calculateAndApplyPhaserDamage(base, player, baseHit);
            }
        }
    }
}

export function formatPhaserHit({
    attacker,
    target,
    damage,
    attackerPos,
    targetShieldPercent,
    outputLevel
}: {
    attacker: string;
    target: string;
    damage: number;
    attackerPos: { v: number, h: number };
    targetShieldPercent: number;
    outputLevel: OutputSetting;
}): string {
    const dmg = Math.round(damage);
    const shields = Math.round(targetShieldPercent);

    switch (outputLevel) {
        case "LONG":
            return `${attacker} @${attackerPos.v}-${attackerPos.h} makes ${dmg} unit phaser hit on ${target}, ${shields >= 0 ? "+" : ""}${shields}%`;
        case "MEDIUM":
            return `${attacker[0]} @${attackerPos.v}-${attackerPos.h} ${dmg}P ${target[0]}, ${shields >= 0 ? "+" : ""}${shields}%`;
        case "SHORT":
            return `${attacker[0]} ${attackerPos.v}-${attackerPos.h} ${dmg}P ${target[0]} ${shields >= 0 ? "+" : ""}${shields}`;
    }
}

export function formatPhaserBaseHit({
    player,
    base,
    damage
}: {
    player: Player;
    base: Planet;
    damage: number;
}): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const dmg = Math.round(damage);
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, base.position);
    const attacker = player.ship.name;
    const output = player.settings.output;

    switch (output) {
        case "LONG":
            return `${attacker} fires phasers and hits ${base.side} base at ${coords} for ${dmg} units`;
        case "MEDIUM":
            return `${attacker?.[0]} PH ${base.side[0]}B @${coords} ${dmg}`;
        case "SHORT":
            return `${attacker?.[0]} > ${base.side[0]}B ${coords} ${dmg}`;
        default:
            return `${attacker} fires phasers and hits ${base.side} base at ${coords} for ${dmg} units`;
    }
}

export function formatPhaserPlanetHit(player: Player, planet: Planet): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, planet.position);
    const name = player.ship.name;
    switch (player.settings.output) {
        case "SHORT":
            return `${name?.[0]} > P ${coords} ${planet.builds}B`;
        case "MEDIUM":
            return `${name} hit planet @${coords}, builds left: ${planet.builds}`;
        case "LONG":
            return `${name} fired phasers at planet located at ${coords}. Remaining builds: ${planet.builds}`;
    }
}

export function formatPhaserBaseDestroyed({ player, base }: { player: Player; base: Planet }): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, base.position);
    const output = player.settings.output;
    switch (output) {
        case "SHORT":
            return `☠ ${base.side[0]}B ${coords}`;
        case "MEDIUM":
            return `${base.side} base destroyed at ${coords}`;
        case "LONG":
            return `The ${base.side} base at ${coords} has been destroyed!`;
    }
}

export function sendFormattedMessageToObservers({
    origin,
    attacker,
    target,
    damage,
    targetShieldPercent,
    formatFunc
}: {
    origin: { v: number, h: number };
    attacker: string;
    target: string;
    damage: number;
    targetShieldPercent: number;
    formatFunc: (opts: {
        attacker: string;
        target: string;
        damage: number;
        attackerPos: { v: number, h: number };
        targetShieldPercent: number;
        outputLevel: OutputSetting;
    }) => string;
}): void {
    for (const other of players) {
        if (!other.radioOn) continue;
        if (!other.ship) continue;

        if (chebyshev(origin, other.ship.position) > 10) continue;

        const msg = formatFunc({
            attacker,
            target,
            damage,
            attackerPos: origin,
            targetShieldPercent,
            outputLevel: other.settings.output
        });

        addPendingMessage(other, msg);
    }
}

function preparePhaserShot(attacker: Player, requestedPhit: number | undefined): { phit: number; energySpent: number } {
    // Default PHACON phit
    let phit = (requestedPhit ?? 0) > 0 ? requestedPhit! : 200;

    // Cost is phit * 10 (integer scaling in original)
    let energyCost = Math.floor(phit * 10);

    // If not enough energy, scale phit down proportionally
    const ship = attacker.ship!;
    if (ship.energy < energyCost) {
        phit = Math.max(0, Math.floor(ship.energy / 10));
        energyCost = Math.floor(phit * 10);
    }

    // Deduct the cost
    ship.energy = Math.max(0, ship.energy - energyCost);

    return { phit, energySpent: energyCost };
}


export const CRIT_CHANCE = 0.20;


export function applyShipCriticalParity(
    target: Player,
    baseHita: number
): {
    hita: number;          // final hit after halve + jitter
    critdv: number;        // device index chosen (-1 if none)
    critdm: number;        // device damage amount applied
    droppedShields: boolean;
} {
    // Narrow first to satisfy strict null checks
    const ship = target.ship;
    // If somehow called without a ship, just do a safe halve+jitter and return
    if (!ship) {
        let hita = Math.max(0, Math.floor(baseHita / 2));
        const jitter = Math.floor((Math.random() - 0.5) * 1000);
        hita = Math.max(0, hita + jitter);
        return { hita, critdv: -1, critdm: 0, droppedShields: false };
    }

    // halve hit per parity
    let hita = Math.floor(baseHita / 2);

    // pick a random device (handle empty set defensively)
    const deviceKeys = Object.keys(ship.devices) as Array<keyof typeof ship.devices>;
    if (deviceKeys.length === 0) {
        const jitter = Math.floor((Math.random() - 0.5) * 1000);
        hita = Math.max(0, hita + jitter);
        return { hita, critdv: -1, critdm: 0, droppedShields: false };
    }

    const critdv = Math.floor(Math.random() * deviceKeys.length);
    const device = deviceKeys[critdv];

    // device takes damage equal to (halved) hit
    const critdm = Math.max(0, hita);
    ship.devices[device] = (ship.devices[device] ?? 0) + critdm;

    // if it's the shields device, drop shields immediately
    let droppedShields = false;
    if (/shield/i.test(String(device))) {
        ship.shieldsUp = false;
        ship.shieldEnergy = 0;
        droppedShields = true;
    }

    // jitter ±500
    const jitter = Math.floor((Math.random() - 0.5) * 1000);
    hita = Math.max(0, hita + jitter);

    return { hita, critdv, critdm, droppedShields };
}


function applyInstallationPhaserToShip(opts: {
    attackerPlanet: Planet;
    target: Player;
    phit: number;           // already scaled for numply
    distance: number;       // Chebyshev
}) {
    const { attackerPlanet, target, phit, distance } = opts;
    if (!target.ship) return { hita: 0, killed: false };

    const coords = ocdefCoords(target.settings.ocdef, attackerPlanet.position, target.ship.position);
    sendMessageToClient(target, `Phaser fire from planet @${coords}!`);

    // PHADAM shield math (shooter is NOT a ship)
    const core = phadamCore({
        targetIsBase: false,
        rawShieldEnergy: target.ship.shieldEnergy,
        rawShieldMax: MAX_SHIELD_ENERGY,
        distance,
        shooterDamaged: false,   // planet devices can’t be “damaged”
        phit
    });

    // write back shields, then ship-crit + jitter BEFORE hull (PHADAM parity)
    target.ship.shieldEnergy = core.newShieldEnergy;

    let hita = core.hita;
    if (Math.random() < CRIT_CHANCE) {
        const crit = applyShipCriticalParity(target, hita);
        hita = crit.hita;
        // We don’t broadcast device detail here; player still gets the main hit msg.
    }

    // apply to hull
    target.ship.energy -= hita;
    target.ship.damage += hita / 2;

    const killed =
        target.ship.energy <= 0 || target.ship.damage >= SHIP_FATAL_DAMAGE;

    return { hita, killed };
}

export function planetPhaserDefense(triggeringPlayer: Player): void {
    if (!triggeringPlayer.ship) return;
    const isRomulanMove = !!triggeringPlayer.ship.romulanStatus?.isRomulan;
    const moverSide = triggeringPlayer.ship.side;
    const numply = players.filter(p => p.ship).length;

    for (const planet of planets) {
        if (planet.isBase) continue; // bases handled elsewhere
        if (planet.energy <= 0) continue; // inert planet

        // Activation rules:
        const isNeutral = planet.side === "NEUTRAL";
        const isEnemy = planet.side !== "NEUTRAL" && planet.side !== moverSide;

        if (!isRomulanMove) {
            if (!isEnemy && !isNeutral) continue;          // own side’s planets do NOT activate
            if (isNeutral && Math.random() < 0.5) continue; // 50% chance to skip neutrals
        } else {
            // Romulan activates both sides; neutrals still 50%
            if (isNeutral && Math.random() < 0.5) continue;
        }

        // Precompute phit from builds: (50 + 30*builds) / numply
        const phit = (50 + 30 * (planet.builds ?? 0)) / Math.max(numply, 1);

        // scan for enemy, visible ships in range 2
        for (const p of players) {
            if (!p.ship) continue;
            if (p.ship.romulanStatus?.cloaked) continue;          // “disp > 0” analogue
            if (planet.side !== "NEUTRAL" && p.ship.side === planet.side && !p.ship.romulanStatus?.isRomulan) continue;

            const dist = chebyshev(planet.position, p.ship.position);
            if (dist > PLANET_PHASER_RANGE) continue;

            // fire!
            const { hita, killed } = applyInstallationPhaserToShip({
                attackerPlanet: planet,
                target: p,
                phit,
                distance: dist
            });

            if (hita <= 0) continue;

            // Team scoring: damage goes to the planet’s captor side; kill yields +5000
            if (planet.side !== "NEUTRAL") {
                pointsManager.addDamageToEnemies(hita, /*by*/ undefined, planet.side);
                if (killed) {
                    pointsManager.addDamageToEnemies(5000, /*by*/ undefined, planet.side);
                }
            }

            // Player messaging (pridis/makhit analogue)
            const coords = ocdefCoords(p.settings.ocdef, p.ship.position, planet.position);
            addPendingMessage(p,
                `ALERT: Planet at ${coords} fires phasers! You take ${Math.round(hita)} damage.`);

            // If the victim died, handle removal like elsewhere
            if (killed) {
                removePlayerFromGame(p);
            }
        }
    }
}

######## planet.ts
import { GRID_WIDTH, GRID_HEIGHT, NUMBER_OF_PLANETS, Side, DEFAULT_BASE_ENERGY } from './settings.js';
import { findObjectAtPosition, ocdefCoords, Position } from './coords.js';
import { planets, bases } from './game.js';
import { getRandom } from './util/random.js';
import { getNearbyAlliedShips } from './ship.js';
import { addPendingMessage } from './communication.js';
import { Player } from './player.js';
import { players } from './game.js';
import { emitBaseBuilt } from './api/events.js';

interface CaptureLock {
    status: boolean;
    time: number;
}

export class Planet {
    public position: Position;
    public side: Side;
    public builds: number;
    public isBase: boolean;
    public energy: number;   // base
    public name: string;
    public hasCriedForHelp: boolean;
    public captureLock: CaptureLock;
    //public captureProgress: { by: Side, progress: number, player: Player } | undefined;   // NOT CLEAR CHECK USAGE

    constructor(v: number, h: number) {
        this.position = { v: v, h: h };
        this.side = "NEUTRAL";
        this.builds = 0;
        this.isBase = false;
        this.energy = 0;
        this.name = "unknown";
        this.hasCriedForHelp = false;
        this.captureLock = { status: false, time: 0 };
        //this.captureProgress = undefined;   // NOT CLEAR CHECK USAGE
    }

    makeBase(side: Side): void {
        const baseArray = side === "FEDERATION" ? bases.federation : bases.empire;
        this.isBase = true;
        this.side = side;
        this.energy = DEFAULT_BASE_ENERGY;
        baseArray.push(this);
    }

    callForHelp(v: number, h: number, side: Side): void {
        const allies = getNearbyAlliedShips(v, h, side, 10);

        for (const player of allies) {
            if (!player.ship) continue;
            const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v: v, h: h });
            const message = `Starbase at ${coords} under attack! Assist immediately.`;
            addPendingMessage(player, message);
        }
    }

    static getBases(side: Side | "ALL"): Planet[] {
        if (side === "ALL") {
            return [...bases.federation, ...bases.empire];
        }
        return side === "FEDERATION" ? bases.federation : bases.empire;
    }

    static generate(count: number = NUMBER_OF_PLANETS): Planet[] {
        const planets: Planet[] = [];
        for (let i = 0; i < count; i++) {
            let v: number, h: number;
            let conflict: boolean;
            let tries = 0;

            do {
                v = Math.floor(getRandom() * GRID_HEIGHT + 1);    // REPLACE FOR SEED
                h = Math.floor(getRandom() * GRID_WIDTH + 1); // REPLACE FOR SEED
                conflict = findObjectAtPosition(v, h) !== null;
                tries++;
            } while (conflict && tries < 500);

            if (conflict) {
                console.warn(`Could not safely place planet ${i + 1} after ${tries} attempts.`);
                continue;
            }

            const planet = new Planet(v, h);
            planet.name = `PL${i + 1}`;
            planet.side = "NEUTRAL";
            planets.push(planet);
        }

        return planets;
    }

    static generateBases(): void {
        const promotePlanetsToBases = (side: Side, planets: Planet[], max: number = 10) => {
            function shuffle(array: Planet[]) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(getRandom() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
                return array;
            }
            // Filter owned planets not already bases
            const eligiblePlanets = planets.filter(p => !p.isBase);

            // Randomize selection
            const shuffled = shuffle(eligiblePlanets);

            let bases = 0;
            for (const planet of shuffled) {
                if (bases >= max) break;
                planet.makeBase(side);
                bases++;
            }
        };

        promotePlanetsToBases("FEDERATION", planets);
        promotePlanetsToBases("EMPIRE", planets);
    }
}



// Exact BASBLD parity
export function baseEnergyRegeneration(triggeringPlayer: Player) {
    // Helpers
    const alivePlayers = players.filter(p => p?.ship && p.ship.energy > 0);
    const numply = alivePlayers.length; // active players only
    const countActiveForSide = (side: Side) =>
        Math.max(1, alivePlayers.filter(p => p.ship!.side === side).length); // avoid /0

    const isRomulan = !!triggeringPlayer.ship?.romulanStatus?.isRomulan;

    // Integer 'n' exactly like Fortran:
    // Romulan: n = 50 / (numply + 1)
    // Player : n = 25 / numsid(team)
    let n: number;
    if (isRomulan) {
        n = Math.floor(50 / (numply + 1)); // integer division
    } else {
        const moverSide = triggeringPlayer.ship!.side as Side;
        const team: Side = moverSide; // FEDERATION | EMPIRE | ROMULAN (ROMULAN shouldn't happen here, but it's typed)

        // numsid(team) — active ships on mover's team
        const numsidRaw = countActiveForSide(team); // declare/import as (side: Side) => number
        const numsid = Math.max(1, numsidRaw);      // avoid divide-by-zero

        n = Math.floor(25 / numsid);
    }

    // Which bases to regenerate:
    // - Romulan: both sides
    // - Player : opposite side only
    const sidesToRegen: ("FEDERATION" | "EMPIRE")[] = isRomulan
        ? ["FEDERATION", "EMPIRE"]
        : triggeringPlayer.ship!.side === "FEDERATION" ? ["EMPIRE"] : ["FEDERATION"];

    // Do the regeneration, capping at 1000 (Fortran min0(..., 1000))
    for (const side of sidesToRegen) {
        const list = side === "FEDERATION" ? bases.federation : bases.empire;
        for (const base of list) {
            if (base.energy > 0) {
                base.energy = Math.min(base.energy + n, 1000);
            }
        }
    }
}


######## planets.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";


export function planetsCommand(player: Player, command: Command): void {
    const newArgs = ["PLANETS", ...command.args];
    listCommand(player, { ...command, args: newArgs });
}
######## player.ts
import { Socket } from 'net';
import { Ship } from './ship.js';
import { sendMessageToClient } from './communication.js';
import { players, removePlayerFromGame } from './game.js';
import { Side, ScanSetting, PromptSetting, OCDEF, ICDEF, OutputSetting, MAX_SHIELD_ENERGY } from './settings.js';
import { AuthSession } from './util/auth.js';
import { findEmptyLocation } from './coords.js';

const suffocationMessages = [
    "Life support failed. Your crew drew their final breaths and fell silent.",
    "Oxygen tanks empty. The ship now drifts, silent and lifeless.",
    "You hear one final gasp... then only the hum of dead systems remains.",
    "Without life support, the crew could not survive. All hands lost.",
    "No air. No hope. Just a hulk in space, and the echo of a failed mission."
];

export class Player {
    public auth: AuthSession;
    public joinTime: number;
    public stardate: number;
    public lastActivity: number;
    public socket: Socket;
    public isAdmin: boolean;
    public isOnHold: boolean;
    public inputBuffer: string;
    public pendingMessages: string[] = [];
    public multiLine: boolean;
    public ship: Ship | null;
    public gagList: Set<string>;
    public radioOn: boolean;
    //public alive: boolean;
    public history: string[];
    public historyIndex: number;
    public ready: boolean;
    public commandQueue: string[];
    public processingCommand: boolean;
    public currentCommandTimer: NodeJS.Timeout | null = null;
    public knownEnemyBases: { x: number; y: number; side: Side }[];
    public points: {
        damageToEnemies: number;
        enemiesDestroyed: number;
        damageToBases: number;
        planetsCaptured: number;
        basesBuilt: number;
        damageToRomulans: number;
        starsDestroyed: number;
        planetsDestroyed: number;
    };
    public settings: {
        scan: ScanSetting;
        prompt: PromptSetting;
        ocdef: OCDEF;
        icdef: ICDEF;
        output: OutputSetting;
        name: string | null;
    }
    public currentPrompt?: string;

    public callBack?: (who: Player, resp: string) => void;

    constructor(socket: Socket) {
        this.auth = {
            ip: socket.remoteAddress ?? 'unknown',
            email: undefined,
            code: undefined,
            authed: false,
            createdAt: Date.now()
        };
        this.socket = socket;
        this.isAdmin = false;
        this.joinTime = Date.now();
        this.stardate = 0;
        this.lastActivity = Date.now();
        this.isOnHold = false;
        this.inputBuffer = '';
        this.pendingMessages = [];
        this.multiLine = false;
        this.ship = this.createShip();
        this.gagList = new Set();
        this.radioOn = true;
        //this.alive = false;
        this.history = [];
        this.historyIndex = -1;
        this.ready = false;
        this.commandQueue = [];
        this.processingCommand = false;
        this.currentCommandTimer = null;
        this.knownEnemyBases = [];
        this.points = {
            damageToEnemies: 0,
            enemiesDestroyed: 0,
            damageToBases: 0,
            planetsCaptured: 0,
            basesBuilt: 0,
            damageToRomulans: 0,
            starsDestroyed: 0,
            planetsDestroyed: 0,
        };
        this.settings = {
            scan: "LONG",
            prompt: "NORMAL",
            ocdef: "ABSOLUTE",
            icdef: "ABSOLUTE",
            output: "LONG",
            name: null
        }
        this.currentPrompt = undefined;
    }

    getPrompt(): string {
        if (!this.ship) {
            return '??> ';
        }

        if (this.currentPrompt) {
            return `${this.currentPrompt}`;
        }

        if (!players.includes(this)) {
            return 'PG> ';
        }

        // NORMAL prompt style
        if (this.settings.prompt === 'NORMAL') {
            return 'Command: ';
        }

        // INFORMATIVE prompt style
        const flags: string[] = [];
        const ship = this.ship;

        // S: shields down or <10%
        if (ship.shieldsUp && ship.shieldEnergy < 0.1 * MAX_SHIELD_ENERGY) {
            flags.push('S');
        }

        // E: energy < 1000 (yellow alert)
        if (ship.energy < 1000) {
            flags.push('E');
        }

        // D: total device damage > 2000
        const totalDamage = Object.values(ship.devices)
            .reduce((sum, d) => sum + d, 0);
        if (totalDamage > 2000) {
            flags.push('D');
        }

        if (ship.devices.lifeSupport >= 300 && ship.lifeSupportFailureTimer != null) {
            flags.push(`${ship.lifeSupportFailureTimer}L`);
        }

        // Combine flags; leave blank if none
        const prefix = flags.length ? flags.join('') : '';
        return `${prefix}> `;
    }

    toggleRadio(state: boolean): void {
        this.radioOn = state;
        sendMessageToClient(this, `Radio turned ${state ? "on" : "off"}.`);
    }

    gagShip(inputName: string): void {
        const resolved = Ship.resolveShipName(inputName);
        if (!resolved) {
            sendMessageToClient(this, `Unknown ship: ${inputName} `);
            return;
        }

        if (this.ship && this.ship.name === resolved) {
            sendMessageToClient(this, `You cannot gag yourself.`);
            return;
        }

        this.gagList.add(resolved.toUpperCase());
        sendMessageToClient(this, `Radio messages from ${resolved} will be ignored.`);
    }

    ungagShip(inputName: string): void {
        const resolved = Ship.resolveShipName(inputName);
        if (!resolved) {
            sendMessageToClient(this, `Unknown ship: ${inputName} `);
            return;
        }

        const removed = this.gagList.delete(resolved.toUpperCase());
        if (removed) {
            sendMessageToClient(this, `Radio messages from ${resolved} will now be received.`);
        } else {
            sendMessageToClient(this, `${resolved} was not gagged.`);
        }
    }

    updateLifeSupport(): void {
        if (!this.ship) return;
        const damage = this.ship.devices.lifeSupport;

        if (damage >= 300) {
            // LS is inoperative
            if (this.ship.lifeSupportFailureTimer == null) {
                this.ship.lifeSupportFailureTimer = 60; // Start 60-stardate countdown
                sendMessageToClient(this, "WARNING: Life support failure. You must dock or repair within 5 stardates.");
            } else {
                this.ship.lifeSupportFailureTimer--;
                if (this.ship.lifeSupportFailureTimer > 0) {
                    sendMessageToClient(this, `Life support failure: ${this.ship.lifeSupportFailureTimer} stardates remaining.`);
                } else {
                    sendMessageToClient(this, suffocationMessages[Math.floor(Math.random() * suffocationMessages.length)]);
                    removePlayerFromGame(this);
                }
            }
        } else {
            // LS repaired — reset countdown
            if (this.ship.lifeSupportFailureTimer !== null) {
                sendMessageToClient(this, "Life support repaired. Countdown cancelled.");
            }
            this.ship.lifeSupportFailureTimer = null;
        }
    }

    //     if (.not. docked(who)) shpcon(who,KLFSUP) = shpcon(who,KLFSUP) - 1	!reduce life-support reserves
    // 	if (shpcon(who,KLFSUP) .lt. 0)  shpcon(who,KSDAM) = KENDAM	!life-support gone?
    // 	if (prtype)  goto 3600
    // 	call out (lifdam,0)
    // 	call odec (shpcon(who,KLFSUP),0)
    // 	call out (strdat,1)
    // *	Update scoring information
    // 3600	do 3700 i = 1, KNPOIN
    // 	  score(i, who) = score(i, who) + tpoint(i)
    // 	  tmscor(team,i) = tmscor(team,i) + tpoint(i)
    // 	  tpoint(i) = 0
    // 3700	continue
    // 	goto 49
    // 9999	call crlf
    // 	call crlf
    // 	i = iran(5)		! five fatal messages
    // 	goto (5001, 5002, 5003, 5004, 5005), i
    // 5001	call out ('The Romulans have devised a fiendish new',1)
    // 	call out ('weapon!  Your ship and crew have been',1)
    // 	call out ('reduced to quarks and now reside in the',1)
    // 	call out ('Romulan''s energy banks!',1)
    // 	goto 3810
    // 5002	call out ('Your Navigation officer contracted a strange', 1)
    // 	call out ('virus during R&R on Zzarpion III.  The Medical', 1)
    // 	call out ('officer has been uable to diagnose it or to', 1)
    // 	call out ('devise a cure or vaccine for it.  Your entire', 1)
    // 	call out ('crew became infected, and all have died, including', 1)
    // 	call out ('you.', 1)
    // 	goto 3810
    // 5003	call out ('Due to a design error, the Doomsday Device aboard', 1)
    // 	call out ('your vessel has detonated.  The error, a missing', 1)
    // 	call out ('instruction in the built-in microprocessor, will', 1)
    // 	call out ('remain undetected for several decades.', 1)
    // 	goto 3810
    // 5004	call out ('An ancient Romulan space mine has exploded,', 1)
    // 	call out ('flooding your ship with deadly radiation.', 1)
    // 	call out ('You are forgiven, Captain, for not noticing the',1)
    // 	call out ('mine, since it was constructed of a special', 1)
    // 	call out ('plastic which is nearly transparant to most', 1)
    // 	call out ('forms of radiation.  Perhaps your crew also', 1)
    // 	call out ('forgave you as they disintegrated in a blaze', 1)
    // 	call out ('of glory!', 1)
    // 	goto 3810
    // 5005	call out ('I regret to report, Captain, that your', 1)
    // 	call out ('ship''s computer became defective, and', 1)
    // 	call out ('consequently you have flown into a', 1)
    // 	call out ('massive star.  The star''s gravitation has', 1)
    // 	call out ('torn your ship apart.', 1)

    addToHistory(line: string): void {
        const trimmed = line.trim();
        if (trimmed.length === 0) return;
        if (trimmed.toUpperCase().startsWith("TE")) return;

        this.history.push(trimmed);
        if (this.history.length > 20) {
            this.history.shift();
        }

        this.historyIndex = -1; // reset browsing on new entry
    }

    getNextHistory(): string | undefined {
        const len = this.history.length;
        if (len === 0) return undefined;
        // return this.history[len - 1];
        //Move backward in history
        this.historyIndex--;

        if (this.historyIndex < 0) {
            this.historyIndex = len - 1; // loop back to most recent
        }

        return this.history[this.historyIndex];
    }


    quitGame(): void {
        const idx = players.findIndex(p => p === this);
        if (idx !== -1) players.splice(idx, 1);

        this.socket?.end();
        this.socket?.destroy();
    }

    // rememberEnemyBaseForTeam(base: Base) {
    //     if (base.side === this.ship.side) return;
    //     if (this.ship.side !== "FEDERATION" && this.ship.side !== "EMPIRE") return;
    //     const memory = this.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
    //     const exists = memory.bases.some(b => b.x === base.x && b.y === base.y);
    //     if (!exists) {
    //         memory.bases.push(base);
    //     }
    // }

    createShip(): Ship | null {
        const ship = new Ship(this);
        ship.side = "NEUTRAL";
        ship.name = "NEUTRAL";
        const pos = findEmptyLocation();
        if (pos) {
            ship.position = pos;
        } else {
            return null;
        }
        return ship;
    }
}

######## points.ts
import { Command } from "./command.js";
import { sendMessageToClient } from "./communication.js";
import { matchesPattern } from "./util/util.js";
import { Player } from './player.js';
import { Side, settings } from './settings.js';
import { pointsManager } from './game.js';

// PointsManager is assumed to be in a separate file (game.js), but included here for completeness
export type PointCategory =
  | 'damageToEnemies'
  | 'enemiesDestroyed'
  | 'damageToBases'
  | 'planetsCaptured'
  | 'basesBuilt'
  | 'damageToRomulans'
  | 'starsDestroyed'
  | 'planetsDestroyed';

type Points = Record<PointCategory, number>;

export class PointsManager {
  private sidePoints: Record<Side, Points>;
  private shipsCommissioned: Record<Side, number>;

  constructor() {
    const empty: Points = {
      damageToEnemies: 0,
      enemiesDestroyed: 0,
      damageToBases: 0,
      planetsCaptured: 0,
      basesBuilt: 0,
      damageToRomulans: 0,
      starsDestroyed: 0,
      planetsDestroyed: 0,
    };
    this.sidePoints = {
      FEDERATION: { ...empty },
      EMPIRE: { ...empty },
      ROMULAN: { ...empty },
      NEUTRAL: { ...empty },
    };
    this.shipsCommissioned = {
      FEDERATION: 0,
      EMPIRE: 0,
      ROMULAN: 0,
      NEUTRAL: 0,
    };
  }

  private add(category: PointCategory, amount: number, player: Player | undefined, side: Side): void {
    console.log(amount, player?.ship?.name, side);
    if (player) {
      player.points[category] += amount;
    }
    if (side == "FEDERATION") {
      this.sidePoints.FEDERATION[category] += amount;
      return;
    } else if (side == "EMPIRE") {
      this.sidePoints.EMPIRE[category] += amount;
      return;
    } else if (side == "ROMULAN") {
      this.sidePoints.ROMULAN[category] += amount;
      return;
    }
  }

  addDamageToEnemies(amount: number, player: Player | undefined, side: Side): void {
    this.add('damageToEnemies', amount, player, side);
  }

  addEnemiesDestroyed(amount: number, player: Player | undefined, side: Side): void {
    this.add('enemiesDestroyed', amount, player, side);
  }

  addDamageToBases(amount: number, player: Player | undefined, side: Side): void {
    this.add('damageToBases', amount, player, side);
  }

  addPlanetsCaptured(amount: number, player: Player | undefined, side: Side): void {
    this.add('planetsCaptured', amount, player, side);
  }

  addBasesBuilt(amount: number, player: Player | undefined, side: Side): void {
    this.add('basesBuilt', amount, player, side);
  }

  addDamageToRomulans(amount: number, player: Player | undefined, side: Side): void {
    this.add('damageToRomulans', amount, player, side);
  }

  addStarsDestroyed(amount: number, player: Player | undefined, side: Side): void {
    this.add('starsDestroyed', amount, player, side);
  }

  addPlanetsDestroyed(amount: number, player: Player | undefined, side: Side): void {
    this.add('planetsDestroyed', amount, player, side);
  }

  incrementShipsCommissioned(side: Side): void {
    this.shipsCommissioned[side]++;
  }

  getShipsCommissioned(side: Side): number {
    return this.shipsCommissioned[side];
  }

  getPointsForSide(side: Side): Points {
    return this.sidePoints[side];
  }
}


// Types for points command
interface Score {
  label: string;
  points: Points;
  ships: number;
  side?: Side; // Tracks side for team scores
}

export function pointsCommand(player: Player, command: Command): void {
  if (!player.ship) {
    sendMessageToClient(player, "You must be in a ship to use this command.");
    return;
  }

  const keywords: string[] = [];
  const filters = ["Me", "I", "Federation", "Human", "Empire", "Klingon", "Romulan", "All"];

  for (const arg of command.args) {
    let matched = false;
    for (const pattern of filters) {
      if (matchesPattern(arg, pattern)) {
        keywords.push(pattern.toUpperCase());
        matched = true;
        break;
      }
    }
    if (!matched) {
      sendMessageToClient(player, `Invalid filter: ${arg}`);
      return;
    }
  }

  const scores: Score[] = [];

  // Default to individual score if no keywords
  if (keywords.length === 0 || keywords.includes("ALL") || keywords.includes("ME") || keywords.includes("I")) {
    scores.push({
      label: player.ship.name,
      points: player.points,
      ships: 1,
      side: player.ship.side
    });
  }

  // Federation score
  if (keywords.includes("ALL") || keywords.includes("FEDERATION") || keywords.includes("HUMAN")) {
    scores.push({
      label: "FEDERATION",
      points: pointsManager.getPointsForSide("FEDERATION"),
      ships: pointsManager.getShipsCommissioned("FEDERATION"),
      side: "FEDERATION"
    });
  }

  // Empire score
  if (keywords.includes("ALL") || keywords.includes("EMPIRE") || keywords.includes("KLINGON")) {
    scores.push({
      label: "EMPIRE",
      points: pointsManager.getPointsForSide("EMPIRE"),
      ships: pointsManager.getShipsCommissioned("EMPIRE"),
      side: "EMPIRE"
    });
  }

  // Romulan score
  if (keywords.includes("ALL") || keywords.includes("ROMULAN")) {
    scores.push({
      label: "ROMULAN",
      points: pointsManager.getPointsForSide("ROMULAN"),
      ships: pointsManager.getShipsCommissioned("ROMULAN"),
      side: "ROMULAN"
    });
  }

  const output = formatScores(scores, player);
  sendMessageToClient(player, output);
}

function formatScores(scores: Score[], player: Player): string {
  if (scores.length < 1 || scores.length > 4) {
    return "";
  }

  // Scaling factors per DECWAR help text
  const pointScales: Record<PointCategory, number> = {
    damageToEnemies: 1,
    enemiesDestroyed: 500,
    damageToBases: 1,
    planetsCaptured: 100,
    basesBuilt: 1000,
    damageToRomulans: 1,
    starsDestroyed: -50,
    planetsDestroyed: -100
  };

  // Point-related headers
  const pointHeaders: { label: string; key: keyof Points }[] = [
    { label: "Damage to enemies", key: "damageToEnemies" },
    { label: "Enemies destroyed", key: "enemiesDestroyed" },
    { label: "Damage to bases", key: "damageToBases" },
    { label: "Planets captured", key: "planetsCaptured" },
    { label: "Bases built", key: "basesBuilt" },
    { label: "Damage to Romulans", key: "damageToRomulans" },
    { label: "Stars destroyed", key: "starsDestroyed" },
    { label: "Planets destroyed", key: "planetsDestroyed" }
  ];

  // Filter headers with non-zero values
  const activeHeaders = pointHeaders.filter(header =>
    scores.some(score => score.points[header.key] !== 0)
  );

  // Fixed headers
  const fixedHeaders = ["", "Total points:", "", "Number of ships:", "Pts. / player:", "Pts. / stardate:"];
  const headers = [...activeHeaders.map(h => h.label), ...fixedHeaders];
  const maxLabelLength = Math.max(...scores.map(s => s.label.length), ...headers.map(h => h.length));
  const colWidth = 15;
  const formatNum = (n: number): string => n.toFixed(0).padStart(6); // DECWAR uses integers

  // Build header row
  let result = " ".repeat(maxLabelLength);
  for (const score of scores) {
    result += score.label.padStart(colWidth);
  }
  result += "\r\n";

  // Build data rows
  for (const header of headers) {
    if (header === "") {
      result += "\r\n";
      continue;
    }
    result += header.padEnd(maxLabelLength);
    for (const score of scores) {
      let value: string;
      switch (header) {
        case "Total points:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          value = formatNum(total);
          break;
        }
        case "Number of ships:": {
          value = formatNum(score.ships);
          break;
        }
        case "Pts. / player:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          const ships = score.ships;
          value = formatNum(ships > 0 ? Math.floor(total / ships) : 0); // Integer division
          break;
        }
        case "Pts. / stardate:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          let turns: number;
          if (score.side && score.side === player.ship?.side && score.ships === 1) {
            // Individual player
            turns = player.stardate;
          } else if (score.side) {
            // Team
            const sideKey = score.side.toLowerCase() as keyof typeof settings.teamTurns;
            turns = settings.teamTurns[sideKey] || 0;
          } else {
            turns = 0;
          }
          value = formatNum(turns > 0 ? Math.floor(total / turns) : 0); // Integer division
          break;
        }
        default: {
          const pointHeader = activeHeaders.find(h => h.label === header);
          value = pointHeader ? formatNum(score.points[pointHeader.key] * pointScales[pointHeader.key]) : "0".padStart(6);
          break;
        }
      }
      result += value.padStart(colWidth);
    }
    result += "\r\n";
  }

  return `\r\n${result}\r\n`;
}
######## pregame.ts
// pregame command dispatcher for DECWAR-style game
import { Player } from './player.js';
import { Command, CommandHandler, tokenize } from './command.js';
import { sendMessageToClient } from './communication.js';
import { generateGalaxy } from './game.js';

// Import only the valid pre-game handlers
import { activateCommand } from './activate.js';
import { gripeCommand } from './gripe.js';
import { helpCommand } from './help.js';
import { newsCommand } from './news.js';
import { timeCommand } from './time.js';
import { usersCommand } from './users.js';
import { quitCommand } from './quit.js';
import { findEmptyLocation } from './coords.js';
import {
    FEDERATION_SHIPS,
    EMPIRE_SHIPS,
    Side,
    settings
} from './settings.js';
import { Ship } from './ship.js';
import { generateAccessCode, isValidEmail } from './util/auth.js';
import { sendEmail } from './util/send-email.js';
import { addEmailToMailchimp } from './util/email.js';
import { setRandomSeed } from './util/random.js';
import { players } from './game.js';
import { pointsManager } from './game.js';

// Map of pre-game command keys to their handlers
const pgCommands = new Map<string, CommandHandler>([
    ['AC', activateCommand],    // ACTIVATE
    ['GR', gripeCommand],       // GRIPE
    ['HE', helpCommand],        // HELP
    ['NE', newsCommand],        // NEWS
    ['TI', timeCommand],        // TIME
    ['US', usersCommand],       // USERS
    ['QU', quitCommand],       // QUIT
]);

/**
 * Parses and executes pre-game (lobby) commands.
 * Routes input to the pgCommands map.
 */
export function parseAndExecutePGCommand(player: Player, input: string): void {
    if (!player) {
        sendMessageToClient(player, `Unknown player (pgCommand)`);
        return;
    }

    try {
        const parsed = tokenize(input);

        if (Array.isArray(parsed.tokens) && parsed.tokens.length > 0) {
            for (const commandTokens of parsed.tokens) {
                const commandKey = commandTokens[0].toUpperCase();
                const commandObject = new Command(
                    commandKey,
                    commandTokens.slice(1),
                    input
                );

                // Find the first handler whose key matches the start of the input
                let matchedHandler: CommandHandler | null = null;
                for (const [key, handler] of pgCommands) {
                    if (key[0] == commandKey.toUpperCase()[0]) {  // note matches 1 letter, make sure this stays legit
                        matchedHandler = handler;
                        break;
                    }
                }

                if (matchedHandler) {
                    matchedHandler(player, commandObject);
                    sendMessageToClient(player, "", false, true);
                } else {
                    sendMessageToClient(
                        player,
                        `Unknown pre-game command: ${commandKey}`
                    );
                }
            }
        }
    } catch (error: unknown) {
        sendMessageToClient(
            player,
            `Error parsing pre-game command: ${error instanceof Error ? error.message : String(error)}`
        );
    }
}

export function sendGameInfo(player: Player): void {
    // external setu06 !There are Romulans in this game.!
    // external setu07 !There are Black holes in this game.!
    sendMessageToClient(player, `Romulans are ${settings.romulans ? "" : "NOT "}in this game.`);
    sendMessageToClient(player, `Black holes are ${settings.blackholes ? "" : "NOT "}in this game.`);
    sendMessageToClient(player,
        `Currently there are ${players.filter(p => p.ship?.side === "FEDERATION").length} Federation ships and ${players.filter(p => p.ship?.side === "EMPIRE").length} Empire ships.\r\n`);
}

export function promptForEmail(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = `ENTER EMAIL FOR ACCESS: `;
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed === "theq") {
            pl.auth.authed = true;
            if (settings.generated) {
                sendGameInfo(pl);
                promptForLevel(pl, 0);
            } else {
                promptForRegularOrTournament(pl, 0);
            }
            // sendMessageToClient(pl, "Welcome back to the game Captain!");
            // if (pl.ship.side != "NEUTRAL") {
            //     promptForShip(pl, 0);
            // } else {
            //     promptForSide(pl, 0);
            // }
        } else if (isValidEmail(trimmed)) {
            pl.auth.email = trimmed;
            pl.auth.code = generateAccessCode();
            pl.auth.createdAt = Date.now();

            sendEmail({
                to: trimmed,
                subject: 'DECWARJS Access Code',
                text: `Welcome to DECWARJS!\n\nYour one-time login code is: ${pl.auth.code}`
            }).catch(err => {
                console.error(`Failed to send email to ${trimmed}:`, err);
                // Optionally notify the player:
                sendMessageToClient(pl, "Email error. Please try again later.");
                return;
            });
            addEmailToMailchimp(trimmed);
            promptForAccessCode(pl, 0);
            // }
        } else {
            sendMessageToClient(pl, "Invalid email.");
            promptForEmail(pl, iter + 1);
            sendMessageToClient(player, "", false, true);
        }

    };
}

export function promptForAccessCode(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "ACCESS CODE: ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed === pl.auth.code) {
            pl.auth.authed = true;
            if (settings.generated) {
                sendGameInfo(pl);
                promptForLevel(pl, 0);
            } else {
                promptForRegularOrTournament(pl, 0);
            }
        } else {
            sendMessageToClient(pl, "Invalid access code, check email for code.");
            promptForAccessCode(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function promptForRegularOrTournament(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Regular or Tournament game? ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("R")) {
            setRandomSeed(Date.now().toString());
            generateGalaxy();
            promptForLevel(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("T")) {
            promptForSeed(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter R or T. ");
            promptForRegularOrTournament(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}
export function promptForSeed(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Tournament name or number: ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.length >= 1) {
            setRandomSeed(trimmed);
            promptForRomulanEmpire(pl, 0);
        } else {
            sendMessageToClient(pl, "Invalid entry.");
            promptForSeed(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function promptForLevel(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = `Are you:\r\n1 Beginner\r\n2 Intermediate\r\n3 Expert\r\n\r\nWhich? `;
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (["1", "2", "3"].includes(trimmed)) {
            const level = parseInt(trimmed);

            if (level === 1) {
                // Beginner settings
                pl.settings.prompt = "NORMAL";
                pl.settings.scan = "LONG";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "ABSOLUTE";
                pl.settings.output = "MEDIUM";
            } else if (level === 2) {
                // Intermediate settings
                pl.settings.prompt = "INFORMATIVE";
                pl.settings.scan = "LONG";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "RELATIVE";
                pl.settings.output = "MEDIUM";
            } else if (level === 3) {
                // Expert settings
                pl.settings.prompt = "INFORMATIVE";
                pl.settings.scan = "SHORT";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "ABSOLUTE";
                pl.settings.output = "SHORT";
            }

            sendMessageToClient(pl, "Medium output format.\r\nNormal command prompt.\r\nLong SCAN format.\r\nAbsolute coordinates are default for input.\r\nBoth coordinates are default for output.\r\n");

            chooseSide(pl);
        } else {
            sendMessageToClient(pl, "Invalid choice. Please enter 1, 2, or 3.");
            promptForLevel(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function chooseSide(player: Player): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to choose a side.");
        return;
    }

    // 1) Compute current balance
    const fedCount = players.filter(p => p.ship!.side === 'FEDERATION').length;
    const empCount = players.filter(p => p.ship!.side === 'EMPIRE').length;

    // 2) Auto‑assign if one side is under‑manned by 2 or more
    if (fedCount + 2 <= empCount) {
        player.ship.side = 'FEDERATION';
        sendMessageToClient(player,
            `Auto-balancing: placing you on Federation (F=${fedCount}, E=${empCount})\r\n`,
            false, true
        );
        return promptForShip(player, 0);
    }
    if (empCount + 2 <= fedCount) {
        player.ship.side = 'EMPIRE';
        sendMessageToClient(player,
            `Auto-balancing: placing you on Empire (F=${fedCount}, E=${empCount})\r\n`,
            false, true
        );
        return promptForShip(player, 0);
    }

    promptForSide(player, 0);
}

function promptForSide(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts to choose side. Please try again later.");
        return;
    }
    player.currentPrompt = 'Which side do you wish to join?\r\n(Federation or Empire) ';
    player.callBack = (pl, resp) => {
        if (!pl.ship) {
            sendMessageToClient(pl, "You must be in a ship to choose a side.");
            return;
        }
        const choice = resp.trim().toUpperCase();
        let desired: 'FEDERATION' | 'EMPIRE' | null = null;
        if (choice.startsWith('F')) desired = 'FEDERATION';
        else if (choice.startsWith('E')) desired = 'EMPIRE';
        else if (choice == "") desired = getBalancedSide();  // game chooses side

        if (!desired) {
            return promptForSide(pl, iter + 1);
        }
        pl.ship.side = desired;
        const formattedSide = desired.charAt(0).toUpperCase() + desired.slice(1).toLowerCase();
        sendMessageToClient(pl, `\r\nYou will join the ${formattedSide}.\r\n\r\n`, false, true);
        promptForShip(pl, 0);
    }
    sendMessageToClient(player, "", false, true);
}

export function promptForShip(player: Player, iter: number): void {
    const side = player.ship?.side ?? "NEUTRAL";
    if (side == "NEUTRAL") {
        console.log("Player in promptForShip must choose a side first.");
        return;
    }

    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts to choose ship. Please try again later.");
        return;
    }
    const available = getAvailableShips(side);
    if (available.length === 0) {
        sendMessageToClient(player, `Sorry, no ${side} ships are currently free.`);
        return;
    }

    player.currentPrompt = `These vessels are available:\r\n\r\n${available
        .map(name => name.charAt(0).toUpperCase() + name.slice(1).toLowerCase())
        .join("\r\n")}\r\n\r\nWhich vessel do you desire? `;


    player.callBack = (pl, resp) => {
        let actualShipName;
        const choice = resp ? resp.trim().toUpperCase() : '';

        if (choice == "") {
            actualShipName = getRandomShip(pl.ship!.side);
            if (actualShipName) {
                sendMessageToClient(player, `You will captain the ${actualShipName}`);
            } else {
                sendMessageToClient(player, `Sorry, no ${pl.ship!.side} ships are currently free.`);
                promptForShip(pl, iter + 1);
                return;
            }
        } else {
            const freshAvailable = getAvailableShips(pl.ship!.side); // Recheck in case others claimed
            actualShipName = freshAvailable.find(ship => ship.startsWith(choice));
        }

        if (!actualShipName) {
            // Invalid input or ship no longer available
            if (!choice || !available.some(ship => ship.startsWith(choice))) {
                sendMessageToClient(player, 'That is not a valid ship name.');
            } else {
                sendMessageToClient(player, 'That ship is no longer in inventory.');
            }
            promptForShip(pl, iter + 1); // Recurse to re-prompt
            return;
        }

        const side = pl.ship!.side;
        pl.ship = new Ship(pl);
        // Successful selection
        pl.ship.name = actualShipName;
        pl.ship.side = side;
        pl.ship.position = findEmptyLocation() || { v: 1, h: 1 };
        if (side == "FEDERATION") {
            pointsManager.incrementShipsCommissioned('FEDERATION');
        } else if (side == "EMPIRE") {
            pointsManager.incrementShipsCommissioned('EMPIRE');
        }

        players.push(player);
        sendMessageToClient(player, `\r\nDECWARJS game #${settings.gameNumber}, ${settings.tournamentSeed}\r\n\r\n`, false, true);
    };

    sendMessageToClient(player, "", false, true); // Trigger the prompt
}

export function getAvailableShips(side: Side): string[] {
    const masterList = side === "FEDERATION" ? FEDERATION_SHIPS : EMPIRE_SHIPS;
    const taken = players.map(p => p.ship?.name ?? "Unknown");
    return masterList.filter(name => !taken.includes(name));
}

function getBalancedSide(): "EMPIRE" | "FEDERATION" {
    const fedCount = players.filter(p => p.ship!.side === "FEDERATION").length;
    const empCount = players.filter(p => p.ship!.side === "EMPIRE").length;

    if (fedCount < empCount) {
        return "FEDERATION";
    } else if (empCount < fedCount) {
        return "EMPIRE";
    } else {
        return Math.random() < 0.5 ? "FEDERATION" : "EMPIRE";
    }
}

function getRandomShip(side: Side): string | null {
    if (side == "NEUTRAL") return null;
    const available = getAvailableShips(side);
    if (available.length === 0) return null;
    const idx = Math.floor(Math.random() * available.length);
    return available[idx];
}

export function promptForRomulanEmpire(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Is the Romulan Empire involved in this conflict? (Yes or No) ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("Y")) {
            settings.romulans = true;
            promptForBlackholes(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("N")) {
            settings.romulans = false;
            promptForBlackholes(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter Y or N. ");
            promptForRomulanEmpire(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}


export function promptForBlackholes(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Do you want black holes? (Yes or No) ";

    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("Y")) {
            settings.blackholes = true;

            generateGalaxy();

            promptForLevel(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("N")) {
            settings.blackholes = false;
            generateGalaxy();
            promptForLevel(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter Y or N. ");
            promptForBlackholes(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}
######## quit.ts
import { sendMessageToClient } from "./communication.js";
import { Player } from "./player.js";
import { matchesPattern } from "./util/util.js";


/**
 * QUIT — Resign from the game. Destroys the ship and ends the session.
 */
export function quitCommand(player: Player): void {
    confirmQuit(player, 0);
}


function confirmQuit(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Are you sure you want to quit? (Y/N): ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (matchesPattern(trimmed, "Yes")) {
            quit(pl);
        } else if (matchesPattern(trimmed, "No")) {
            sendMessageToClient(player, "", false, true);
        } else {
            //sendMessageToClient(pl, "Invalid response. Please enter Yes or No.");
            player.currentPrompt = "Are you sure you want to quit? (Y/N): ";
            sendMessageToClient(player, "", false, true);
            confirmQuit(pl, iter + 1);
        }
    };
}


function quit(player: Player): void {
    //  const score = player.score?.total ?? 0;
    const output = player.settings?.output ?? "MEDIUM";

    // Format message based on OutputSetting
    if (output === "SHORT") {
        sendMessageToClient(player, `Quit`, true, false);
    } else if (output === "LONG") {
        sendMessageToClient(player, "You have chosen to resign from your post as captain.", true, false);
    } else {
        // MEDIUM
        sendMessageToClient(player, "You have quit the game.", true, false);
    }

    // Remove player and disconnect
    player.quitGame();
}
######## radio.ts
import { Command } from "./command.js";
import { Player } from "./player.js";
import { sendMessageToClient, } from "./communication.js";

export function radioCommand(player: Player, command: Command): void {
    const args = command.args;
    const action = args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use RADIO.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    switch (action) {
        case "ON":
            player.toggleRadio(true);
            return;
        case "OFF":
            player.toggleRadio(false);
            return;
        case "G":
        case "GAG":
            if (!args[1]) {
                sendMessageToClient(player, "Specify a ship to gag. Example: RADIO GAG LEXINGTON");
            } else {
                player.gagShip(args[1].toUpperCase());
            }
            return;
        case "U":
        case "UNGAG":
            if (!args[1]) {
                sendMessageToClient(player, "Specify a ship to ungag. Example: RADIO UNGAG LEXINGTON");
            } else {
                player.ungagShip(args[1].toUpperCase());
            }
            return;
        case undefined:
            sendMessageToClient(player, "No RADIO command specified. Use RADIO ON/OFF/GAG/UNGAG or RADIO <message>.");
            return;
    }
}
######## repair.ts
import { Player } from './player.js';
import { sendMessageToClient, putClientOnHold, releaseClient } from './communication.js';
import {
    MAX_SHIP_ENERGY,
    MAX_SHIELD_ENERGY,
    ENERGY_REPAIR_AMOUNT,
    ENERGY_REPAIR_COST,
    SHIELD_REPAIR_AMOUNT,
    SHIELD_REPAIR_COST,
    OutputSetting,
} from './settings.js';
import { DeviceName } from './ship.js';
import { Command } from './command.js';
//import { starbasePhaserDefense } from './base.js'; TODO: Add this back in

export function repairCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You cannot repair — you have no ship.");
        done?.();
        return;
    }

    const mode: OutputSetting = player.settings.output ?? "LONG";

    const defaultRepair = player.ship.docked ? 100 : 50;
    const repairAmount = command.args.length > 0 ? parseInt(command.args[0], 10) : defaultRepair;

    if (isNaN(repairAmount) || repairAmount <= 0) {
        sendMessageToClient(player, "Invalid repair amount. Usage: RE [<units>]");
        done?.();
        return;
    }

    const damagedDevices = Object.entries(player.ship.devices)
        .filter(entry => entry[1] > 0) as [DeviceName, number][];

    if (
        damagedDevices.length === 0 &&
        player.ship.energy >= MAX_SHIP_ENERGY &&
        player.ship.shieldEnergy >= MAX_SHIELD_ENERGY
    ) {
        sendMessageToClient(player, "All systems are fully operational. No repairs needed.");
        done?.();
        return;
    }

    const delaySeconds = (repairAmount * 0.08) * (player.ship.docked ? 0.5 : 1);
    putClientOnHold(player, "Repairing...");

    const timer = setTimeout(() => {
        const repaired: string[] = [];
        let totalDeviceRepair = 0;

        if (!player.ship) {
            sendMessageToClient(player, "You cannot repair — you have no ship.");
            done?.();
            return;
        }

        for (const [device, damage] of damagedDevices) {
            const repair = Math.min(repairAmount, damage);
            player.ship.devices[device] -= repair;
            totalDeviceRepair += repair;

            if (mode === "SHORT") {
                sendMessageToClient(player, `${device}+${repair}`);
            } else if (mode === "MEDIUM") {
                sendMessageToClient(player, `${device} repaired ${repair}`);
            } else {
                sendMessageToClient(player, `${device} repaired ${repair} units.`);
            }
        }

        if (player.ship.shieldEnergy < MAX_SHIELD_ENERGY) {
            if (player.ship.energy >= SHIELD_REPAIR_COST) {
                player.ship.energy -= SHIELD_REPAIR_COST;
                const restored = Math.min(SHIELD_REPAIR_AMOUNT, MAX_SHIELD_ENERGY - player.ship.shieldEnergy);
                player.ship.shieldEnergy += restored;
                repaired.push("shields");
            } else {
                if (mode !== "SHORT") {
                    sendMessageToClient(player, "Insufficient energy to repair shields.");
                }
            }
        }

        if (player.ship.energy < MAX_SHIP_ENERGY && player.ship.energy >= ENERGY_REPAIR_COST) {
            const restored = Math.min(ENERGY_REPAIR_AMOUNT, MAX_SHIP_ENERGY - player.ship.energy);
            player.ship.energy += restored;
            repaired.push("energy");
        }

        if (totalDeviceRepair > 0 || repaired.length > 0) {
            if (mode === "SHORT") {
                sendMessageToClient(player, `+${totalDeviceRepair} ${repaired.join(", ")}`);
            } else if (mode === "MEDIUM") {
                sendMessageToClient(player, `Repair complete: ${totalDeviceRepair} units. Restored: ${repaired.join(", ")}`);
            } else {
                sendMessageToClient(player, `Repair completed. Devices repaired: ${totalDeviceRepair} units. Restored: ${repaired.join(", ")}`);
            }
        } else {
            sendMessageToClient(player, "Repair completed. No systems needed repair.");
        }

        releaseClient(player);
        done?.();
    }, delaySeconds * 1000);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player);

    if (mode !== "SHORT") {
        sendMessageToClient(player, `Beginning repair of ${repairAmount} units... (${delaySeconds.toFixed(1)}s)`);
    }
}

######## romulan.ts
// romulan.ts — FORTRAN-parity Romulan (ROMDRV/ROMTOR/ROMSTR/PHAROM/TOROM/DEADRO)

import { Player } from "./player.js";
import { NullSocket } from "./util/nullsocket.js";
import { GRID_HEIGHT, GRID_WIDTH, settings } from "./settings.js";
import { players, bases, stars, pointsManager } from "./game.js";
import { addPendingMessage } from "./communication.js";
import { chebyshev, bresenhamLine, findEmptyLocation, findObjectAtPosition } from "./coords.js";
import { Planet } from "./planet.js";
import { applyPhaserDamage } from "./phaser.js";
import { torpedoDamage } from "./torpedo.js";
import { Ship } from "./ship.js";
import { Star } from "./star.js";
import { Blackhole } from "./blackhole.js";

// ----- constants (FORTRAN-aligned) -----
const KRANGE = 20;                  // search/notify/attack window
const TORP_SHOTS = 3;               // ROMTOR loop id=1..3
const PHA_PHIT = 0.4;               // FORTRAN 200 -> 0.4 (removed 10x integer trick)
const PHA_BASE_PAUSE_MS = 750;      // (slwest+1)*750 in FORTRAN; we scale by active players
const TORP_BASE_PAUSE_MS = 1000;    // (slwest+1)*1000 in FORTRAN

// ----- small helpers -----
const activePlayersPlusOne = () =>
    Math.max(1, players.filter(p => p.ship && p.ship.energy > 0).length + 1);

function iran(n: number): number {
    // 1..n inclusive (FORTRAN-like)
    return Math.floor(Math.random() * n) + 1;
}

type ScoringAPI = {
    incrementShipsCommissioned?(side: string): void;
};

// ----- Romulan singleton state -----
export let romulan: Player | null = null;
let erom = 0;                 // FORTRAN erom (Romulan “energy” tracked separately)
let romcnt = 0;               // FORTRAN romcnt (spawn cadence counter)
let rppausUntil = 0;          // phaser pause timestamp (ms)
let rtpausUntil = 0;          // torpedo pause timestamp (ms)

// ----- spawn cadence like ROMDRV -----
export function maybeSpawnRomulan(): void {
    if (!settings.generated) return;
    if (romulan && romulan.ship) return;

    romcnt += 1;

    const numply = Math.max(1, players.filter(p => p.ship && p.ship.energy > 0).length);

    // slow start: wait until roughly half a sweep has gone by
    if (romcnt * 2 < numply) return;

    // spawn only when enough cycles have passed AND a random gate opens
    if (romcnt >= numply * 3 && iran(5) === 5) {
        spawnRomulan();
        erom = iran(200) + 200; // 201..400

        // notify nearby players (iwhat=11 semantics simplified)
        if (romulan?.ship) {
            const rv = romulan.ship.position.v;
            const rh = romulan.ship.position.h;
            for (const p of players) {
                if (!p.ship) continue;
                if (chebyshev(p.ship.position, { v: rv, h: rh }) <= KRANGE) {
                    addPendingMessage(p, `Sensors: a Romulan vessel has appeared near ${rv}-${rh}!`);
                }
            }
        }
        romcnt = 0;
    }
}

// explicit spawn with placement
export function spawnRomulan(): void {
    if (romulan && romulan.ship) return;

    const pl = new Player(new NullSocket());
    pl.settings.name = "ROMULAN";
    if (pl.ship) {
        pl.ship.name = "ROMULAN";
        pl.ship.side = "ROMULAN";
        pl.ship.romulanStatus = { isRomulan: true, isRevealed: false, cloaked: true };
        pl.ship.energy = 0;          // not used for durability (we use erom)
        pl.ship.damage = 0;
        pl.ship.shieldEnergy = 0;

        const pos = findEmptyLocation();
        if (pos) {
            pl.ship.position = pos;
            players.push(pl);

            // optional scoring hook (no `any`)
            (pointsManager as unknown as ScoringAPI).incrementShipsCommissioned?.("ROMULAN");

            romulan = pl;
        }
    }
}

// ----- main per-tick update (ROMDRV core) -----
export function updateRomulan(): void {
    if (!romulan?.ship) return;

    // occasional speech
    if (iran(10) === 1) romulanSpeaks();

    // find nearest ship/base in range
    const target = findClosestTargetInRange();
    if (!target) return;

    // choose weapon by cooldowns (FORTRAN style)
    const now = Date.now();
    const phaReady = now >= rppausUntil;
    const torpReady = now >= rtpausUntil;
    if (!phaReady && !torpReady) return;

    romcnt = 0; // reset cadence when firing

    if (phaReady && torpReady) {
        if (iran(2) === 1) fireRomulanTorpedoes(target);
        else fireRomulanPhasers(target);
    } else if (phaReady) {
        fireRomulanPhasers(target);
    } else {
        fireRomulanTorpedoes(target);
    }
}

// ----- target selection like ROMDRV: ships first, then bases, within KRANGE -----
type Target =
    | { kind: "ship"; player: Player; distance: number }
    | { kind: "base"; planet: Planet; distance: number };

function findClosestTargetInRange(): Target | null {
    if (!romulan?.ship) return null;
    const rpos = romulan.ship.position;

    let best: Target | null = null;

    // enemy ships (FED/EMP)
    for (const p of players) {
        if (!p.ship) continue;
        if (p === romulan) continue;
        if (p.ship.side !== "FEDERATION" && p.ship.side !== "EMPIRE") continue;
        const d = chebyshev(p.ship.position, rpos);
        if (d > KRANGE) continue;
        if (!best || d < best.distance) best = { kind: "ship", player: p, distance: d };
    }

    // enemy bases
    for (const side of ["FEDERATION", "EMPIRE"] as const) {
        const list = side === "FEDERATION" ? bases.federation : bases.empire;
        for (const base of list) {
            const d = chebyshev(base.position, rpos);
            if (d > KRANGE) continue;
            if (!best || d < best.distance) best = { kind: "base", planet: base, distance: d };
        }
    }

    return best;
}

// ----- phaser path (PHADAM parity via applyPhaserDamage) -----
function fireRomulanPhasers(target: Target): void {
    if (!romulan?.ship) return;

    // base “calls for help” when first hit at full shields
    if (target.kind === "base" && target.planet.energy === 1000) {
        for (const p of players) {
            if (!p.ship) continue;
            if (p.ship.side === target.planet.side) {
                addPendingMessage(
                    p,
                    `Starbase ${target.planet.position.v}-${target.planet.position.h} is under Romulan phaser fire!`
                );
            }
        }
    }

    // fire (let phaser core handle distance/absorption)
    const res = applyPhaserDamage(
        romulan,
        target.kind === "ship" ? target.player : target.planet,
        PHA_PHIT
    );

    // cooldown: rppaus = now + (active+1)*750
    rppausUntil = Date.now() + activePlayersPlusOne() * PHA_BASE_PAUSE_MS;

    // message victim
    if (target.kind === "ship") {
        addPendingMessage(target.player, `Romulan phasers hit you for ${Math.round(res.hita)}!`);
    }
}

// ----- torpedo path (ROMSTR + ROMTOR parity) -----
function fireRomulanTorpedoes(target: Target): void {
    if (!romulan?.ship) return;

    // initial aim point
    let aim =
        target.kind === "ship" ? (target.player.ship ? target.player.ship.position : null) : target.planet.position;
    if (!aim) return;

    // ROMSTR: retarget to adjacent star if present
    aim = retargetToAdjacentStar(aim) ?? aim;

    // ROMTOR: 3 shots with reacquire + star retarget each time
    for (let shot = 1; shot <= TORP_SHOTS; shot += 1) {
        if (!aim) break;

        const found = findObjectAtPosition(aim.v, aim.h);
        const obj = found?.obj;

        if (obj instanceof Star) {
            // Star detonation messaging (nova behavior handled elsewhere in your engine if applicable)
            if (iran(100) <= 80) {
                addPendingMessage(romulan, `Romulan torpedo detonated near a star at ${aim.v}-${aim.h}.`);
            }
        } else if (obj instanceof Planet) {
            if (obj.isBase) {
                torpedoDamage(romulan, obj);
            } else {
                // accidental planet attack: 25% chance to reduce builds by 1
                if (iran(100) >= 75) obj.builds = Math.max(0, obj.builds - 1);
            }
        } else if (obj instanceof Ship) {
            const targetPlayer =
                players.find(p => p.ship === obj) ||
                players.find(p => p.ship && p.ship.position.v === aim!.v && p.ship.position.h === aim!.h);
            if (targetPlayer) torpedoDamage(romulan, targetPlayer);
        } else if (obj instanceof Blackhole) {
            addPendingMessage(romulan, `Romulan torpedo lost in a black hole near ${aim.v}-${aim.h}.`);
        }

        // reacquire nearest, then ROMSTR star retarget again
        const nxt = findClosestTargetInRange();
        if (!nxt) break;

        let nextPos: { v: number; h: number } | null = null;
        if (nxt.kind === "ship" && nxt.player.ship) nextPos = nxt.player.ship.position;
        if (nxt.kind === "base") nextPos = nxt.planet.position;
        if (!nextPos) break;

        aim = retargetToAdjacentStar(nextPos) ?? nextPos;

        // cooldown: tpaus = now + (active+1)*1000
        rtpausUntil = Date.now() + activePlayersPlusOne() * TORP_BASE_PAUSE_MS;
    }
}

// ROMSTR: if a star is adjacent to aim, retarget to it
function retargetToAdjacentStar(pos: { v: number; h: number }): { v: number; h: number } | null {
    const vf = Math.max(1, pos.v - 1);
    const vl = Math.min(GRID_HEIGHT, pos.v + 1);
    const hf = Math.max(1, pos.h - 1);
    const hl = Math.min(GRID_WIDTH, pos.h + 1);

    for (let v = vf; v <= vl; v += 1) {
        for (let h = hf; h <= hl; h += 1) {
            if (stars.some(s => s.position.v === v && s.position.h === h)) return { v, h };
        }
    }
    return null;
}

// ----- movement helper (safe approach) -----
function moveToward(targetPos: { v: number; h: number }): void {
    if (!romulan?.ship) return;
    const rpos = romulan.ship.position;

    const dv = targetPos.v - rpos.v;
    const dh = targetPos.h - rpos.h;
    const dist = Math.max(Math.abs(dv), Math.abs(dh));

    // up to 4 steps, but don’t enter the target tile
    const steps = Math.max(1, Math.min(4, dist));
    const sv = Math.sign(dv);
    const sh = Math.sign(dh);

    let nv = rpos.v + sv * Math.max(0, steps - 1);
    let nh = rpos.h + sh * Math.max(0, steps - 1);

    // clamp to bounds
    nv = Math.max(1, Math.min(GRID_HEIGHT, nv));
    nh = Math.max(1, Math.min(GRID_WIDTH, nh));

    // simple path clearance
    const path = [...bresenhamLine(rpos.v, rpos.h, nv, nh)];
    path.shift(); // skip start
    let blocked = false;
    for (const p of path) {
        if (findObjectAtPosition(p.v, p.h)) {
            blocked = true;
            break;
        }
    }
    if (blocked) {
        nv = rpos.v + sv * Math.max(0, steps - 2);
        nh = rpos.h + sh * Math.max(0, steps - 2);
    }

    if (!findObjectAtPosition(nv, nh)) {
        romulan.ship.position = { v: nv, h: nh };
    }
}

// optional: call between attacks if you want the Romulan to “close distance”
export function romulanApproachTick(): void {
    const target = findClosestTargetInRange();
    if (!target) return;
    const tpos =
        target.kind === "ship" && target.player.ship
            ? target.player.ship.position
            : target.kind === "base"
                ? target.planet.position
                : null;
    if (tpos) moveToward(tpos);
}

// ----- “Romulan gets hit by …” (PHAROM/TOROM) -----
// id = distance in original (used in divisor)
export function applyRomulanPhaserHitFrom(
    phit: number,
    id: number
): { ihita: number; killed: boolean } {
    if (!romulan) return { ihita: 0, killed: false };

    // ihita = ((100 + iran(100)) * phit) / (10 * id)
    const denom = 10 * Math.max(1, id);
    const ihita = ((100 + iran(100)) * phit) / denom;

    // erom = erom - (ihita / 10)
    erom -= ihita / 10;

    if (erom <= 0) {
        destroyRomulan();
        return { ihita, killed: true };
    }
    return { ihita, killed: false };
}

export function applyRomulanTorpedoHitFrom(): { ihita: number; killed: boolean } {
    if (!romulan) return { ihita: 0, killed: false };

    // ihita = min(iran(4000), 2000)
    const ihita = Math.min(iran(4000), 2000);

    // erom = erom - (ihita / 10)
    erom -= ihita / 10;

    if (erom <= 0) {
        destroyRomulan();
        return { ihita, killed: true };
    }
    return { ihita, killed: false };
}

// ----- DEADRO parity -----
export function destroyRomulan(): void {
    if (!romulan?.ship) {
        romulan = null;
        return;
    }

    romulan.ship.romulanStatus.cloaked = true;

    const idx = players.indexOf(romulan);
    if (idx !== -1) players.splice(idx, 1);

    romulan = null;
    erom = 0;
    rppausUntil = 0;
    rtpausUntil = 0;
}

// ----- flavor (speech) -----
function romulanSpeaks(): void {
    if (!romulan?.ship) return;

    const rh = romulan.ship.position.h;
    const rv = romulan.ship.position.v;
    const recipients = players.filter(
        p => p !== romulan && p.ship && chebyshev(p.ship.position, { v: rv, h: rh }) <= KRANGE
    );

    const singleTarget = recipients.length === 1;
    const msg = generateRomulanMessage(singleTarget);

    for (const p of recipients) {
        addPendingMessage(p, `Romulan: ${msg}`);
    }
}

function generateRomulanMessage(single: boolean): string {
    const lead = single
        ? [
            "You have aroused my wrath, ",
            "You will witness my vengeance, ",
            "May you be attacked by a slime-devil, ",
            "I will reduce you to quarks, ",
        ]
        : ["Death to ", "Destruction to ", "I will crush ", "Prepare to die, "];

    const adjectives = ["mindless ", "worthless ", "ignorant ", "idiotic ", "stupid "];
    const species = ["sub-Romulan ", "human ", "klingon "];
    const objects = ["mutant", "cretin", "toad", "worm", "parasite"];

    const l = lead[Math.floor(Math.random() * lead.length)];
    const a = adjectives[Math.floor(Math.random() * adjectives.length)];
    const s = single ? "" : species[Math.floor(Math.random() * species.length)];
    const o = objects[Math.floor(Math.random() * objects.length)];

    return `${l}${a}${s}${o}${single ? "!" : "s!"}`;
}






// // Romulan AI Canonical Implementation (State Machine + Fortran Fidelity)

// import { Player } from './player.js';
// import { applyDamage } from './torpedo.js';
// import { NullSocket } from './util/nullsocket.js';
// import {
//     GRID_WIDTH,
//     GRID_HEIGHT,
//     settings,
//     MAX_SHIELD_ENERGY,
// } from './settings.js';
// import {
//     players,
//     bases,
//     stars,
//     planets,
//     pointsManager,
// } from './game.js';
// import { addPendingMessage, sendMessageToClient } from './communication.js';
// import { torpedoDamage } from './torpedo.js';
// import { bresenhamLine, chebyshev, findEmptyLocation, findObjectAtPosition } from './coords.js';
// import { Planet } from './planet.js';

// // parity helpers
// import { phadamCore, applyShipCriticalParity } from './phaser.js';
// // If you already export this from a central crit module, import from there instead
// const CRIT_CHANCE = 0.20;

// const TARGET_RANGE = 20;
// const ATTACK_CHANCE = 1 / 3;
// let romulanCounter = 0;
// export let romulan: Player | null = null;

// enum RomulanState {
//     IDLE,
//     SPEAK,
//     SEARCH,
//     MOVE,
//     DECLOAK,
//     PREATTACK,
//     ATTACK,
//     REPAIR,
//     END
// }

// let romulanState = RomulanState.IDLE;

// let romulanTarget: Target | null = null;

// type Target = Planet | Player;

// export function maybeSpawnRomulan(): void {
//     if (!settings.generated) return;
//     romulanCounter++;
//     const numPlayers = players.length;

//     if ((!romulan || !romulan.ship) && romulanCounter >= numPlayers * 3 && Math.floor(Math.random() * 5) === 4) {
//         spawnRomulan();
//         romulanCounter = 0;
//     }
// }

// export function spawnRomulan(): void {
//     if (romulan && romulan.ship) return;

//     pointsManager.incrementShipsCommissioned('ROMULAN');

//     romulan = new Player(new NullSocket());
//     romulan.settings.name = 'ROMULAN';
//     if (romulan.ship) {
//         romulan.ship.name = 'ROMULAN';
//         romulan.ship.side = 'ROMULAN';
//         romulan.ship.romulanStatus = { isRomulan: true, isRevealed: false, cloaked: true };
//         romulan.ship.energy = 5000;
//         romulan.ship.damage = 0;
//         romulan.ship.shieldEnergy = 0;

//         const position = findEmptyLocation();
//         if (position) {
//             romulan.ship.position = position;
//             players.push(romulan);
//         }
//     }
// }

// export function updateRomulan(): void {
//     if (!romulan || !romulan.ship) return;

//     switch (romulanState) {
//         case RomulanState.IDLE:
//             romulanState = RomulanState.SPEAK;
//             break;

//         case RomulanState.SPEAK:
//             if (Math.random() < 1 / 10) romulanSpeaks();
//             romulanState = RomulanState.SEARCH;
//             break;

//         case RomulanState.SEARCH:
//             romulanTarget = findClosestTarget();
//             if (romulanTarget) {
//                 romulanState = RomulanState.MOVE;
//             } else {
//                 relocateRomulan();
//                 romulanState = RomulanState.END;
//             }
//             break;

//         case RomulanState.MOVE: {
//             if (!romulanTarget) {
//                 romulanState = RomulanState.END;
//                 break;
//             }

//             const destination = romulanTarget instanceof Player
//                 ? romulanTarget.ship?.position
//                 : romulanTarget.position;

//             if (!destination) {
//                 romulanState = RomulanState.END;
//                 break;
//             }

//             if (romulan && romulan.ship && !isPathClear(romulan.ship.position, destination)) {
//                 romulanState = RomulanState.END;
//                 break;
//             }

//             romulan.ship.position = computeRomulanMovement(romulan.ship.position, destination);
//             romulanState = RomulanState.DECLOAK;
//             romulan.ship.romulanStatus.cloaked = false;
//             break;
//         }

//         case RomulanState.DECLOAK:
//             romulanState = RomulanState.PREATTACK;
//             break;

//         case RomulanState.PREATTACK:
//             romulanState = RomulanState.ATTACK;
//             break;

//         case RomulanState.ATTACK: {
//             if (!romulanTarget) {
//                 romulanState = RomulanState.END;
//                 break;
//             }

//             let targetPos = null;

//             if (romulanTarget instanceof Planet) {
//                 targetPos = romulanTarget.position;
//             } else if (romulanTarget instanceof Player && romulanTarget.ship) {
//                 targetPos = romulanTarget.ship.position;
//             }

//             if (!targetPos) {
//                 romulanState = RomulanState.END;
//                 break;
//             }

//             const override = maybeRetargetToAdjacentStar(romulanTarget);
//             if (override) targetPos = override;

//             if (chebyshev(romulan.ship.position, targetPos) > TARGET_RANGE || Math.random() >= ATTACK_CHANCE) {
//                 romulanState = RomulanState.REPAIR;
//                 break;
//             }

//             // 50/50 phaser vs torpedo
//             if (Math.random() < 0.5) {
//                 if (romulanTarget instanceof Player) {
//                     const targetPlayer = players.find(
//                         p => p.ship &&
//                             p.ship.position.h === targetPos.h &&
//                             p.ship.position.v === targetPos.v
//                     );
//                     if (targetPlayer && targetPlayer.ship) {
//                         sendMessageToClient(targetPlayer, "You are under Romulan phaser fire!");
//                         addPendingMessage(romulan, `Romulan ship ${romulan!.ship!.name} fires phasers at ${targetPlayer.ship.name} at ${targetPlayer.ship.position.v}-${targetPlayer.ship.position.h}!`);

//                         // PHADAM parity phaser attack
//                         romulanPhaserAttack(romulan!, targetPlayer);
//                     }
//                 } else {
//                     if (romulanTarget.side === 'FEDERATION' || romulanTarget.side === 'EMPIRE') {
//                         const baseTarget = findBaseAt(romulanTarget.position, romulanTarget.side);
//                         if (baseTarget) {
//                             addPendingMessage(romulan, `Romulan ship ${romulan!.ship!.name} fires phasers at ${baseTarget.side} base at ${baseTarget.position.v}-${baseTarget.position.h}!`);
//                             // PHADAM parity phaser attack against base
//                             romulanPhaserAttack(romulan!, baseTarget);
//                         }
//                     }
//                 }
//             } else {
//                 // Torpedo
//                 if (romulanTarget instanceof Player) {
//                     sendMessageToClient(romulanTarget, "A Romulan torpedo strikes!");
//                     torpedoDamage(romulan!, romulanTarget); // ✅ correct source/target order
//                 } else {
//                     if (romulanTarget.side === 'FEDERATION' || romulanTarget.side === 'EMPIRE') {
//                         const baseTarget = findBaseAt(romulanTarget!.position, romulanTarget.side);
//                         if (baseTarget) {
//                             torpedoDamage(romulan!, baseTarget);
//                         }
//                     }
//                 }
//             }

//             // Romulan survival check (kept as-is)
//             if (romulan.ship.energy <= 0 || romulan.ship.damage >= 10000) {
//                 destroyRomulan();
//                 return;
//             }

//             romulanState = RomulanState.REPAIR;
//             break;
//         }

//         case RomulanState.REPAIR:
//             romulan.ship.romulanStatus.cloaked = true;
//             romulanBaseRepair();
//             romulanState = RomulanState.IDLE;
//             break;

//         case RomulanState.END:
//             romulanTarget = null;
//             romulanState = RomulanState.IDLE;
//             break;
//     }
// }

// function findBaseAt(position: { v: number; h: number }, side: 'FEDERATION' | 'EMPIRE' | 'NEUTRAL') {
//     const arr = side === 'FEDERATION' ? bases.federation : bases.empire;
//     return arr.find(b => b.position.h === position.h && b.position.v === position.v);
// }

// function findClosestTarget(): Target | null {
//     if (!romulan || !romulan.ship) return null;
//     const romPos = romulan!.ship.position;
//     const candidates: Target[] = [];

//     // ships
//     for (const p of players) {
//         if (p.ship && p !== romulan && (p.ship.side === 'FEDERATION' || p.ship.side === 'EMPIRE')) {
//             const d = chebyshev(p.ship.position, romPos);
//             if (d <= TARGET_RANGE) candidates.push(p);
//         }
//     }

//     // bases — fixed: actually push the base
//     for (const side of ['FEDERATION', 'EMPIRE'] as const) {
//         const sideBases = side === 'FEDERATION' ? bases.federation : bases.empire;
//         for (const base of sideBases) {
//             const d = chebyshev(base.position, romPos);
//             if (d <= TARGET_RANGE) candidates.push(base);
//         }
//     }

//     let closest: Target[] = [];
//     let minDist = Infinity;

//     for (const t of candidates) {
//         const pos = t instanceof Player && t.ship ? t.ship.position : (t instanceof Planet ? t.position : undefined);
//         if (!pos) continue;
//         const dist = chebyshev(pos, romPos);
//         if (dist < minDist) {
//             closest = [t];
//             minDist = dist;
//         } else if (dist === minDist) {
//             closest.push(t);
//         }
//     }

//     return closest.length ? closest[Math.floor(Math.random() * closest.length)] : null;
// }

// function maybeRetargetToAdjacentStar(target: Target): { v: number; h: number } | null {
//     let pos = null;

//     if (target instanceof Player && target.ship) {
//         pos = target.ship.position;
//     } else if (target instanceof Planet) {
//         pos = target.position;
//     }
//     if (!pos) return null;

//     for (let dh = -1; dh <= 1; dh++) {
//         for (let dv = -1; dv <= 1; dv++) {
//             if (dh === 0 && dv === 0) continue;
//             const h = pos.h + dh;
//             const v = pos.v + dv;
//             if (stars.some(s => s.position.h === h && s.position.v === v)) return { v, h };
//         }
//     }
//     return null;
// }

// function isPathClear(from: { v: number; h: number }, to: { v: number; h: number }): boolean {
//     if (!romulan || !romulan.ship) return false;

//     const path = [...bresenhamLine(from.v, from.h, to.v, to.h)];
//     path.shift(); // skip start
//     path.pop();   // skip end

//     for (const { v, h } of path) {
//         if (
//             stars.some(obj => obj.position.h === h && obj.position.v === v) ||
//             planets.some(obj => obj.position.h === h && obj.position.v === v) ||
//             players.some(p => p.ship && p !== romulan && p.ship.position.h === h && p.ship.position.v === v)
//         ) return false;
//     }
//     return true;
// }

// export function destroyRomulan(): void { //TODO
//     if (!romulan || !romulan.ship) return;
//     romulan.ship.romulanStatus.cloaked = true;
//     const idx = players.indexOf(romulan);
//     if (idx !== -1) players.splice(idx, 1);
//     romulan = null;
// }

// export function romulanBaseRepair(): void {
//     if (!romulan || !romulan.ship) return;

//     const numPlayers = players.filter(p => p.ship!.side === 'FEDERATION' || p.ship!.side === 'EMPIRE').length;
//     const repairAmount = Math.floor(50 / (numPlayers + 1));

//     for (const side of ['FEDERATION', 'EMPIRE'] as const) {
//         const sideBases = side === 'FEDERATION' ? bases.federation : bases.empire;
//         for (const base of sideBases) {
//             if (base.energy > 0) {
//                 base.energy = Math.min(1000, base.energy + repairAmount);
//             }
//         }
//     }
// }

// function romulanSpeaks(): void {
//     if (!romulan || !romulan.ship) return;

//     const rh = romulan.ship.position.h;
//     const rv = romulan.ship.position.v;
//     const recipients = players.filter(p => p !== romulan && p.ship && chebyshev(p.ship.position, { v: rv, h: rh }) <= TARGET_RANGE);

//     const singleTarget = recipients.length === 1;
//     const msg = generateRomulanMessage(singleTarget);

//     for (const p of recipients) {
//         addPendingMessage(p, `Romulan: ${msg}`);
//     }
// }

// function generateRomulanMessage(single: boolean): string {
//     const lead = single
//         ? ["You have aroused my wrath, ", "You will witness my vengeance, ", "May you be attacked by a slime-devil, ", "I will reduce you to quarks, "]
//         : ["Death to ", "Destruction to ", "I will crush ", "Prepare to die, "];

//     const adjectives = ["mindless ", "worthless ", "ignorant ", "idiotic ", "stupid "];
//     const species = ["sub-Romulan ", "human ", "klingon "];
//     const objects = ["mutant", "cretin", "toad", "worm", "parasite"];

//     return `${lead[Math.floor(Math.random() * lead.length)]}${adjectives[Math.floor(Math.random() * adjectives.length)]}${single ? "" : species[Math.floor(Math.random() * species.length)]}${objects[Math.floor(Math.random() * objects.length)]}${single ? "!" : "s!"}`;
// }

// function relocateRomulan(): void {
//     for (let i = 0; i < 100; i++) {
//         const v = Math.floor(Math.random() * GRID_HEIGHT) + 1;
//         const h = Math.floor(Math.random() * GRID_WIDTH) + 1;
//         if (!findObjectAtPosition(v, h)) {
//             if (romulan && romulan.ship) {
//                 romulan!.ship.position = { v, h };
//             }
//         }
//     }
// }

// // === PHADAM parity phaser attack for Romulan ===
// function romulanPhaserAttack(attacker: Player, target: Player | Planet) {
//     if (!attacker.ship) return { hita: 0, isDestroyed: false };

//     const isShip = target instanceof Player && !!target.ship;
//     const isBase = target instanceof Planet && target.isBase;

//     const rawShieldEnergy = isShip ? (target as Player).ship!.shieldEnergy : (target as Planet).energy;
//     const rawShieldMax = isShip ? MAX_SHIELD_ENERGY : 1000;

//     const distance = chebyshev(
//         attacker.ship.position,
//         isShip ? (target as Player).ship!.position : (target as Planet).position
//     );

//     const shooterDamaged =
//         !!attacker.ship.devices?.phaser || !!attacker.ship.devices?.computer;

//     // Use standard phaser power (PHACON default 200); Romulan has no energy spend
//     const { hita, newShieldEnergy } = phadamCore({
//         targetIsBase: !!isBase,
//         rawShieldEnergy,
//         rawShieldMax,
//         distance,
//         shooterDamaged,
//         phit: 200,
//     });

//     // write back shield drain
//     if (isShip) (target as Player).ship!.shieldEnergy = newShieldEnergy;
//     else (target as Planet).energy = newShieldEnergy;

//     // ship device crit + jitter BEFORE hull
//     let finalHit = hita;
//     if (isShip && Math.random() < CRIT_CHANCE) {
//         const crit = applyShipCriticalParity(target as Player, hita);
//         finalHit = crit.hita;
//     }

//     // apply to hull using the shared resolver (keeps scoring consistent)
//     // import from torpedo.js where your applyDamage is defined
//     // NOTE: we import phadamCore & applyShipCriticalParity above; applyDamage is used indirectly by torpedo path.
//     // If applyDamage is exported from another module, adjust the import path accordingly.

//     return applyDamage(attacker, target, finalHit, Math.random());
// }

// // (Legacy helper kept for reference — no longer used)
// // function romulanPhaserDamage(distance: number, romulan: Player): number {
// //   let baseHit = Math.pow(0.9 + 0.02 * Math.random(), distance); // Fortran: pwr(0.9–0.92, id)
// //   if (romulan.ship && (romulan.ship.devices.phaser > 0 || romulan.ship.devices.computer > 0)) {
// //     baseHit *= 0.8; // Fortran: hit *= 0.8 if damaged
// //   }
// //   return baseHit;
// // }


// function computeRomulanMovement(
//     from: { v: number; h: number },
//     to: { v: number; h: number },
//     maxSteps = 4
// ): { v: number; h: number } {
//     // Chebyshev distance (max axis delta)
//     const dv = to.v - from.v;
//     const dh = to.h - from.h;

//     const dist = Math.max(Math.abs(dv), Math.abs(dh));
//     if (dist === 0) return from;

//     // never enter the target tile: stop 1 short if needed
//     const steps = Math.min(maxSteps, Math.max(0, dist - 1));

//     // move diagonally first, then along the dominant remaining axis
//     const sv = Math.sign(dv);
//     const sh = Math.sign(dh);

//     const diag = Math.min(steps, Math.min(Math.abs(dv), Math.abs(dh))); // diagonal steps
//     const rem = steps - diag;

//     const extraV = Math.min(rem, Math.max(0, Math.abs(dv) - diag));
//     const extraH = Math.min(rem, Math.max(0, Math.abs(dh) - diag));

//     let v = from.v + sv * (diag + extraV);
//     let h = from.h + sh * (diag + extraH);

//     // clamp to galaxy bounds
//     v = Math.max(1, Math.min(GRID_HEIGHT, v));
//     h = Math.max(1, Math.min(GRID_WIDTH, h));

//     return { v, h };
// }

######## scan.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
import {
    GRID_HEIGHT, GRID_WIDTH,
    SYMBOL_ROMULAN, SYMBOL_STAR, SYMBOL_BLACK_HOLE, SYMBOL_EMPTY,
    SYMBOL_WARNING, SYMBOL_BASE_FED, SYMBOL_BASE_EMP,
    SYMBOL_PLANET_NEU, SYMBOL_PLANET_FED, SYMBOL_PLANET_EMP, SYMBOL_PLANET_UNKNOWN,
    BASE_WARNING_DISTANCE, PLANET_WARNING_DISTANCE, BLACKHOLE_WARNING_DISTANCE,
    DEFAULT_SCAN_RANGE,
} from './settings.js';
import { addPlanetToMemory } from './memory.js';
import { Command } from './command.js';
import { Planet } from './planet.js';
import { planets, players, stars, blackholes } from './game.js';
import { matchesPattern } from './util/util.js';

export function scanCommand(player: Player, command: Command): void {
    scan(player, command, DEFAULT_SCAN_RANGE);
}

export function scan(player: Player, command: Command, range: number = DEFAULT_SCAN_RANGE): void {
    const args = command.args.map(arg => arg.toUpperCase());
    if (!player.ship) return;

    const { v, h } = player.ship.position;

    // ────── Parse arguments ──────
    let vDir = 0, hDir = 0;
    let vertical = range;
    let horizontal = range;
    let cornerMode = false;

    const nums = args.map(Number).filter(n => !isNaN(n));
    if (nums.length === 1) {
        vertical = horizontal = Math.min(nums[0], range);
    } else if (nums.length >= 2) {
        vertical = Math.min(nums[0], range);
        horizontal = Math.min(nums[1], range);
    }

    for (const arg of args) {
        if (!isNaN(Number(arg))) continue;
        if (matchesPattern(arg, "Up")) vDir = 1;  //matchesPattern
        else if (matchesPattern(arg, "Down")) vDir = -1;
        else if (matchesPattern(arg, "Right")) hDir = 1;
        else if (matchesPattern(arg, "Left")) hDir = -1;
        else if (matchesPattern(arg, "Center")) cornerMode = true;
    }

    const warningFlag = args.some(arg => matchesPattern(arg, "Warning"));
    const warningSectors = warningFlag ? getWarningSectors(player) : new Set<string>();

    // ────── Compute scan bounds ──────
    let vMin: number, vMax: number, hMin: number, hMax: number;

    if (cornerMode && nums.length >= 2) {
        const dv = Math.max(-range, Math.min(range, nums[0]));
        const dh = Math.max(-range, Math.min(range, nums[1]));

        vMin = Math.min(v, v + dv);
        vMax = Math.max(v, v + dv);
        hMin = Math.min(h, h + dh);
        hMax = Math.max(h, h + dh);
    } else {
        if (hDir < 0) {
            hMin = h - horizontal;
            hMax = h;
        } else if (hDir > 0) {
            hMin = h;
            hMax = h + horizontal;
        } else {
            hMin = h - horizontal;
            hMax = h + horizontal;
        }

        if (vDir < 0) {
            vMin = v - vertical;
            vMax = v;
        } else if (vDir > 0) {
            vMin = v;
            vMax = v + vertical;
        } else {
            vMin = v - vertical;
            vMax = v + vertical;
        }
    }

    hMin = Math.max(1, hMin);
    hMax = Math.min(GRID_WIDTH, hMax);
    vMin = Math.max(1, vMin);
    vMax = Math.min(GRID_HEIGHT, vMax);

    // ────── Build spatial maps for fast lookup ──────
    const coordKey = (v: number, h: number) => `${v},${h}`;

    const shipMap = new Map<string, Player>();
    for (const p of players) {
        if (p.ship) {
            shipMap.set(coordKey(p.ship.position.v, p.ship.position.h), p);
        }
    }

    const planetMap = new Map<string, Planet>();
    for (const planet of planets) {
        planetMap.set(coordKey(planet.position.v, planet.position.h), planet);
        addPlanetToMemory(player, planet);
    }

    const blackholeSet = new Set<string>(blackholes.map(bh => coordKey(bh.position.v, bh.position.h)));
    const starSet = new Set<string>(stars.map(s => coordKey(s.position.v, s.position.h)));

    // ────── Header ──────
    const header = [];
    for (let col = hMin; col <= hMax; col += 2) {
        header.push(String(col).padStart(2, " "));
    }
    sendMessageToClient(player, `   ${header.join("  ")}`);

    // ────── Grid ──────
    for (let rowV = vMax; rowV >= vMin; rowV--) {
        let line = `${String(rowV).padStart(2, " ")} `;

        for (let colH = hMin; colH <= hMax; colH++) {
            const key = coordKey(rowV, colH);
            let symbol = SYMBOL_EMPTY;

            const player = shipMap.get(key);
            const planet = planetMap.get(key);

            if (player) {    // why?  && !ship.ship.romulanStatus.cloaked) {
                if (player.ship && player.ship.name) {
                    if (player.ship.romulanStatus.isRomulan && !player.ship.romulanStatus.cloaked) {
                        symbol = SYMBOL_ROMULAN;
                    } else {
                        symbol = player.ship.name[0]
                    }
                } else {
                    symbol = `?`
                }
            } else if (planet) {
                if (planet.isBase) {
                    symbol = planet.side === "FEDERATION" ? SYMBOL_BASE_FED : SYMBOL_BASE_EMP;
                } else {
                    const side = planet.side;
                    symbol = side === "NEUTRAL" ? SYMBOL_PLANET_NEU :
                        side === "FEDERATION" ? SYMBOL_PLANET_FED :
                            side === "EMPIRE" ? SYMBOL_PLANET_EMP :
                                SYMBOL_PLANET_UNKNOWN;
                }
            } else if (starSet.has(key)) {
                symbol = SYMBOL_STAR;
            } else if (blackholeSet.has(key)) {
                symbol = SYMBOL_BLACK_HOLE;
            } else if (warningSectors.has(key)) {
                symbol = SYMBOL_WARNING;
            }

            if (symbol.length === 1) symbol = ` ${symbol}`;
            line += symbol;
        }

        line += ` ${String(rowV).padStart(2, " ")}`;
        sendMessageToClient(player, line);
    }

    // ────── Footer ──────
    sendMessageToClient(player, `   ${header.join("  ")}`);
}


// Identify sectors that should show warnings
function getWarningSectors(player: Player): Set<string> {
    const warningSet = new Set<string>();
    if (!player.ship) return warningSet;

    const side = player.ship.side;  // SHOULDN'T HAPPEN

    let warningDistance = PLANET_WARNING_DISTANCE;
    for (const planet of planets) {
        if (planet.isBase) {
            warningDistance = BASE_WARNING_DISTANCE;
        } else {
            warningDistance = PLANET_WARNING_DISTANCE;
        }
        if (planet.side !== side || planet.side === "NEUTRAL") {   // neutral is via Harris info
            for (let dh = -warningDistance; dh <= warningDistance; dh++) {
                for (let dv = -warningDistance; dv <= warningDistance; dv++) {
                    if (dh === 0 && dv === 0) continue;
                    warningSet.add(`${planet.position.v + dv},${planet.position.h + dh}`);
                }
            }
        }
    }

    for (const obj of [...blackholes]) {  // , ...stars
        for (let dh = -BLACKHOLE_WARNING_DISTANCE; dh <= BLACKHOLE_WARNING_DISTANCE; dh++) {
            for (let dv = -BLACKHOLE_WARNING_DISTANCE; dv <= BLACKHOLE_WARNING_DISTANCE; dv++) {
                if (dh === 0 && dv === 0) continue;
                warningSet.add(`${obj.position.v + dv},${obj.position.h + dh}`);
            }
        }
    }

    return warningSet;
}

######## server.ts
// server.ts (excerpt) — run your telnet server as usual, then:
import { startApiServer } from "./api/server.js";
import type { GameStateProvider } from "./api/provider.js";

import { planets, stars, blackholes, bases, players } from "./game.js";
import {
  toSummaryDTO,
  toPlayerDTO,
  toPlanetDTO,
  toStarDTO,
  toBlackholeDTO,
  toBaseDTO,
} from "./api/dto.js";
import type { Ship } from "./ship.js";

// Build the read-only provider against your live state
const provider: GameStateProvider = {
  getSummary: () =>
    toSummaryDTO({
      players,
      planets,
      stars,
      blackholes,
      federationBases: bases.federation,
      empireBases: bases.empire,
    }),

  listPlayers: () =>
    players
      .filter((p): p is Player & { ship: Ship } => Boolean(p.ship))
      .map(toPlayerDTO),

  listPlanets: () => planets.map(toPlanetDTO),
  listStars: () => stars.map(toStarDTO),
  listBlackholes: () => blackholes.map(toBlackholeDTO),
  listBases: () => [...bases.federation, ...bases.empire].map(toBaseDTO),
};

// Start the API if desired (env or explicit)
if (process.env.API_PORT) {
  startApiServer(provider);
}



import * as net from 'net';
import { config } from 'dotenv';
import { Player } from './player.js';
import { limbo } from './game.js';
import { queueCommands } from './command.js';
import { MAX_PLAYERS } from './settings.js';
import { swapPlayerForBackhole } from './gripe.js';
import { parseAndExecutePGCommand } from './pregame.js';
import { removePlayerFromGame } from './game.js';

config();

const IAC = 255;
//const IP = 244;
const SE = 240;
const DO = 253;
const DONT = 254;
const WILL = 251;
const WONT = 252;
const SB = 250;

const ECHO = 1;
const SUPPRESS_GO_AHEAD = 3;
const LINEMODE = 34;

export const clients: Map<net.Socket, Player> = new Map();

const server = net.createServer((socket) => {
  if (players.length >= MAX_PLAYERS) {
    socket.write("Server is full.\r\n");
    socket.end();
    return;
  }

  const player = new Player(socket);
  clients.set(socket, player);
  //players.push(player);

  // Negotiate raw mode: suppress line mode and client-side echo
  socket.write(Buffer.from([IAC, WILL, SUPPRESS_GO_AHEAD]));
  socket.write(Buffer.from([IAC, WILL, ECHO]));
  socket.write(Buffer.from([IAC, WONT, LINEMODE]));

  // Welcome and initial SUM command
  //socket.write(`[DECWARJS Version ${gameSettings.version}, ${gameSettings.date}]\r\n`);
  socket.write(`Now entering DECWARJS Pre-game; type\r\nACtivate to enter game.\r\n`);
  socket.write(player.getPrompt());
  //socket.write('\r\n' + player.getPrompt() + ' ');
  //parseAndExecuteCommand(player, 'SUM');

  let skipLF = false;

  socket.on('data', (chunk: Buffer) => {
    for (let i = 0; i < chunk.length; i++) {
      const byte = chunk[i];

      // Telnet IAC sequences — silently skip
      if (byte === IAC) {
        const command = chunk[i + 1];

        if (command === IAC) {
          // Literal 255
          i++; // skip extra 255
          continue;
        }

        if (
          command === DO || command === DONT ||
          command === WILL || command === WONT
        ) {
          // IAC DO/WILL/WONT/DONT option
          i += 2; // skip IAC, command, and option
          continue;
        }

        if (command === SB) {
          // IAC SB ... IAC SE
          i += 2; // skip IAC and SB and option
          // Skip until IAC SE
          while (i < chunk.length) {
            if (chunk[i] === IAC && chunk[i + 1] === SE) {
              i += 2;
              break;
            }
            i++;
          }
          continue;
        }

        // All other IAC commands (like IP, NOP, SE, etc.)
        i += 1; // skip IAC and command
        continue;
      }

      // Ctrl-C (ASCII 3)
      if (byte === 3) {
        handleControlC(player, socket);
        continue;
      }

      // Ctrl-U (ASCII 21) — clear entire input line
      if (byte === 21) {
        if (!player.ready) continue;
        const erase = '\b \b'.repeat(player.inputBuffer.length);
        socket.write(erase);
        player.inputBuffer = '';
        continue;
      }

      // Backspace/Delete (ASCII 8 or 127)
      if (byte === 8 || byte === 127) {
        if (player.inputBuffer.length > 0) {
          player.inputBuffer = player.inputBuffer.slice(0, -1);
          socket.write('\b \b');
        }
        continue;
      }

      // ESC key (ASCII 27) — recall next command from history
      if (byte === 27 && (chunk[i + 1] === undefined || chunk[i + 1] < 32)) {
        if (!player.ready) continue;
        const erase = '\b \b'.repeat(player.inputBuffer.length);
        socket.write(erase);
        const command = player.getNextHistory() || '';
        player.inputBuffer = command;
        socket.write(command);
        continue;
      }

      // Enter (CR or LF)
      if ((byte === 13 || (byte === 10 && !skipLF)) && !player.multiLine || (player.multiLine && byte === 0x1A)) {
        if (player.inputBuffer === '') {    // handle empty line by user
          socket.write('\r\n\r\n' + player.getPrompt());
          continue;
        }
        player.lastActivity = Date.now();
        if (byte === 13) skipLF = true;
        const line = player.inputBuffer.trim();
        player.inputBuffer = '';
        socket.write('\r\n\r\n');

        if (player.isOnHold) {
          socket.write(player.getPrompt());
          continue;
        }

        if (player.currentPrompt) {
          const cb = player.callBack;
          player.callBack = undefined;
          player.currentPrompt = undefined;
          cb?.(player, line);
        } else if (line) {
          if (players.includes(player)) { // why?
            player.addToHistory(line);
            queueCommands(player, line);
            //parseAndExecuteCommand(player, line);
          } else {
            parseAndExecutePGCommand(player, line);
          }
        }
        continue;
      }

      if (player.multiLine && (byte === 13 || byte === 10)) {
        player.inputBuffer += '\n';
        socket.write('\r\n');
        continue;
      }

      // Skip LF if part of CRLF
      if (byte === 10 && skipLF) {
        skipLF = false;
        continue;
      }

      // Printable characters (ASCII 32–126)
      if (byte >= 32 && byte <= 126) {
        if (!player.ready) {
          player.ready = true;
          //socket.write('\r\n' + player.getPrompt() + ' ');
        }

        const char = String.fromCharCode(byte);
        player.inputBuffer += char;
        socket.write(char);
      }
    }
  });


  socket.on('close', () => {
    clients.delete(socket);
  });

  socket.on('error', (err) => {
    console.error('Socket error:', err.message);
    clients.delete(socket);
  });
});

function handleControlC(player: Player, socket: net.Socket): void {
  let atCommandPrompt: boolean = true;

  if (player.multiLine) {
    socket.write(`^C Use ^Z to end.\r\n`);
    return;
  }

  if (player.currentCommandTimer || player.commandQueue.length > 0) {
    atCommandPrompt = false;
  }


  player.inputBuffer = "";

  // 2. Cancel the current timer if any
  if (player.currentCommandTimer) {
    clearTimeout(player.currentCommandTimer);
    player.currentCommandTimer = null;
  }

  // 3. Clear the queued commands
  player.commandQueue = [];

  // 4. Reset processing flag (in case a command never called `done`)
  player.processingCommand = false;
  player.multiLine = false;
  player.currentPrompt = undefined;
  player.isOnHold = false;


  if (limbo.includes(player)) {
    swapPlayerForBackhole(player);
  }

  // 5. Notify user + reprint prompt
  if (atCommandPrompt) {
    if (player.ship && player.ship.condition == "RED") {
      socket.write("Use QUIT to terminate while under RED alert.\r\n");
      socket.write(`${player.getPrompt()} `);
    } else {
      removePlayerFromGame(player);
      socket.write(`^C\r\n${player.getPrompt()} `);
    }
  } else {
    if (player.ready) {
      socket.write('\r\x1b[K'); // Clear line
      socket.write('\x07\x07\x07\x07'); // Optional bells
      socket.write('Commands cancelled.\r\n');
      socket.write(`${player.getPrompt()} `);
    }
  }
}

const PORT = 23;
server.listen(PORT, () => console.log(`Telnet server running on port ${PORT}`));


// function isSocketActive(socket: net.Socket): boolean {
//     return !socket.destroyed && socket.writable;
// }

// Optional: try a no-op write to check silently
export function isSocketLive(socket: net.Socket): boolean {
  return (!socket.destroyed && socket.writable && socket.readable);
}
######## set.ts
import { ScanSetting, PromptSetting, ICDEF, OCDEF, OutputSetting } from './settings.js';
import { Player } from './player.js';
import { Command } from './command.js';
import { sendMessageToClient } from './communication.js';
//import { setPlayerSettings } from './db/userRecords.js';

// helper to match a user’s prefix against allowed options
function matchValue(input: string, options: readonly string[]): string | null {
    const upperInput = input.toUpperCase();
    const candidates = options.filter(opt => opt.startsWith(upperInput));
    return candidates.length === 1 ? candidates[0] : null;
}

export function setCommand(player: Player, command: Command): void {
    if (command.args.length < 2) {
        sendMessageToClient(player, "Usage: SET <setting> <value>");
        return;
    }

    // Allow unambiguous prefixes for setting names
    const settingArg = command.args[0];
    const selectedSetting = matchValue(settingArg, [
        "SCAN", "PROMPT", "OCDEF", "ICDEF", "NAME", "OUTPUT"
    ]);
    if (!selectedSetting) {
        sendMessageToClient(player, `Unknown setting: ${settingArg}`);
        return;
    }

    // Value argument
    const valueArg = command.args[1];
    const valueUpper = valueArg.toUpperCase();

    switch (selectedSetting) {
        case "SCAN": {
            const chosenScan = matchValue(valueUpper, ["LONG", "SHORT"]);
            if (chosenScan) {
                player.settings.scan = chosenScan as ScanSetting;
                sendMessageToClient(player, `SCAN set to ${chosenScan}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid SCAN value: ${valueArg}. Valid: Long, Short.`
                );
            }
            break;
        }

        case "PROMPT": {
            const chosenPrompt = matchValue(valueUpper, ["NORMAL", "INFORMATIVE"]);
            if (chosenPrompt) {
                player.settings.prompt = chosenPrompt as PromptSetting;
                sendMessageToClient(player, `PROMPT set to ${chosenPrompt}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid PROMPT value: ${valueArg}. Valid: Normal, Informative.`
                );
            }
            break;
        }

        case "OCDEF": {
            const chosenOC = matchValue(valueUpper, ["ABSOLUTE", "RELATIVE", "BOTH"]);
            if (chosenOC) {
                player.settings.ocdef = chosenOC as OCDEF;
                sendMessageToClient(
                    player,
                    `OCDEF set to ${chosenOC}.`
                );
            } else {
                sendMessageToClient(
                    player,
                    `Invalid OCDEF value: ${valueArg}. Valid: Absolute, Relative, Both).`
                );
            }
            break;
        }

        case "ICDEF": {
            const chosenIC = matchValue(valueUpper, ["ABSOLUTE", "RELATIVE"]);
            if (chosenIC) {
                player.settings.icdef = chosenIC as ICDEF;
                sendMessageToClient(
                    player,
                    `ICDEF set to ${chosenIC}.`
                );
            } else {
                sendMessageToClient(
                    player,
                    `Invalid ICDEF value: ${valueArg}. Valid: Absolute, Relative.`
                );
            }
            break;
        }

        case "NAME": {
            const newName = command.args.slice(1).join(" ");
            player.settings.name = newName;
            sendMessageToClient(
                player,
                `NAME set to ${newName}.`
            );
            break;
        }

        case "OUTPUT": {
            const chosenOutput = matchValue(valueUpper, ["LONG", "MEDIUM", "SHORT"]);
            if (chosenOutput) {
                player.settings.output = chosenOutput as OutputSetting;
                sendMessageToClient(player, `OUTPUT set to ${chosenOutput}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid OUTPUT value: ${valueArg}. Valid: Long, Medium, Short.`
                );
            }
            break;
        }

        default:
            // Shouldn't be reached
            sendMessageToClient(player, `Unknown setting: ${selectedSetting}`);
    }
    //setPlayerSettings(player); // TODO: implement
}

######## settings.ts
import { VERSION } from "./version.js";

export const GRID_WIDTH = 75;
export const GRID_HEIGHT = 75;
export const MAX_PLAYERS = 18;
export const NUMBER_OF_PLANETS = 60;
export const MAX_NUMBER_OF_PLAYERS = 18;
export const DEFAULT_BASE_ENERGY = 1000;
export const MAX_BUILDS_PER_PLANET = 5;
export const MAX_SHIP_ENERGY = 5000;
export const MAX_SHIELD_ENERGY = 2500;
export const MAX_TORPEDOES = 10;
export const BASE_WARNING_DISTANCE = 4;
export const PLANET_WARNING_DISTANCE = 2;
export const BLACKHOLE_WARNING_DISTANCE = 1;
export const DEFAULT_SCAN_RANGE = 10;
export const DEFAULT_SRS_RANGE = 7;
export const INITIAL_BASE_STRENGTH = 1000;
export const CAPTURE_DELAY_MIN_MS = 5000;
export const WARP_DELAY_MIN_MS = 2000;
export const WARP_DELAY_RANGE = 2000;
export const DOCK_DELAY_RANGE = 2000;
export const DOCK_DELAY_MIN_MS = 2000;
export const BUILD_DELAY_MIN_MS = 2000;
export const BUILD_DELAY_RANGE = 2000;
export const MAX_BASES_PER_TEAM = 10;
export const ENERGY_REPAIR_COST = 500;
export const SHIELD_REPAIR_COST = 300;
export const SHIELD_REPAIR_AMOUNT = 500;
export const ENERGY_REPAIR_AMOUNT = 1000;
export const DESTRUCTION_DAMAGE_THRESHOLD = 2500;
export const PHASER_COOLDOWN = 1000;
export const IMPULSE_DELAY_MS = 2000;
export const IMPULSE_DELAY_RANGE = 2000;
export const MAX_TORPEDO_RANGE = 10;
export const STARBASE_PHASER_RANGE = 4;
export const INACTIVITY_TIMEOUT = 60 * 1000 * 24 * 365;


export type ScanSetting = "LONG" | "SHORT";
export type PromptSetting = "NORMAL" | "INFORMATIVE";
export type CoordMode = "ABSOLUTE" | "RELATIVE" | "COMPUTED";
export type ICDEF = "ABSOLUTE" | "RELATIVE";
export type OCDEF = "ABSOLUTE" | "RELATIVE" | "BOTH";
export type Condition = "RED" | "YELLOW" | "GREEN";
export type OutputSetting = "SHORT" | "MEDIUM" | "LONG";

export const SYMBOL_ROMULAN = "R";
export const SYMBOL_STAR = "*";
export const SYMBOL_BLACK_HOLE = " ";
export const SYMBOL_EMPTY = ".";
export const SYMBOL_WARNING = "!";
export const SYMBOL_BASE_FED = "<>";
export const SYMBOL_BASE_EMP = ")(";
export const SYMBOL_PLANET_NEU = "@";
export const SYMBOL_PLANET_FED = "@F";
export const SYMBOL_PLANET_EMP = "@E";
export const SYMBOL_PLANET_UNKNOWN = "@?";


export type Side = "NEUTRAL" | "FEDERATION" | "EMPIRE" | "ROMULAN";

export const FEDERATION_SHIPS: string[] = [
    "EXCALIBUR"
    , "FARRAGUT", "INTREPID", "LEXINGTON", "NIMITZ",
    "SAVANNAH", "TRENTON", "VULCAN", "YORKTOWN"
];

export const EMPIRE_SHIPS: string[] = [
    "BUZZARD",
    "COBRA", "DEMON", "GOBLIN", "HAWK",
    "JACKAL", "MANTA", "PANTHER", "WOLF"
];

export const SHIPNAMES: string[] = [...FEDERATION_SHIPS, ...EMPIRE_SHIPS];

export const settings = {
    stardate: 0,
    generated: false,
    winner: null as string | null,
    version: "0.3" + VERSION,
    date: "2025-06-08",
    allowRomulans: true,
    allowBlackHoles: true,
    outputDetail: "FULL",
    promptStyle: "DEFAULT",
    sensorScanDetail: "DEFAULT",
    coordInputDefault: "DEFAULT",
    coordOutputDefault: "DEFAULT",
    ttyType: "DEFAULT",
    allowGripe: true,
    gameNumber: 1,
    timeConsumingMoves: 0,
    tournamentSeed: "0",
    blackholes: false,
    romulans: false,
    teamTurns: {
        federation: 0,
        empire: 0,
        romulan: 0
    },
    dotime: 0
};
######## shield.ts
import { Command } from "./command.js";
import { Player } from "./player.js";
import { sendMessageToClient } from "./communication.js";
import { matchesPattern } from "./util/util.js";

export function shieldCommand(player: Player, command: Command): void {
    const action = command.args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use SHIELD.");
        return;
    }

    if (!player.ship.isDeviceOperational("shield")) return;

    if (!action) {
        sendMessageToClient(player, "Usage: SHIELD [UP|DOWN|TRANSFER amount]");
        return;
    }

    if (matchesPattern(action, "Up")) {
        console.log("Raising shields");
        player.ship?.raiseShields();
    } else if (matchesPattern(action, "Down")) {
        console.log("Lowering shields");
        player.ship?.lowerShields();
    } else if (matchesPattern(action, "Transfer")) {
        const energyAmount = command.args[1];

        if (!energyAmount || !/^-?\d+$/.test(energyAmount)) {
            sendMessageToClient(player, "Bad energy amount.");
            return;
        }

        const amount = parseInt(energyAmount, 10);
        if (amount > 0) {
            player.ship?.transferToShields(amount);
        } else {
            player.ship?.transferFromShields(-amount);
        }
    } else {
        sendMessageToClient(player, "Unknown SHIELD command. Try UP, DOWN, or TRANSFER.");
    }
}


######## ship.ts
import { addPendingMessage, sendMessageToClient, sendOutputMessage } from './communication.js';
import { isInBounds, Position, findEmptyLocation, chebyshev, findObjectAtPosition, ocdefCoords, isAdjacent } from './coords.js';
import { SHIPNAMES, Condition, MAX_TORPEDOES, MAX_SHIP_ENERGY, MAX_SHIELD_ENERGY } from './settings.js';
import { Player } from './player.js';
import { players, planets } from './game.js';
import { Planet } from './planet.js';
import { bases } from './game.js';
import { Side } from './settings.js';


type DockableTarget = { position: { v: number; h: number } }; // minimal shape

function hasDockTarget(s: Ship): s is Ship & { dockTarget?: DockableTarget | null } {
    // This keeps it structural: only cares that the property exists
    return "dockTarget" in (s as object);
}



type Cooldowns = {
    phasersAvailableAt: [number, number]; // [bank1, bank2]
};

export type DeviceName =
    | "warp"
    | "impulse"
    | "torpedo"
    | "phaser"
    | "shield"
    | "computer"
    | "radio"
    | "tractor"
    | "lifeSupport";

export interface DeviceStatus {
    [deviceName: string]: number; // damage value
}

export class Ship {
    public player: Player;
    public position: Position;
    public energy: number;
    public shieldsUp: boolean;
    public shieldEnergy: number;
    public name: string;
    public isDestroyed: boolean;
    public side: Side;
    public docked: boolean;
    public tractorPartner: Ship | null;
    public romulanStatus: {
        isRomulan: boolean;
        isRevealed: boolean;
        cloaked: boolean;
    };
    public torpedoes: number;
    public devices: {
        warp: number;
        impulse: number;
        torpedo: number;
        phaser: number;
        shield: number;
        computer: number;
        radio: number;
        tractor: number;
        lifeSupport: number;
    }
    lifeSupportFailureTimer: number | null = null;
    public condition: Condition;
    public damage: number;
    public cooldowns: Cooldowns;

    constructor(player: Player) {
        this.player = player;
        this.position = findEmptyLocation() || { v: 1, h: 1 };
        this.energy = MAX_SHIP_ENERGY;
        this.shieldsUp = true;
        this.shieldEnergy = MAX_SHIELD_ENERGY;
        this.docked = false;
        this.name = "Unknown";
        this.isDestroyed = false;
        this.side = "NEUTRAL";
        this.tractorPartner = null;
        this.romulanStatus = {
            isRomulan: false,
            isRevealed: false,
            cloaked: false
        };
        this.torpedoes = MAX_TORPEDOES;
        this.devices = {
            warp: 0,
            impulse: 0,
            torpedo: 0,
            phaser: 0,
            shield: 0,
            computer: 0,
            radio: 0,
            tractor: 0,
            lifeSupport: 0
        };
        this.lifeSupportFailureTimer = null;
        this.condition = "GREEN";
        this.damage = 0;
        this.cooldowns = { phasersAvailableAt: [0, 0] };
    }

    raiseShields(): void {   // TODO factor in shield device damange?
        if (!this.shieldsUp && this.energy >= 100) {
            this.energy -= 100;
            this.shieldsUp = true;
            if (this.tractorPartner) {
                if (this.tractorPartner.tractorPartner) {
                    this.tractorPartner.tractorPartner = null;
                    addPendingMessage(this.tractorPartner.player, `Tractor beam was broken, ${this.name} raised shields.`);
                }
                this.tractorPartner = null;
                sendMessageToClient(this.player, `Tractor beam broken, Captain.`);
            }
            sendOutputMessage(this.player, {
                SHORT: "SH > UP",
                MEDIUM: "Shields raised.",
                LONG: "Defensive shields have been raised. Energy expenditure: 100 units."
            });

            sendOutputMessage(this.player, {
                SHORT: `SH > ${this.computeShieldStrength()}`,
                MEDIUM: `Shield strength: ${this.computeShieldStrength()}`,
                LONG: `Current shield strength is ${this.computeShieldStrength()}`
            });

        } else if (this.shieldsUp) {
            sendOutputMessage(this.player, {
                SHORT: "SH > UP ALRDY",
                MEDIUM: "Shields are already up.",
                LONG: "Shields are already raised; no action taken."
            });

        } else {
            sendOutputMessage(this.player, {
                SHORT: "SH > NO E",
                MEDIUM: "Insufficient energy to raise shields.",
                LONG: "Unable to raise shields due to inadequate ship energy reserves."
            });

        }
    }

    lowerShields(): void {
        if (this.shieldsUp) {
            this.shieldsUp = false;

            sendOutputMessage(this.player, {
                SHORT: "SH > DN",
                MEDIUM: "Shields lowered.",
                LONG: "Defensive shields have been lowered."
            });

            sendOutputMessage(this.player, {
                SHORT: `SH > ${this.computeShieldStrength()}`,
                MEDIUM: `Shield strength: ${this.computeShieldStrength()}`,
                LONG: `Current shield strength is ${this.computeShieldStrength()}`
            });

        } else {
            sendOutputMessage(this.player, {
                SHORT: "SH > DN ALRDY",
                MEDIUM: "Shields are already down.",
                LONG: "Shields are already lowered; no action taken."
            });
        }
    }

    transferToShields(amount: number): number {
        const maxShieldEnergy = MAX_SHIELD_ENERGY;
        const availableShipEnergy = Math.max(0, this.energy);
        const shieldRoom = Math.max(0, maxShieldEnergy - this.shieldEnergy);
        const requestedAmount = Math.max(0, amount);

        const transferable = Math.min(requestedAmount, availableShipEnergy, shieldRoom);

        if (transferable <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > MAX",
                MEDIUM: "Shields full or insufficient energy.",
                LONG: "Shield energy is already at maximum or ship lacks energy for transfer."
            });
            return 0;
        }

        this.shieldEnergy += transferable;
        this.energy -= transferable;

        sendOutputMessage(this.player, {
            SHORT: `+SH ${transferable}`,
            MEDIUM: `Transferred ${transferable} to shields.`,
            LONG: `Transferred ${transferable} units of energy from ship to shields.`
        });

        sendOutputMessage(this.player, {
            SHORT: `EN ${this.energy}`,
            MEDIUM: `Ship energy: ${this.energy}`,
            LONG: `Remaining ship energy: ${this.energy}`
        });

        sendOutputMessage(this.player, {
            SHORT: `SH ${this.shieldEnergy}`,
            MEDIUM: `Shield energy: ${this.shieldEnergy}`,
            LONG: `Current shield reserve: ${this.shieldEnergy}`
        });

        return transferable;
    }

    transferFromShields(amount: number): number {
        const maxShipEnergy = MAX_SHIP_ENERGY;
        const shipEnergy = this.energy;
        const roomInShip = maxShipEnergy - shipEnergy;

        if (isNaN(amount) || amount <= 0) {
            sendOutputMessage(this.player, {
                SHORT: `SH > BAD AMT`,
                MEDIUM: `Invalid amount: ${amount}`,
                LONG: `Invalid energy transfer amount: ${amount}. Operation cancelled.`
            });

            return 0;
        }

        if (roomInShip <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > SHIP FULL",
                MEDIUM: "Ship already at full energy.",
                LONG: "Cannot transfer from shields — ship's energy storage is already full."
            });
            return 0;
        }

        const transferable = Math.min(amount, this.shieldEnergy, roomInShip);

        if (transferable <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > NO SH",
                MEDIUM: "Not enough energy in shields.",
                LONG: "Insufficient shield energy available for transfer."
            });

            return 0;
        }

        this.shieldEnergy -= transferable;
        this.energy += transferable;

        sendOutputMessage(this.player, {
            SHORT: `-SH ${transferable}`,
            MEDIUM: `Transferred ${transferable} from shields.`,
            LONG: `Transferred ${transferable} units of energy from shields to ship.`
        });
        return transferable;
    }

    computeShieldStrength(): string {
        const percentage = (this.shieldEnergy / MAX_SHIELD_ENERGY) * 100;    //TODO SHIELD AND LEVEL?  is this correct?
        const strength = Math.max(0, Math.floor(percentage));
        return strength === 100
            ? `${strength}%`
            : `${this.shieldsUp ? '+' : '-'}${strength}%`;
    }

    computeShieldPercent(): number {
        const percent = (this.shieldEnergy / MAX_SHIELD_ENERGY) * 100;
        return this.shieldsUp ? Math.round(percent) : -Math.round(percent);
    }

    isDeviceOperational(device: keyof typeof this.devices): boolean {
        function isDeviceInoperative(ship: Ship, device: keyof typeof ship.devices): boolean {
            return ship.devices[device] >= 300;
        }

        function deviceMayFail(ship: Ship, device: keyof typeof ship.devices): boolean {
            const dmg = ship.devices[device];
            return dmg >= 300 || (dmg >= 100 && Math.random() < 0.25);
        }

        function deviceMalfunctionMessage(device: string): string {
            const messages: Record<string, string> = {
                warp: "ERROR: Warp drive malfunction.",
                impulse: "ERROR: Impulse engines not responding.",
                torpedo: "ERROR: Torpedo system inoperative.",
                phaser: "ERROR: Phaser banks offline.",
                shield: "ERROR: Shield generator offline.",
                computer: "ERROR: Computer too damaged to compute coordinates.",
                lifeSupport: "WARNING: Life support system failing.",
                radio: "ERROR: Radio system inoperative.",
                tractor: "Tractor beam not in operation at this time, sir.",
            };
            return messages[device] ?? `ERROR: ${device} system failure.`;
        }

        if (isDeviceInoperative(this, device)) {
            sendMessageToClient(this.player, deviceMalfunctionMessage(device));
            return false;
        }
        if (deviceMayFail(this, device)) {
            sendMessageToClient(this.player, deviceMalfunctionMessage(device));
            return false;
        }
        return true;
    }


    computeCondition(): Condition {
        // 1. RED if any enemy ship within 10-man distance
        for (const other of players) {
            if (other === this.player || !other.ship) continue;
            if (other.ship.side === this.side) continue;

            // if (chebyshev(this.position, other.ship.position) <= 10) {  // TODO PUT BACK
            //     return "RED";
            // }
        }

        // 2. YELLOW if moderately low energy or significant damage
        if (this.damage >= 1000 || this.energy < 1000) {
            return "YELLOW";
        }

        // 3. GREEN otherwise
        return "GREEN";
    }

    static resolveShipName(abbreviation: string): string | null {
        const upper = abbreviation.toUpperCase();
        return SHIPNAMES.find(name => name.startsWith(upper)) || null;
    }

    static findPlayerByName(name: string): Player | undefined {
        return [...players].find(p => p.ship && p.ship.name === name);
    }

    static findShipByPartialName(partialName: string): Ship | null {
        if (!partialName) return null;
        const name = partialName.toUpperCase();
        const ship = players.find(
            (player: Player) => player.ship && player.ship.name && player.ship.name.toUpperCase().startsWith(name)
        )?.ship;
        return ship || null;
    }
}

export function applyDeviceDamage(
    ship: Ship,
    totalDamage = 150,
    targetDevices?: DeviceName[]
): void {
    const devices = (targetDevices ?? Object.keys(ship.devices)) as DeviceName[];

    const hits = 2 + Math.floor(Math.random() * 2); // 2 or 3 hits
    const perDevice = Math.floor(totalDamage / hits);

    const damageMap: Partial<Record<DeviceName, number>> = {};

    for (let i = 0; i < hits; i++) {
        const target = devices[Math.floor(Math.random() * devices.length)];
        ship.devices[target] += perDevice;
        damageMap[target] = (damageMap[target] ?? 0) + perDevice;
    }

    for (const device of Object.keys(damageMap) as DeviceName[]) {
        const value = ship.devices[device];
        const status = value >= 300 ? "destroyed" : "damaged";
        addPendingMessage(ship.player, `${device} ${status}`);
    }
}

export function getNearbyAlliedShips(v: number, h: number, side: string, range: number): Player[] {
    return players.filter(p => {
        if (!p.ship) return false;
        if (p.ship.side !== side) return false;
        if (!p.radioOn) return false;

        return chebyshev(p.ship.position, { v: v, h: h }) <= range;
    });
}

export function attemptDisplaceFromImpact(attacker: Player, target: Player): void {
    if (!target.ship || !attacker.ship) return;

    const from = attacker.ship.position;
    const to = target.ship.position;

    const dv = Math.sign(to.v - from.v); // impact direction on Y
    const dh = Math.sign(to.h - from.h); // impact direction on X


    const newV = to.v + dv;
    const newH = to.h + dh;

    if (!isInBounds(newV, newH)) return;

    // Do not displace if the space is occupied by any game object (ship, planet, base, etc.)
    if (!findObjectAtPosition(newV, newH, true)) return;

    // Displace the ship
    target.ship.position = { v: newV, h: newH };

    const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, { v: newV, h: newH });
    addPendingMessage(target, `You were displaced to ${coords} by the torpedo impact.`);
    sendMessageToClient(attacker, `${target.ship.name} was knocked to ${newV}-${newH}.`);
}



export function getAdjacentFriendlyPlanets(ship: Ship): Planet[] {
    const { v, h } = ship.position;
    const team = ship.side;

    const adjacent: Planet[] = [];

    for (const planet of planets) {
        if (
            planet.side === team &&
            isAdjacent({ v, h }, planet.position) &&
            !adjacent.some(obj =>
                obj.position.v === planet.position.v &&
                obj.position.h === planet.position.h
            )
        ) {
            adjacent.push(planet);
        }
    }

    return adjacent;
}

export function handleUndockForAllShipsAfterPortDestruction(destroyedPort: Planet): void {
    const side = destroyedPort.side;
    if (side !== "FEDERATION" && side !== "EMPIRE") return; // nothing to do for neutral

    // Alive friendly bases
    const friendlyBases = (side === "FEDERATION" ? bases.federation : bases.empire)
        .filter(b => b.isBase && b.energy > 0);

    // Friendly captured planets (if your game allows docking at them)
    const friendlyPlanets = planets.filter(pl => pl.side === side && !pl.isBase /* captured planet */);

    for (const p of players) {
        const ship = p.ship;
        if (!ship || !ship.docked) continue;
        if (ship.side !== side) continue; // only ships of the destroyed side are affected

        // If ship is still adjacent to ANY friendly base or friendly captured planet, it can remain docked.
        const stillAdjacentToFriendlyBase = friendlyBases.some(b => isAdjacent(ship.position, b.position));
        const stillAdjacentToFriendlyPlanet = friendlyPlanets.some(pl => isAdjacent(ship.position, pl.position));
        const canRemainDocked = stillAdjacentToFriendlyBase || stillAdjacentToFriendlyPlanet;

        if (!canRemainDocked) {
            // Force undock and set RED (BASKIL behavior)
            ship.docked = false;
            ship.condition = "RED";

            // Clear any tracked dock target if present
            if (hasDockTarget(ship)) {
                ship.dockTarget = undefined;
            }

            addPendingMessage(p, "Your docking port was destroyed. You are now UNDOCKED. Condition set to RED.");
        } else {
            // Optional retargeting if you track a dock target (safe no-op otherwise)
            // if (hasDockTarget(ship)) {
            //   const teamBases = ship.side === "FEDERATION" ? bases.federation : bases.empire;
            //   const nearbyBase = teamBases.find(b => isAdjacent(ship.position, b.position));
            //   const nearbyPlanet = planets.find(pl => pl.side === ship.side && isAdjacent(ship.position, pl.position));
            //   ship.dockTarget = nearbyBase ?? nearbyPlanet ?? ship.dockTarget;
            // }
        }
    }
}

// // is this needed?

// export function handleUndockAfterPortDestruction(ship: Ship): void {
//     const remainingPorts = getAdjacentFriendlyPlanets(ship);
//     if (ship.docked && remainingPorts.length <= 1) {
//         ship.docked = false;
//         addPendingMessage(ship.player, "Your docking port was destroyed. You are now undocked.");
//     }
// }
######## srs.ts
import { DEFAULT_SRS_RANGE } from "./settings.js";
import { Player } from './player.js';
import { Command } from './command.js';
import { scan } from "./scan.js";

export function shortRangeScanCommand(player: Player, command: Command): void {
    scan(player, command, DEFAULT_SRS_RANGE);
}
######## star.ts
import { GRID_WIDTH, GRID_HEIGHT } from './settings.js';
import { stars } from './game.js';
import { findObjectAtPosition, Position } from './coords.js';
import { getRandom } from './util/random.js';

export class Star {
    position: Position;

    constructor(v: number, h: number) {
        this.position = { v, h };
    }

    static generate(count?: number): Star[] {
        if (typeof count !== 'number') {
            count = Math.floor(getRandom() * 21) + 40; // 40–60
        }
        let attempts = 0;

        while (stars.length < count && attempts < 1000) {
            const v = Math.floor(getRandom() * GRID_WIDTH) + 1;
            const h = Math.floor(getRandom() * GRID_HEIGHT) + 1;

            if (!findObjectAtPosition(v, h)) {
                stars.push(new Star(v, h));
            }

            attempts++;
        }
        return stars;
    }
}

######## starbase_phasers.ts
import { Player } from './player.js';
import { Side } from './settings.js';
import { Planet } from './planet.js';
import { bases, players } from './game.js';
import { chebyshev } from './coords.js';
import { phadamCore } from './phaser.js';
import { applyShipCriticalParity } from './phaser.js';
import { applyDamage } from './torpedo.js';
import { MAX_SHIELD_ENERGY } from './settings.js';
import { CRIT_CHANCE } from './phaser.js';
import { addPendingMessage } from './communication.js';
import { Ship } from './ship.js';
import { pointsManager } from './game.js';
import { getRandom } from './util/random.js'; // deterministic RNG used elsewhere

type RomulanStatus = {
    isRomulan: boolean;
    isRevealed: boolean;
    cloaked: boolean;
};



// // --- BASPHA parity: enemy bases fire once per sweep ------------------
// function isVisibleToBase(p: Player): boolean {
//     // If you have real cloaking/visibility, use that here:
//     return !(p.ship && (p.ship as any).isCloaked);
// }

// --- BASPHA parity: enemy bases fire once per sweep ------------------
function isVisibleToBase(p: Player): boolean {
    const s = p.ship;
    // Preserve prior behavior: players without a ship were treated as "visible"
    if (!s) return true;

    // Invisible only if truly cloaked and not currently revealed
    if (hasRomulanStatus(s)) {
        return !(s.romulanStatus.cloaked && !s.romulanStatus.isRevealed);
    }

    // No romulan status → visible
    return true;
}

function baseIsOperational(p: Planet): boolean {
    // Today: all registry entries are operational.
    // Future: add e.g. `return p.isBase && !p.destroyed;`
    return p.isBase === true;
}

function enemyBasesFor(side: Side): Planet[] {
    if (side === "ROMULAN") {
        return [...bases.federation, ...bases.empire].filter(baseIsOperational);
    }
    const enemySide: Side = (side === "FEDERATION") ? "EMPIRE" : "FEDERATION";
    const arr = (enemySide === "FEDERATION") ? bases.federation : bases.empire;
    return arr.filter(baseIsOperational);
}

export function basphaFireOnce(mover: Player, numply: number): void {
    if (!mover?.ship) return;

    // Fortran BASPHA: phit = floor(200 / numply)
    const basePhit = Math.max(1, Math.floor(200 / Math.max(1, numply)));

    const allTargets = players.filter(
        p => p?.ship && p.ship.energy > 0 && isVisibleToBase(p)
    );

    const basesToFire = enemyBasesFor(mover.ship.side);

    for (const base of basesToFire) {
        // Each base selects enemies of its own side (important if mover is ROMULAN)
        const targets = allTargets.filter(p => p.ship!.side !== base.side);

        for (const ship of targets) {
            const distance = chebyshev(base.position, ship.ship!.position);
            if (distance > 4) continue; // Fortran: ldis(..., 4)

            // PHADAM (base -> ship): targetIsBase=false, shooterDamaged=false
            const core = phadamCore({
                targetIsBase: false,
                rawShieldEnergy: ship.ship!.shieldEnergy,
                rawShieldMax: MAX_SHIELD_ENERGY,
                distance,
                shooterDamaged: false,
                phit: basePhit,
            });

            let hita = core.hita;

            // write back shield drain
            ship.ship!.shieldEnergy = core.newShieldEnergy;

            // Ship device crit + ±500 jitter BEFORE hull (same as players)
            if (getRandom() < CRIT_CHANCE) {
                const crit = applyShipCriticalParity(ship, hita);
                hita = crit.hita;
                const deviceKeys = Object.keys(ship.ship!.devices);
                const deviceName = deviceKeys[crit.critdv]?.toUpperCase?.() ?? "DEVICE";
                addPendingMessage(ship, `BASE PHASERS CRIT: ${deviceName} damaged by ${crit.critdm}!`);
            }

            // use current "alive" gate as pre-state to avoid double kill credit within the sweep
            const wasAlive = ship.ship!.energy > 0;

            // apply hull/energy damage & destruction via shared resolver (deterministic rng)
            const res = applyDamage(base, ship, hita, getRandom());

            // === scoring parity (credit exactly this volley) ===
            const dealt = Math.max(0, Math.round(res.hita));
            try {
                pointsManager.addDamageToEnemies(dealt, /*player*/ undefined, base.side);
                if (wasAlive && res.isDestroyed) {
                    pointsManager.addEnemiesDestroyed(1, /*player*/ undefined, base.side);
                }
            } catch {
                // pointsManager may be absent in some builds; ignore
            }
            // ===================================================
        }
    }
}


function hasRomulanStatus(s: Ship): s is Ship & { romulanStatus: RomulanStatus } {
    return typeof (s as unknown as { romulanStatus?: RomulanStatus }).romulanStatus !== "undefined";
}
######## status.ts

import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';
import { MAX_SHIELD_ENERGY, settings } from './settings.js';
import { Player } from './player.js';
import { ocdefCoords } from './coords.js';

/**
 * Syntax: STATUS [<codes>]
 * Codes: C (Condition), L (Location), T (Torpedoes), E (Energy),
 *        D (Damage), SH (Shields), RA (Radio), PH (Phasers cooldown)
 * No args: full report in order: Condition, Location, Torps, Energy,
 *          Damage, Shields, Radio.
 */
export function statusCommand(player: Player, command: Command): void {
    const args = command.args.map(a => a.toUpperCase());
    const mode: "SHORT" | "MEDIUM" | "LONG" = player.settings.output ?? "LONG";
    //const coordsMode = player.settings.ocdef ?? "ABSOLUTE";

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use STATUS.");
        return;
    }

    const allFields = ['condition', 'location', 'torpedoes', 'energy', 'damage', 'shields', 'radio', 'phasers'];

    let fields: string[];
    if (args.length === 0) {
        fields = allFields;
    } else {
        fields = allFields.filter(field =>
            args.some(arg => arg.length > 1 && field.toLowerCase().startsWith(arg)) ? field : false
        );
    }

    console.log(fields);

    // Always display stardate first
    switch (mode) {
        case "SHORT":
            sendMessageToClient(player, `SD${settings.stardate}`);
            break;
        case "MEDIUM":
            sendMessageToClient(player, `SDate    ${settings.stardate}`);
            break;
        case "LONG":
        default:
            sendMessageToClient(player, `Stardate   ${settings.stardate}`);
            break;
    }

    const shortParts: string[] = [];
    const conditionStr = player.ship.computeCondition();

    for (const field of fields) {
        switch (field) {
            case 'condition': {
                const isDocked = player.ship.docked;
                const flag = conditionStr[0]; // R, Y, G
                const text = isDocked ? `D+${flag}` : flag;
                if (mode === "SHORT") shortParts.push(text);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Cond   ${conditionStr}`);
                else sendMessageToClient(player, `Condition  ${conditionStr}`);
                break;
            }
            case 'location': {
                const coordText = ocdefCoords(player.settings.ocdef, player.ship.position, player.ship.position);

                if (mode === "SHORT") shortParts.push(coordText);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Loc    ${coordText}`);
                else sendMessageToClient(player, `Location   ${coordText}`);
                break;
            }
            case 'torpedoes': {
                const t = `T${player.ship.torpedoes}`;
                if (mode === "SHORT") shortParts.push(t);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Torps    ${player.ship.torpedoes}`);
                else sendMessageToClient(player, `Torpedoes  ${player.ship.torpedoes}`);
                break;
            }
            case 'energy': {
                const e = `E${Math.round(player.ship.energy)}`;
                if (mode === "SHORT") shortParts.push(e);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Ener   ${player.ship.energy.toFixed(1)}`);
                else sendMessageToClient(player, `Energy     ${player.ship.energy.toFixed(1)}`);
                break;
            }
            case 'damage': {
                const d = `D${Math.round(player.ship.damage)}`;
                if (mode === "SHORT") shortParts.push(d);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Dam     ${player.ship.damage.toFixed(1)}`);
                else sendMessageToClient(player, `Damage     ${player.ship.damage.toFixed(1)}`);
                break;
            }
            case 'shields': {
                const curr = player.ship.shieldEnergy;
                const pct = Math.round((curr / MAX_SHIELD_ENERGY) * 100);
                const status = player.ship.shieldsUp ? "UP" : "DN";
                if (mode === "SHORT") shortParts.push(`SH+${pct}/${status}`);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Shlds  +${pct.toFixed(1)}% ${curr.toFixed(1)} units (${status})`);
                else sendMessageToClient(player, `Shields    +${pct.toFixed(1)}%   ${curr.toFixed(1)} units (${status})`);
                break;
            }
            case 'radio': {
                const r = player.radioOn ? "ROn" : "ROff";
                if (mode === "SHORT") shortParts.push(r);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Radio  ${player.radioOn ? "On" : "Off"}`);
                else sendMessageToClient(player, `Radio      ${player.radioOn ? "On" : "Off"}`);
                break;
            }
            case 'phasers': {
                const now = Date.now();
                const [ph1, ph2] = player.ship.cooldowns.phasersAvailableAt;
                const nextReady = Math.min(ph1, ph2);
                const ready = now >= nextReady;
                if (mode === "SHORT") {
                    shortParts.push(ready ? "PHok" : `PH${Math.ceil((nextReady - now) / 1000)}s`);
                } else {
                    const message = ready
                        ? "Phasrs     ready"
                        : `Phasrs     cooling down (${Math.ceil((nextReady - now) / 1000)}s)`;
                    sendMessageToClient(player, message);
                }
                break;
            }
        }
    }

    if (mode === "SHORT") {
        sendMessageToClient(player, shortParts.join(" "));
    }
}

######## summary.ts
import { listCommandHelper } from "./list.js";
import { Command } from "./command.js";
import { Player } from './player.js';


export function summaryCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, true);
}

######## targets.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";

export function targetsCommand(player: Player, command: Command): void {
    const newArgs = ["ENEMY", ...command.args];
    const taggedCommand = { ...command, args: newArgs };

    listCommand(player, taggedCommand);
}
######## tell.ts
import { Player } from './player.js';
import { Command } from './command.js';
import { players } from './game.js';
import { addPendingMessage, sendMessageToClient } from './communication.js';
import { SHIPNAMES } from './settings.js';
import { matchesPattern } from './util/util.js';

export function tellCommand(player: Player, command: Command): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use TELL.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    if (!command.raw.includes(';')) {
        sendMessageToClient(player, "TEll All|FEderation|HUman|EMpire|Klingon|ENemy|FRiendly|<shipnames>;<msg>");
        return;
    }

    const [targetPart, ...msgParts] = command.raw.split(";");
    const message = msgParts.join(";").trim();

    if (!player.radioOn) {
        sendMessageToClient(player, "Captain, your radio is off.");
        return;
    }

    if (!message) {
        sendMessageToClient(player, "Message required after semicolon.");
        return;
    }

    const targetTokens = targetPart.trim().split(/\s+/).slice(1).map(t => t.toUpperCase());
    let targetDesc = targetTokens.join(" ");
    let recipients = players.filter(p => p.ship);

    const keyword = targetTokens[0];

    // --- Handle broadcast group keywords ---
    const matchGroup =
        matchesPattern(keyword, "All") ? "ALL" :
            matchesPattern(keyword, "FEderation") ? "FEDERATION" :
                matchesPattern(keyword, "EMpire") ? "EMPIRE" :
                    matchesPattern(keyword, "Human") ? "HUMAN" :
                        matchesPattern(keyword, "Klingon") ? "KLINGON" :
                            matchesPattern(keyword, "ENemy") ? "ENEMY" :
                                matchesPattern(keyword, "FRiendly") ? "FRIENDLY" :
                                    null;

    if (matchGroup) {
        switch (matchGroup) {
            case "ALL":
                recipients = players.filter(p => p.ship);
                targetDesc = "ALL";
                break;
            case "FEDERATION":
            case "HUMAN":
                recipients = recipients.filter(p => p.ship && p.ship.side === "FEDERATION");
                targetDesc = matchGroup;
                break;
            case "EMPIRE":
            case "KLINGON":
                recipients = recipients.filter(p => p.ship && p.ship.side === "EMPIRE");
                targetDesc = matchGroup;
                break;
            case "ENEMY":
                recipients = recipients.filter(p => p.ship && player.ship && p.ship.side !== player.ship.side);
                targetDesc = "ENEMY";
                break;
            case "FRIENDLY":
                recipients = recipients.filter(p => p.ship && player.ship && p.ship.side === player.ship.side);
                targetDesc = "FRIENDLY";
                break;
        }
    } else {
        // --- Handle ship name targeting ---
        const matchedShips: Player[] = [];
        for (const target of targetTokens) {
            const matches = recipients.filter(p => p.ship?.name?.toUpperCase().startsWith(target));
            if (matches.length === 1) {
                matchedShips.push(matches[0]);
            } else if (SHIPNAMES.some(name => name.startsWith(target))) {
                sendMessageToClient(player, `Ship ${SHIPNAMES.find(name => name.startsWith(target))} not in game`);
            } else {
                sendMessageToClient(player, `Unknown target: ${target}`);
            }
        }
        recipients = matchedShips;
    }

    if (recipients.length === 0) {
        sendMessageToClient(player, `No reachable ${matchGroup}'s for TELL.`);
        return;
    }

    // --- Deliver messages ---
    for (const recipient of recipients) {
        if (recipient !== player) {
            if (recipient.radioOn) {
                addPendingMessage(recipient, `<< ${player.ship.name} (TELL): ${message}`);
            }
        }
    }
    sendMessageToClient(player, `>> To ${targetDesc}: ${message}`);
}
######## temp.ts

######## time.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
const gameStartTime = Date.now();

export function timeCommand(player: Player): void {
    const nowMs = Date.now();

    const secsSinceGameStart = (nowMs - gameStartTime) / 1000;
    const secsSinceJoin = (nowMs - player.joinTime) / 1000;
    const processUptimeSec = process.uptime();

    const currentTime = new Date(nowMs).toLocaleTimeString('en-US', {
        hour12: false
    });

    const timeLine = (label: string, value: string | number) => `  ${label.padEnd(22)}${value}`;
    // Add random 2 digits to stardate for a "fancy" stardate as a number
    // Galactic stardate is seconds since game start divided by 100, plus random 2 digits at the end
    //const baseStardate = secsSinceGameStart / 100;

    sendMessageToClient(player, timeLine("Stardate:", player.stardate));
    sendMessageToClient(player, timeLine("Game's elapsed time:", formatDuration(secsSinceGameStart)));
    sendMessageToClient(player, timeLine("Ship's elapsed time:", formatDuration(secsSinceJoin)));
    sendMessageToClient(player, timeLine("Current time (UTC):", currentTime));
    sendMessageToClient(player, timeLine("Job's total run time:", formatDuration(processUptimeSec)));
    sendMessageToClient(player, "");
}

export function formatDuration(totalSeconds: number): string {
    const days = Math.floor(totalSeconds / 86400);
    totalSeconds %= 86400;

    const hours = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;

    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const hms = [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        seconds.toString().padStart(2, '0')
    ].join(':');

    return days > 0
        ? `${days}d ${hms}`
        : hms;
}
######## torpedo.ts
import { Player } from './player.js';
import { Command } from './command.js';
import {
    addPendingMessage,
    putClientOnHold,
    releaseClient,
    sendMessageToClient,
    sendMessageToOthers
} from './communication.js';
import {
    MAX_SHIELD_ENERGY,
    MAX_TORPEDO_RANGE,
    GRID_HEIGHT,
    GRID_WIDTH,
    CoordMode
} from './settings.js';
import { Planet } from './planet.js';
import { isInBounds, bresenhamLine, chebyshev, ocdefCoords } from './coords.js';
import { players, bases, planets, stars, blackholes, pointsManager, removePlayerFromGame, checkEndGame } from './game.js';
import { handleUndockForAllShipsAfterPortDestruction } from './ship.js';
import { triggerNovaAt } from './nova.js';
import { Star } from './star.js';
import { Blackhole } from './blackhole.js';
import { applyShipCriticalParity } from './phaser.js';
import { Side } from './settings.js';
import { gameEvents } from './api/events.js';

// ...

type ScoringAPI = {
    addDamageToBases?(amount: number, source: Player, side: Side): void;
    addEnemiesDestroyed?(count: number, source: Player, side: Side): void;
    addDamageToEnemies?(amount: number, source: Player, side: Side): void;
};

import { SHIP_FATAL_DAMAGE } from './game.js';

type TorpedoCollision =
    | { type: "ship"; player: Player }
    | { type: "planet"; planet: Planet }
    | { type: "star"; star: Star }
    | { type: "blackhole"; blackhole: Blackhole }
    | { type: "target"; point: Point } // reached target with no collision
    | { type: "boundary"; point: Point } // reached grid boundary
    | null;

type Point = { v: number; h: number };

function getPointTenStepsAway(start: Point, end: Point): Point {
    // Direction vector from start to end
    const dh = end.h - start.h; // Δh
    const dv = end.v - start.v; // Δv

    // Euclidean distance (magnitude of direction vector)
    const magnitude = Math.sqrt(dh * dh + dv * dv);

    if (magnitude === 0) {
        // If start and end are the same, return start
        return { v: start.v, h: start.h };
    }

    // Normalize direction vector
    const unitH = dh / magnitude;
    const unitV = dv / magnitude;

    // Move 10 steps along the direction
    const steps = 10;
    let newH = start.h + unitH * steps;
    let newV = start.v + unitV * steps;

    // Round to nearest grid point (integer coordinates)
    newH = Math.round(newH);
    newV = Math.round(newV);

    // Clamp to grid boundaries
    newH = Math.max(1, Math.min(GRID_WIDTH, newH));
    newV = Math.max(1, Math.min(GRID_HEIGHT, newV));

    return { v: newV, h: newH };
}

function traceTorpedoPath(player: Player, start: Point, target: Point): TorpedoCollision {

    if (!isInBounds(start.v, start.h) || !isInBounds(target.v, target.h)) {
        sendMessageToClient(player, `Start ${JSON.stringify(start)} or target ${JSON.stringify(target)} is outside grid boundaries`);
        return null;
    }

    const { v: endV, h: endH } = getPointTenStepsAway(start, target);
    const points = bresenhamLine(start.v, start.h, endV, endH);
    let skipFirst = true;

    for (const { v, h } of points) {
        if (skipFirst) {
            skipFirst = false;
            continue; // Skip the attacker's own position
        }

        // Verify point is within grid (defensive check)
        if (!isInBounds(v, h)) {
            sendMessageToClient(player, `Bresenham point (${v}, ${h}) is outside grid boundaries`);
            return null;
        }

        // Check for ship
        const ship = players.find(p => p.ship && p.ship.position.v === v && p.ship.position.h === h);
        if (ship) return { type: "ship", player: ship };

        // Check for planet
        const planet = planets.find(p => p.position.h === h && p.position.v === v);
        if (planet) return { type: "planet", planet: planet };

        // Check for star
        const star = stars.find(star => star.position.v === v && star.position.h === h);
        if (star) {
            return { type: "star", star: star };
        }

        // Check for black hole
        const blackhole = blackholes.find(bh => bh.position.v === v && bh.position.h === h);
        if (blackhole) {
            return { type: "blackhole", blackhole: blackhole };
        }
    }

    // No collision, reached the grid boundary
    const boundaryPoint = { v: endV, h: endH };
    // if (!isInBounds(boundaryPoint.v, boundaryPoint.h)) {
    //     throw new Error(`Boundary point ${JSON.stringify(boundaryPoint)} is outside grid boundaries`);
    // }
    return { type: "boundary", point: boundaryPoint };
}


function getTargetsFromCommand(player: Player, args: string[], mode: "ABSOLUTE" | "RELATIVE" | "COMPUTED", cursor: number, n: number): { v: number; h: number }[] | null {
    const targets: { v: number; h: number }[] = [];
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to fire torpedoes.");
        return null;
    }

    if (mode === "COMPUTED") {
        const matchedShips: { v: number; h: number }[] = [];
        while (cursor < args.length) {
            const partialName = args[cursor++].toUpperCase();
            const match = players.find(p => p.ship && p.ship.name && p.ship.name.toUpperCase().startsWith(partialName));
            if (!match) {
                sendMessageToClient(player, `No ship found matching '${partialName}'.`);
                return null;
            }
            if (match.ship) {
                matchedShips.push({ v: match.ship.position.v, h: match.ship.position.h });
            }
        }
        if (matchedShips.length === 0) {
            sendMessageToClient(player, "At least one valid ship name must be provided.");
            return null;
        }
        targets.push(...repeatOrTrim(matchedShips, n));
    } else {
        const coordPairs: { v: number, h: number; }[] = [];
        if (mode === "RELATIVE") {
            while (cursor + 1 < args.length) {
                const dv = parseInt(args[cursor++]);
                const dh = parseInt(args[cursor++]);
                if (isNaN(dv) || isNaN(dh)) {
                    sendMessageToClient(player, "Invalid RELATIVE coordinate offset.");
                    return null;
                }
                coordPairs.push({
                    v: player.ship.position.v + dv,
                    h: player.ship.position.h + dh
                });
            }
        } else {
            while (cursor + 1 < args.length) {
                const v = parseInt(args[cursor++]);
                const h = parseInt(args[cursor++]);
                if (isNaN(v) || isNaN(h)) {
                    sendMessageToClient(player, "Invalid coordinate pair.");
                    return null;
                }
                coordPairs.push({ v, h });
            }
        }
        if (coordPairs.length === 0) {
            sendMessageToClient(player, "At least one coordinate pair is required.");
            return null;
        }
        targets.push(...repeatOrTrim(coordPairs, n));
    }

    return targets;
}

export function torpedoCommand(player: Player, command: Command, done?: () => void): void {
    const args = command.args;
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to fire torpedoes.");
        done?.();
        return;
    }

    if (!player.ship.isDeviceOperational("torpedo")) {
        done?.();
        return;
    }
    // if (Date.now() < player.ship.cooldowns.torpedoesReadyAt) {
    //     sendMessageToClient(player, "Torpedo tubes not yet reloaded.");
    //     done?.();
    //     return;
    // }

    if (args.length < 2) {
        sendMessageToClient(player, "Usage: TORPEDO [A|R|C] <1–3> <targets...>");
        done?.();
        return;
    }

    // Determine mode
    let mode: CoordMode;
    let cursor = 0;
    const modeArg = args[0].toUpperCase();

    if (["A", "ABSOLUTE"].includes(modeArg)) { mode = "ABSOLUTE"; cursor++; }
    else if (["R", "RELATIVE"].includes(modeArg)) { mode = "RELATIVE"; cursor++; }
    else if (["C", "COMPUTED"].includes(modeArg)) { mode = "COMPUTED"; cursor++; }
    else { mode = player.settings.icdef; }

    const n = parseInt(args[cursor++]);
    if (isNaN(n) || n < 1 || n > 3) {
        sendMessageToClient(player, "You must fire between 1 and 3 torpedoes.");
        done?.();
        return;
    }

    if (player.ship.torpedoes < n) {
        sendMessageToClient(player, "Not enough torpedoes.");
        done?.();
        return;
    }

    if (mode === "COMPUTED" && !player.ship.isDeviceOperational("computer")) {
        done?.();
        return;
    }

    const targets = getTargetsFromCommand(player, args, mode, cursor, n);
    if (!targets) {
        done?.();
        return;
    }

    for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.v === player.ship.position.v && target.h === player.ship.position.h) {
            sendMessageToClient(player, "Cannot target your own position.");
            continue;
        }
        const range = chebyshev(player.ship.position, target);
        if (range > MAX_TORPEDO_RANGE) {
            sendMessageToClient(player, formatTorpedoOutOfRange(player, target.v, target.h));
            continue;
        }

        const collision = traceTorpedoPath(player, player.ship.position, target);
        if (!collision) {
            continue;
        }
        let fired = false;
        switch (collision?.type) {
            case "ship": {
                const victim = collision.player;
                const res = torpedoDamage(player, victim);
                fired = true;

                // Shooter message
                {
                    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, victim.ship!.position);
                    sendMessageToClient(player, `Torpedo hit ${victim.ship!.name} @${coords} for ${Math.round(res.hita)} damage${res.critdm ? " (CRIT)" : ""}.`);
                }
                // Victim message
                addPendingMessage(victim, `${player.ship!.name} hit you with a torpedo for ${Math.round(res.hita)} damage${res.critdm ? " (CRIT)" : ""}.`);

                // Endgame check if something died
                if (res.isDestroyed) {
                    checkEndGame();
                }
                break;
            }

            case "planet": {
                const p = collision.planet;
                const res = torpedoDamage(player, p); // will no-op on non-base planets by validation
                fired = true;

                const coords = ocdefCoords(player.settings.ocdef, player.ship.position, p.position);
                if (p.isBase) {
                    sendMessageToClient(player, `Torpedo ${res.hita > 0 ? `hit base @${coords} for ${Math.round(res.hita)} damage` : `was deflected @${coords}`}${res.critdm ? " (CRIT)" : ""}.`);
                    if (res.isDestroyed) checkEndGame();
                } else {
                    // Non-base planets are inert to torpedoes per your validation
                    sendMessageToClient(player, `Torpedo impact on planet @${coords} had no significant effect.`);
                }
                break;
            }

            case "star":
                sendMessageToClient(player, formatTorpedoExplosion(player, collision.star.position.v, collision.star.position.h));
                if (Math.random() < 0.8) {
                    triggerNovaAt(player, collision.star.position.v, collision.star.position.h);
                }
                fired = true;
                break;

            case "blackhole":
                sendMessageToClient(player, formatTorpedoLostInVoid(player, collision.blackhole.position.v, collision.blackhole.position.h));
                fired = true;
                break;

            case "boundary": {
                const { v, h } = collision.point;
                sendMessageToClient(player, `Torpedo flew off to ${ocdefCoords(player.settings.ocdef, player.ship.position, { v, h })} and detonated harmlessly.`);
                fired = true;
                break;
            }

            default:
                sendMessageToClient(player, `Torpedo failed to reach target.`);
                fired = true;
                break;
        }


        if (i !== targets.length - 1) { // not last target
            if (fired) {
                player.ship.torpedoes--;
                sendMessageToOthers(player, formatTorpedoBroadcast(player, target.v, target.h));

                if (player.ship.romulanStatus.isRomulan) {
                    player.ship.romulanStatus.isRevealed = true;
                    setTimeout(() => {
                        if (player.ship)
                            player.ship.romulanStatus.isRevealed = false;
                    }, 5000);   // TODO is this right?
                }
            }
        } else { // last target
            const captureDelayMs = 2000 + Math.random() * 2000 + player.ship.devices.torpedo / 100;
            if (fired) {
                putClientOnHold(player, "");
                const timer = setTimeout(() => {
                    releaseClient(player);
                    if (player.ship) {
                        player.ship.torpedoes--;
                    }
                    sendMessageToOthers(player, formatTorpedoBroadcast(player, target.v, target.h));

                    if (player.ship && player.ship.romulanStatus.isRomulan) {
                        player.ship.romulanStatus.isRevealed = true;
                        setTimeout(() => {
                            if (player.ship) {
                                player.ship.romulanStatus.isRevealed = false;
                            }
                        }, 5000);   // TODO is this right?
                    }
                    done?.();
                }, captureDelayMs);
                player.currentCommandTimer = timer;
            } else {
                done?.();
                return;
            }
        }
    }
    done?.();
}



function repeatOrTrim<T>(items: T[], n: number): T[] {
    const result: T[] = [];
    for (let i = 0; i < n; i++) {
        result.push(i < items.length ? items[i] : items[items.length - 1]);
    }
    return result;
}

function formatTorpedoOutOfRange(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    switch (player.settings.output) {
        case "SHORT":
            return `F > ${coords} No impact`;
        case "MEDIUM":
            return `Torpedo did not reach ${coords} `;
        case "LONG":
        default:
            return `Torpedo launch aborted.Target at ${coords} is beyond maximum range.`;
    }
}
function formatTorpedoLostInVoid(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    switch (player.settings.output) {
        case "SHORT":
            return `F > ${coords} Vanished`;
        case "MEDIUM":
            return `Torpedo swallowed by black hole`;
        case "LONG":
        default:
            return `Torpedo lost at ${coords}. Possible gravitational anomaly encountered.`;
    }
}

function formatTorpedoExplosion(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    switch (player.settings.output) {
        case "SHORT":
            return `F > ${coords} BOOM`;
        case "MEDIUM":
            return `Explosion at ${coords}!`;
        case "LONG":
        default:
            return `Torpedo triggered explosion at ${coords}. Unstable celestial mass may have ignited.`;
    }
}


function formatTorpedoBroadcast(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });
    switch (player.settings.output) {
        case "SHORT":
            return `F > ${coords} `;
        case "MEDIUM":
            return `Torpedo launched toward ${coords} `;
        case "LONG":
        default:
            return `${player.ship?.name ?? "Unknown"} has launched a torpedo toward ${coords}.`;
    }
}

const CRIT_CHANCE = 0.20;  // TODO should this be in global?
// Torpedo damage (TORDAM entry point) — parity-focused
// Torpedo damage (TORDAM entry point) — parity-focused
// --- Torpedo damage (TORDAM parity) ---------------------------------------
export function torpedoDamage(
    source: Player | Planet,
    target: Player | Planet
): { hita: number; isDestroyed: boolean; shieldStrength: number; shieldsUp: boolean; critdm: number } {
    // Validate target state
    if (target instanceof Player) {
        const ship = target.ship;
        if (!ship || ship.energy <= 0 || ship.damage >= SHIP_FATAL_DAMAGE) {
            return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
        }
    } else if (target instanceof Planet) {
        // Only bases take torpedo damage
        if (!target.isBase || target.energy <= 0) {
            return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
        }
    } else {
        return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
    }

    const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
    const toPct = (energy: number, max: number) => (max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0);
    const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

    const isPlayer = target instanceof Player && !!target.ship;
    const isBase = target instanceof Planet && target.isBase;

    let rawShieldEnergy = isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy; // bases store 0..1000
    const rawShieldMax = isPlayer ? MAX_SHIELD_ENERGY : 1000;
    const shieldsUp = isPlayer ? target.ship!.shieldsUp : true;

    let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

    // Base torpedo hit (Fortran TORDAM): 4000..8000
    const hit = 4000.0 + 4000.0 * Math.random();

    // Deflection test
    const rana = Math.random();
    const rand = Math.random();
    const rand2 = rana - (shieldPct * 0.001 * rand) + 0.1;

    if (rand2 <= 0.0) {
        // Deflected: drain some shields (50 * rana on 0..1000 scale)
        shieldPct = clamp(shieldPct - 50.0 * rana, 0, 1000);
        rawShieldEnergy = fromPct(shieldPct, rawShieldMax);

        if (isPlayer) {
            target.ship!.shieldEnergy = rawShieldEnergy;
            addPendingMessage(target, `Your ship's shields deflected a torpedo, losing ${Math.round(50.0 * rana)} shield units!`);
        } else {
            (target as Planet).energy = rawShieldEnergy;
        }

        return {
            hita: 0,
            isDestroyed: false,
            shieldStrength: rawShieldEnergy,
            shieldsUp,
            critdm: 0,
        };
    }

    // Damage through shields + drain
    let hita = hit;
    const prevShieldPct = shieldPct;

    if (shieldPct > 0) {
        // Portion that penetrates
        hita = hit * (1000.0 - shieldPct) * 0.001;

        // Drain shields
        const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
        shieldPct = shieldPct - (hit * absorptionFactor + 10.0) * 0.03;
        if (shieldPct < 0) shieldPct = 0;

        // Write back
        rawShieldEnergy = fromPct(shieldPct, rawShieldMax);
        if (isPlayer) {
            target.ship!.shieldEnergy = rawShieldEnergy;
        } else {
            (target as Planet).energy = rawShieldEnergy;
        }
    }

    // Base collapse crit/kill BEFORE hull
    let critdm = 0;
    if (isBase && prevShieldPct > 0 && shieldPct === 0) {
        const rana2 = Math.random();
        const extra = 50 + Math.floor(100 * rana2); // 50..149
        (target as Planet).energy = Math.max(0, (target as Planet).energy - extra);
        critdm = 1;

        if (Math.random() < 0.10 || (target as Planet).energy <= 0) {
            // Base killed via collapse: award and remove
            // (ensure you have this import somewhere near the top of the file)
            // import { gameEvents } from "./api/events.js";

            if (source instanceof Player && source.ship) {
                const atkSide = source.ship.side;
                const tgtSide = (target as Planet).side;
                const sign = atkSide !== tgtSide ? 1 : -1;

                (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, source, atkSide);
                (pointsManager as unknown as ScoringAPI).addEnemiesDestroyed?.(1, source, atkSide);
            }

            // --- base removal / collapse ---
            {
                const base = target as Planet;
                const prevSide = base.side; // capture before mutation

                // remove from the correct team list using the captured side
                const arr = prevSide === "FEDERATION" ? bases.federation : bases.empire;
                const idx = arr.indexOf(base);
                if (idx !== -1) arr.splice(idx, 1);

                // mutate planet state
                base.isBase = false;
                base.builds = 0;
                base.energy = 0;
                // Fortran semantics typically keep the planet's side after base destruction.
                // If you intend to neutralize immediately, do it explicitly:
                // base.side = "NEUTRAL";

                handleUndockForAllShipsAfterPortDestruction(base);

                // emit event with correct previous side and current position
                gameEvents.emit({
                    type: "planet_base_removed",
                    payload: {
                        planet: {
                            name: base.name,
                            previousSide: prevSide,
                            position: { ...base.position },
                            energy: base.energy,
                            builds: base.builds,
                        },
                        by: (source instanceof Player && source.ship)
                            ? { shipName: source.ship.name, side: source.ship.side }
                            : undefined,
                        reason: "collapse_torpedo",
                    },
                });
            }



            return {
                hita, // pre-scale raw hit for telemetry, but base is gone
                isDestroyed: true,
                shieldStrength: 0,
                shieldsUp: false,
                critdm,
            };
        }
    }

    // Ship critical (device damage) BEFORE hull
    if (isPlayer && Math.random() < CRIT_CHANCE) {
        const crit = applyShipCriticalParity(target as Player, hita);
        hita = crit.hita;
        critdm = Math.max(critdm, crit.critdm);

        const deviceKeys = Object.keys(target.ship!.devices);
        const deviceName = deviceKeys[crit.critdv]?.toUpperCase?.() ?? "DEVICE";
        addPendingMessage(target as Player, `CRITICAL HIT: ${deviceName} damaged by ${crit.critdm}!`);
    }

    // Scale raw torp impact into hull units (~×0.1) before applying/scoring
    const TORP_HULL_SCALE = 0.1;
    const hull = Math.max(0, Math.round(hita * TORP_HULL_SCALE));

    // Apply to target
    const result = applyDamage(source, target, hull, rana) || {
        hita: hull,
        isDestroyed: false,
        shieldStrength: isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy,
        shieldsUp,
        critdm: 0,
    };

    // Award DAMAGE POINTS on the actual applied hull damage
    if (source instanceof Player && source.ship && result.hita > 0) {
        const atkSide = source.ship.side;

        if (isBase) {
            const sign = atkSide !== (target as Planet).side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToBases?.(result.hita * sign, source, atkSide);
        } else if (isPlayer) {
            const sign = atkSide !== target.ship!.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(result.hita * sign, source, atkSide);
        }
    }

    // Kill bonuses (post-state)
    if (source instanceof Player && source.ship && result.isDestroyed) {
        const atkSide = source.ship.side;

        if (isPlayer) {
            const sign = atkSide !== target.ship!.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(5000 * sign, source, atkSide);
            // ship kill count already handled in applyDamage
        } else if (isBase) {
            const sign = atkSide !== (target as Planet).side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, source, atkSide);
            (pointsManager as unknown as ScoringAPI).addEnemiesDestroyed?.(1, source, atkSide);
        }
    }

    // Surface crit flag and shield fields
    result.critdm = Math.max(result.critdm || 0, critdm);
    result.shieldsUp = isPlayer ? (target.ship!.shieldsUp && target.ship!.shieldEnergy > 0) : true;
    result.shieldStrength = isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy;

    return result;
}




// /**
//  * TORDAM-parity core for torpedo impact against shields/hull.
//  * Internally uses 0..1000 shield scale and converts back to your storage.
//  */
// function tordamCore(params: {
//     rawShieldEnergy: number; // current stored shield/energy
//     rawShieldMax: number;    // players: MAX_SHIELD_ENERGY; bases: 1000
// }): { hita: number; newShieldEnergy: number } {
//     const { rawShieldEnergy, rawShieldMax } = params;

//     const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
//     const toPct = (energy: number, max: number) =>
//         max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0;
//     const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

//     // Torpedo base impact (Fortran: 4000..8000 range)
//     let hit = 4000 + 4000 * Math.random();

//     // Shields in 0..1000 scale
//     let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

//     // If shields are up, absorb part of the hit and drain shields
//     // Absorb: hit = (1000 - shield%) * hit * 0.001
//     // Drain:  shield% -= (hit * amax1(shield%*0.001, 0.1) + 10) * 0.03
//     if (shieldPct > 0) {
//         hit = (1000 - shieldPct) * hit * 0.001;

//         const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
//         shieldPct = shieldPct - (hit * absorptionFactor + 10) * 0.03;
//         if (shieldPct < 0) shieldPct = 0;
//     }

//     const hita = hit; // final torpedo damage post-absorption
//     return { hita, newShieldEnergy: fromPct(shieldPct, rawShieldMax) };
// }

// Shared damage resolver for phasers / torpedoes
// --- Shared damage resolver (phasers/torpedoes) ---------------------------
export function applyDamage(
    source: Player | Planet,
    target: Player | Planet,
    hita: number,
    rana: number
): { hita: number; isDestroyed: boolean; shieldStrength: number; shieldsUp: boolean; critdm: number } {
    void rana;
    const critdm = 0;
    let isDestroyed = false;

    // Ships
    if (target instanceof Player && target.ship) {
        target.ship.energy -= hita;
        target.ship.damage += hita / 2;

        // Clamp to avoid negative telemetry
        if (target.ship.energy < 0) target.ship.energy = 0;

        if (target.ship.energy <= 0 || target.ship.damage >= SHIP_FATAL_DAMAGE) {
            isDestroyed = true;
            removePlayerFromGame(target);
            if (source instanceof Player && source.ship) {
                pointsManager.addEnemiesDestroyed(1, source, source.ship.side);
            }
        }

        return {
            hita,
            isDestroyed,
            shieldStrength: target.ship.shieldEnergy,
            shieldsUp: target.ship.shieldsUp && target.ship.shieldEnergy > 0,
            critdm,
        };
    }

    // Bases
    if (target instanceof Planet && target.isBase) {
        target.energy -= hita;
        if (target.energy < 0) target.energy = 0;


        if (target.energy <= 0) {
            isDestroyed = true;

            // capture before mutation
            const prevSide = target.side;

            const arr = prevSide === "FEDERATION" ? bases.federation : bases.empire;
            const idx = arr.indexOf(target);
            if (idx !== -1) arr.splice(idx, 1);

            // mutate the planet
            target.isBase = false;
            target.energy = 0;
            target.builds = 0;
            // NOTE: Fortran semantics usually keep side until later recapture; 
            // if you demote to neutral immediately, do it explicitly here:
            // target.side = "NEUTRAL";

            handleUndockForAllShipsAfterPortDestruction(target);

            // emit with the captured previous side
            gameEvents.emit({
                type: "planet_base_removed",
                payload: {
                    planet: {
                        name: target.name,
                        previousSide: prevSide,               // <-- fix
                        position: { ...target.position }
                    },
                    reason: "collapse_torpedo"
                }
            });
        }


        return {
            hita,
            isDestroyed,
            shieldStrength: target.energy,
            shieldsUp: true,
            critdm,
        };
    }

    // Fallback (shouldn’t occur)
    return { hita, isDestroyed, shieldStrength: 0, shieldsUp: false, critdm };
}


######## tractor.ts
// DECWAR-style TRACTOR (TR) command implementation
import { Player } from './player.js';
import { Command } from './command.js';
import { addPendingMessage, sendMessageToClient, sendOutputMessage } from './communication.js';
import { SHIPNAMES } from './settings.js';
import { Ship } from './ship.js';
import { chebyshev } from './coords.js';

export function tractorCommand(player: Player, command: Command): void {
    const args = command.args;
    const arg = args[0]?.toUpperCase();


    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use TRACTOR.");
        return;
    }

    if (player.ship.tractorPartner) {
        sendMessageToClient(player, "Tractor beam already active, sir.");
        return;
    }

    if (!player.ship.isDeviceOperational("tractor")) return;

    // TRACTOR or TRACTOR OFF to release
    if (!arg || arg === "OFF") {
        if (player.ship.tractorPartner !== null) {
            const targetShip = player.ship.tractorPartner as Ship;
            targetShip.tractorPartner = null;
            const partnerPlayer = targetShip.player;
            player.ship.tractorPartner = null;
            sendOutputMessage(player, {
                SHORT: "Trac. Beam off",
                MEDIUM: "Trac. Beam off",
                LONG: "Tractor beam broken, Captain."
            });
            addPendingMessage(partnerPlayer, `${player.ship.name} has disengaged tractor beam.`);
        } else {
            sendMessageToClient(player, "No tractor beam is active.");
        }
        return;
    }

    // Match by prefix
    const matches = SHIPNAMES.filter(name => name.startsWith(arg));
    if (matches.length === 0) {
        sendMessageToClient(player, `No ship found matching "${arg}".`);
        return;
    }
    if (matches.length > 1) {
        sendMessageToClient(player, `Ambiguous ship name "${arg}". Matches: ${matches.join(", ")}`);
        return;
    }

    const targetName = matches[0];
    const target = Ship.findPlayerByName(targetName);

    if (!target || !target.ship) {
        sendMessageToClient(player, `${targetName} is not active.`);
        return;
    }

    if (!target || !target.ship) {
        sendMessageToClient(player, `${targetName} is not active.`);
        return;
    }
    if (target === player) {
        sendMessageToClient(player, "Beg your pardon, sir?  You want to apply a tractor beam to your own ship?");
        return;
    }
    if (player.ship.side !== target.ship.side) {
        sendMessageToClient(player, "Can not apply tractor beam to enemy ship.");
        return;
    }

    if (chebyshev(player.ship.position, target.ship.position) > 1) {
        sendMessageToClient(player, "Target ship is not adjacent.");
        return;
    }

    if (player.ship.tractorPartner) {
        sendMessageToClient(player, `Tractor beam activated, Captain.\r\nUse TRACTOR OFF to release.`);
        return;
    }

    if (player.ship.shieldsUp) {
        sendMessageToClient(player, "Both ships must have shields down to initiate tractor beam.");
        return;
    }

    if (target.ship.shieldsUp) {
        sendMessageToClient(player, `${target.ship.name} has his shields up.  Unable to apply tractor beam.`);
        return;
    }

    // Establish link 
    player.ship.tractorPartner = target.ship;
    target.ship.tractorPartner = player.ship;

    sendMessageToClient(player, `Tractor beam locked on to ${target.ship.name}.`);
    sendOutputMessage(player, {
        SHORT: "Trac. Beam on",
        MEDIUM: "Trac. Beam on",
        LONG: "Tractor beam activated, Captain."
    });
    addPendingMessage(target, `You are now being tractored by ${player.ship.name}.`);
}

export function disconnectTractor(ship: Ship): void {
    if (ship.tractorPartner) {
        if (ship.tractorPartner.tractorPartner) {
            addPendingMessage(ship.tractorPartner.player, `Tractor beam broken, ${ship.name} disconnected.`);
            ship.tractorPartner.tractorPartner = null;
        }
        ship.tractorPartner = null;
        sendMessageToClient(ship.player, `Tractor beam broken, Captain.`);
    }
}

export function disconnectTractorWithReason(ship: Ship, reason: string): void {
    if (ship.tractorPartner) {
        addPendingMessage(ship.player, `Tractor beam broken, disconnected by ${reason}.`);

        if (ship.tractorPartner.tractorPartner) {
            addPendingMessage(ship.tractorPartner.player, `Tractor beam broken, disconnected by ${reason}.`);
            ship.tractorPartner.tractorPartner = null;
        }
        ship.tractorPartner = null;
    }
}
######## tweak.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';

export function tweakCommand(player: Player, command: Command): void {

    if (command.args[0] === "FEDERATION") {
        removeAllPlanetsAndBasesFromSide("FEDERATION");
    } else if (command.args[0] === "EMPIRE") {
        removeAllPlanetsAndBasesFromSide("EMPIRE");
    }
    sendMessageToClient(player, "Tweaked");
}



// // CODE TO TEST END OF GAME

// if (command.args[0] === "FEDERATION") {
//     removeAllPlanetsAndBasesFromSide("FEDERATION");
// } else if (command.args[0] === "EMPIRE") {
//     removeAllPlanetsAndBasesFromSide("EMPIRE");


// Removes all planets and all bases from a given side ("FEDERATION" or "EMPIRE")
import { Side } from './settings.js';
import { planets } from './game.js';
import { bases } from './game.js';

// Remove all planets and all bases belonging to the specified side
export function removeAllPlanetsAndBasesFromSide(side: Side): void {
    const sideKey = side === "FEDERATION" ? "federation" : side === "EMPIRE" ? "empire" : null;

    // bases.federation.length = 0;
    // bases.empire.length = 0;

    if (sideKey && bases[sideKey]) {
        bases[sideKey].length = 0;
    }

    // Remove all planets on the opposite side
    const oppositeSide = side === "FEDERATION" ? "EMPIRE" : side === "EMPIRE" ? "FEDERATION" : null;

    if (oppositeSide) {
        for (let i = planets.length - 1; i >= 0; i--) {
            if (planets[i].side === oppositeSide && !planets[i].isBase) {
                planets.splice(i, 1);
            }
        }
    }
}

######## type.ts
import { sendOutputMessage } from './communication.js';
import { Player } from './player.js';
import { settings } from './settings.js';

export function typeCommand(player: Player): void {
    const { version, date, allowRomulans, allowBlackHoles } = settings;
    const { output, prompt, scan, icdef, ocdef } = player.settings;

    const short = `[v1.${version}] ${allowRomulans ? 'Romulans' : 'No Romulans'}, ${output} output, ${icdef} in, ${ocdef} out\r\n`;

    const medium = [
        `[DECWARJS Version 1.${version}, ${date}]`,
        `Romulans: ${allowRomulans ? 'enabled' : 'disabled'}.`,
        `Black holes: ${allowBlackHoles ? 'enabled' : 'disabled'}.`,
        `Output: ${output}`,
        `Prompt: ${prompt}`,
        `SCAN format: ${scan}`,
        `Input coords: ${icdef}`,
        `Output coords: ${ocdef}`
    ].join('\r\n') + '\r\n';

    const longLines: string[] = [
        `[DECWARJS Version 1.${version}, ${date}]`,
        `There ${allowRomulans ? 'are' : 'are no'} Romulans in this game.`,
        `There ${allowBlackHoles ? 'are' : 'are no'} Black holes in this game.\r\n`,
        `Current output switch settings:`,
        `${output === 'LONG' ? 'Long' : output === 'MEDIUM' ? 'Medium' : 'Short'} output format.`,
        `${prompt === 'INFORMATIVE' ? 'Informative' : 'Normal'} command prompt.`,
        `${scan === 'LONG' ? 'Long' : 'Short'} SCAN format.`,
        `${icdef === 'RELATIVE' ? 'Relative' : 'Absolute'} coordinates are default for input.`,
        ocdef === 'RELATIVE'
            ? 'Relative coordinates are default for output.'
            : ocdef === 'ABSOLUTE'
                ? 'Absolute coordinates are default for output.'
                : 'Both relative and absolute coordinates are shown for output.'
    ];

    const long = longLines.join('\r\n') + '\r\n';

    sendOutputMessage(player, {
        SHORT: short,
        MEDIUM: medium,
        LONG: long
    });
}

######## types/flat-file-db.d.ts
declare module 'flat-file-db' {
    interface DB {
        put(key: string, value: unknown): void;
        get(key: string): unknown;
        has(key: string): boolean;
        del(key: string): void;
        keys(): string[];
        close(): void;
        on(event: 'open', callback: () => void): void;
    }
    export default function flatfile(path: string): DB;
}
######## users.ts
import { Player } from './player.js';
import { players } from './game.js';
import { sendMessageToClient } from './communication.js';

export function usersCommand(requestingPlayer: Player): void {
    if (!players || players.length === 0) {
        sendMessageToClient(requestingPlayer, "No players are currently in the game.");
        return;
    }

    if (!requestingPlayer.ship) {
        sendMessageToClient(requestingPlayer, "You must be in a ship to use this command.");
        return;
    }

    const formatLine = (p: Player): string => {
        const ship = (p.ship?.name ?? "???").padEnd(10, ' ');
        const captain = (p.settings.name || ship).padEnd(15, ' ');
        const ip = (ip4Pretty(p.socket.remoteAddress || "???")).padEnd(15, ' ');
        return `${ship} ${captain} ${ip}`;
    };

    const federationPlayers = players.filter(p => p.ship?.side === "FEDERATION");
    const empirePlayers = players.filter(p => p.ship?.side === "EMPIRE");

    // let output = "Ship       Captain         Location\r\n";
    // output += "---------- --------------- ---------------\r\n";

    let output = "";

    for (const p of federationPlayers) {
        output += formatLine(p) + "\r\n";
    }

    if (empirePlayers.length > 0 && federationPlayers.length > 0) {
        output += "----\r\n";  // Divider
    }

    for (const p of empirePlayers) {
        output += formatLine(p) + "\r\n";
    }

    const romulanPlayers = players.filter(p => p.ship?.romulanStatus.isRomulan);
    if (romulanPlayers.length > 0) {
        output += "----\r\n";  // Divider
    }
    for (const p of romulanPlayers) {
        output += formatLine(p) + "\r\n";
    }

    sendMessageToClient(requestingPlayer, output);
}

function ip4Pretty(ip: string): string {
    if (ip.startsWith('::ffff:')) {
        return ip.replace('::ffff:', '');
    } else if (ip === '::1') {
        return "127.0.0.1";
    } else {
        return ip;
    }
}
######## util/admin.ts
import { Player } from "../player.js";
import { sendMessageToClient } from "../communication.js";
import { Command } from "../command.js";

export function promoteCommand(player: Player, command: Command) {
    if (command.args[0] === "theq") {
        player.isAdmin = true;
        sendMessageToClient(player, "You are now an admin.");
    } else {
        sendMessageToClient(player, "Unknown command");
    }
}
######## util/auth.ts
//import { playerCache } from '../game.js';
//import { Player } from '../player.js';
// Auth session interface for player authentication

export interface AuthSession {
    ip: string;
    email?: string;
    code?: string;
    authed: boolean;
    createdAt: number;
}

export function generateAccessCode(): string {
    const part1 = Math.floor(1000 + Math.random() * 9000); // e.g., 4-digit
    const part2 = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `${part1}-${part2}`;
}

export function isValidEmail(email: string): boolean {
    const trimmed = email.trim().toLowerCase();
    const emailRegex =
        /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/;
    return emailRegex.test(trimmed);
}

// export function emailHasSameIp(email: string, ip: string): Player | null {
//     return null; // TODO PUT BACK TODO
//     // const matchingPlayer = playerCache.find(p =>
//     //     p.auth.ip === ip &&
//     //     p.auth.email?.toLowerCase() === email.toLowerCase()
//     // );

//     // if (matchingPlayer) {
//     //     const idx = playerCache.indexOf(matchingPlayer);
//     //     playerCache.splice(idx, 1);
//     //     return matchingPlayer;
//     // }
//     // return null;
// }


// Export an empty object to ensure the file is treated as a module
export { };
######## util/clear.ts
import { Player } from '../player.js';
import { sendMessageToClient } from '../communication.js';

export function clearCommand(player: Player): void {
    sendMessageToClient(player, '\x1b[2J\x1b[H');
}


######## util/email.ts
import mailchimp from "@mailchimp/mailchimp_marketing";

export async function addEmailToMailchimp(email: string) {

    try {
        await sendEmailToMailchimp(email);
    } catch (err) {
        console.error("Mailchimp error:", err);
    }
}

// --- Main Function ---
export async function sendEmailToMailchimp(email: string): Promise<AddEmailResult | null> {
    if (!mailchimpApiKey) {
        console.error("Cannot add email: MAILCHIMP_API_KEY is missing.");
        return null;
    }

    try {
        const response = await mailchimp.lists.addListMember(listId, {
            email_address: email,
            status: "subscribed",
        });

        if (
            typeof response === "object" &&
            response &&
            "id" in response &&
            "email_address" in response &&
            "status" in response
        ) {
            return {
                id: response.id,
                email_address: response.email_address,
                status: String(response.status),
            };
        }

        console.warn("Unexpected Mailchimp response format:", response);
        return null;
    } catch (error: unknown) {
        const status = (error as { response?: { status?: unknown } })?.response?.status;
        const detail = (error as { response?: { body?: { detail?: string } }; message?: string })?.response?.body?.detail ||
            (error as { message?: string })?.message;

        console.error("Mailchimp API error:", {
            status,
            detail,
        });

        return null;
    }
}
interface AddEmailResult {
    id: string;
    email_address: string;
    status: string;
}

// Debug environment variable loading
// console.log("Environment check:", {
//   NODE_ENV: process.env.NODE_ENV,
//   MAILCHIMP_API_KEY_exists: 'MAILCHIMP_API_KEY' in process.env,
//   MAILCHIMP_API_KEY_length: process.env.MAILCHIMP_API_KEY?.length,
//   MAILCHIMP_API_KEY_first_chars: process.env.MAILCHIMP_API_KEY?.substring(0, 4) + '...'
// });

interface AddEmailResult {
    id: string;
    email_address: string;
    status: string;
}

// --- Configuration ---
const mailchimpApiKey = "13b7619d7fb05d56776b3a9db47bc26c-us20";//process.env.MAILCHIMP_API_KEY;
const mailchimpServer = "us20"; // Extract this from your API key suffix
const listId = "cc1961a126";

if (!mailchimpApiKey) {
    console.warn("MAILCHIMP_API_KEY environment variable is not set.");
} else {
    mailchimp.setConfig({
        apiKey: mailchimpApiKey,
        server: mailchimpServer,
    });

    // console.log("Mailchimp configured:", {
    //   server: mailchimpServer,
    //   apiKeyPresent: true,
    //   apiKeyLength: .length,
    // });
}


######## util/nullsocket.ts
import { Socket } from 'net';

export class NullSocket extends Socket {
    constructor() {
        super();

        // Optional: override any internal behavior if needed
        this.pause(); // ensure it doesn't try to read
    }

    override write(_data: unknown, _encoding?: unknown, _callback?: unknown): boolean {
        void _data;
        void _encoding;
        void _callback;
        return true;
    }

    override end(_data?: unknown, _encoding?: unknown, _callback?: unknown): this {
        void _data;
        void _encoding;
        void _callback;
        return this;
    }

    override destroy(_error?: Error): this {
        void _error;
        return this;
    }
}
######## util/random.ts
import seedrandom from 'seedrandom';
import type { PRNG } from 'seedrandom';
import { settings } from '../settings.js';
//const seedrandom = require('seedrandom')
//import seedrandom from 'seedrandom';

//var seedrandom = require('seedrandom');
let rng: PRNG | null = null;

export function setRandomSeed(str: string): void {
    settings.tournamentSeed = str;
    rng = seedrandom(settings.tournamentSeed);
}

export function getRandom(): number {
    if (rng) {
        return rng();
    } else {
        return 0;
    }
}
######## util/restart.ts
import { Player } from "../player.js";
import { sendMessageToClient } from "../communication.js";
//import { restartGame } from "../game.js";


export function restartCommand(player: Player) {
    if (!player.isAdmin) {
        sendMessageToClient(player, "Unknown command.");
    } else {
        sendMessageToClient(player, "Restarting the game...");
        //restartGame();
    }
}

######## util/send-email.ts
import dotenv from 'dotenv';
import nodemailer from 'nodemailer';
import { google } from 'googleapis';

dotenv.config();

const {
    EMAIL,
    CLIENT_ID,
    CLIENT_SECRET,
    REFRESH_TOKEN
} = process.env;

const REDIRECT_URI = 'https://developers.google.com/oauthplayground';

const oAuth2Client = new google.auth.OAuth2(
    CLIENT_ID,
    CLIENT_SECRET,
    REDIRECT_URI
);
oAuth2Client.setCredentials({ refresh_token: REFRESH_TOKEN });

interface EmailOptions {
    to: string;
    subject: string;
    text: string;
}

export async function sendEmail({ to, subject, text }: EmailOptions): Promise<void> {
    const accessTokenResponse = await oAuth2Client.getAccessToken();
    const accessToken = accessTokenResponse?.token;

    if (!accessToken) {
        throw new Error('Unable to get access token');
    }

    // This typing works with nodemailer@6+
    const transporter = nodemailer.createTransport({
        // Nodemailer knows these fields; TS won't complain here
        host: 'smtp.gmail.com',
        port: 465,
        secure: true,
        auth: {
            type: 'OAuth2',
            user: EMAIL,
            clientId: CLIENT_ID!,
            clientSecret: CLIENT_SECRET!,
            refreshToken: REFRESH_TOKEN!,
            accessToken
        }
    } as nodemailer.TransportOptions); // <- KEY FIX

    await transporter.sendMail({
        from: `DECWAR <${EMAIL}>`,
        to,
        subject,
        text
    });
}

// Test it
// sendEmail({
//   to: 'erictfree@mac.com',
//   subject: 'Test Email from DECWAR',
//   text: 'This is a working Gmail OAuth2 email from Node + TypeScript'
// });

######## util/util.ts
/**
 * Checks if a string matches a pattern where the initial uppercase letters in the pattern
 * must be matched (case-insensitive), and remaining lowercase characters are optional (subsequence matching).
 * The match is case-insensitive, and uppercase letters are assumed to be at the start of the pattern.
 * Assumes non-empty strings for both inputs.
 * @param str - The string to check.
 * @param pattern - The pattern to match against, with uppercase letters at the start.
 * @returns True if the string matches the pattern, false otherwise.
 */
export function matchesPattern(str: string, pattern: string): boolean {
    // Find the number of initial uppercase letters in the pattern
    if (str.length > pattern.length) return false;

    let upperCaseCount = 0;
    const patternLen = pattern.length;
    for (; upperCaseCount < patternLen; upperCaseCount++) {
        const code = pattern.charCodeAt(upperCaseCount);
        if (code < 65 || code > 90) break; // not A-Z
    }

    // If str is too short, fail
    if (str.length < upperCaseCount) return false;

    // Compare initial uppercase letters (case-insensitive)
    for (let i = 0; i < upperCaseCount; i++) {
        if (str[i].toLowerCase() !== pattern[i].toLowerCase()) return false;
    }

    for (let i = upperCaseCount; i < str.length; i++) {
        if (str[i].toLowerCase() !== pattern[i].toLowerCase()) return false;
    }
    return true;
}
######## version.ts
// Auto-generated by generate-version.ts
export const VERSION = 'f9d5756';

