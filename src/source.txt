######## activate.ts
// ACTIVATE command for pre-game lobby
import { Player } from './player.js';
import { promptForShip, promptForLevel, promptForEmail, promptForRegularOrTournament } from './pregame.js';
import { settings } from './settings.js';
import { sendGameInfo } from './pregame.js';

/**
 * Handles the ACTIVATE <ship-name> command in pre-game mode.
 */
export function activateCommand(player: Player): void {
    // if (!player.auth.authed) {
    //     promptForEmail(player, 0);
    //     //promptForLevel(player, 0);
    // } else 
    if (player.ship && player.ship.side === "NEUTRAL") {
        //promptForLevel(player, 0);
        if (settings.generated) {
            sendGameInfo(player);
            promptForLevel(player, 0);
        } else {
            promptForRegularOrTournament(player, 0);
        }
    } else {
        if (settings.generated) {
            promptForShip(player, 0);
        } else {
            promptForRegularOrTournament(player, 0);
        }
    }
}

######## api/dto.ts
// DTOs + pure mappers; import ONLY types from game
import type { Side } from "../settings.js";
import type { Player } from "../player.js";
import type { Ship } from "../ship.js";
import type { Planet } from "../planet.js";
import type { Star } from "../star.js";
import type { Blackhole } from "../blackhole.js";

export type PositionDTO = Readonly<{ v: number; h: number }>;

export type PlayerDTO = Readonly<{
    name: string;
    side: Side;
    position: PositionDTO;
    condition: string;
    docked: boolean;
    shieldsUp: boolean;
    energy: number;
    damage: number;
    shieldEnergy: number;
    torpedoes: number;
    romulan?: Readonly<{ isRomulan: boolean; isRevealed: boolean; cloaked: boolean }>;
}>;

export type PlanetDTO = Readonly<{
    name?: string;
    side: Side;
    position: PositionDTO;
    isBase: boolean;
    builds: number;
    energy: number; // for bases: 0..1000 shields; for planets: whatever you store
}>;

export type BaseDTO = Readonly<{
    side: Side;
    position: PositionDTO;
    energy: number; // 0..1000
}>;

export type StarDTO = Readonly<{
    position: PositionDTO;
}>;

export type BlackholeDTO = Readonly<{
    position: PositionDTO;
}>;

export type SummaryDTO = Readonly<{
    timestamp: number;
    counts: Readonly<{
        players: number;
        ships: number;
        planets: number;
        stars: number;
        blackholes: number;
        federationShips: number;
        empireShips: number;
        federationBases: number;
        empireBases: number;
    }>;
}>;

// ---- Mappers (pure, lint-safe) ----

export function toPlayerDTO(p: Player & { ship: Ship }): Readonly<PlayerDTO> {
    const s = p.ship;
    return Object.freeze({
        name: s.name,
        side: s.side,
        position: Object.freeze({ v: s.position.v, h: s.position.h }),
        condition: s.condition,
        docked: s.docked,
        shieldsUp: s.shieldsUp,
        energy: s.energy,
        damage: s.damage,
        shieldEnergy: s.shieldEnergy,
        torpedoes: s.torpedoes,
        romulan: s.romulanStatus
            ? Object.freeze({
                isRomulan: !!s.romulanStatus.isRomulan,
                isRevealed: !!s.romulanStatus.isRevealed,
                cloaked: !!s.romulanStatus.cloaked,
            })
            : undefined,
    });
}

export function toPlanetDTO(pl: Planet): Readonly<PlanetDTO> {
    return Object.freeze({
        name: (pl as { name?: string }).name,
        side: pl.side,
        position: Object.freeze({ v: pl.position.v, h: pl.position.h }),
        isBase: !!pl.isBase,
        builds: pl.builds,
        energy: pl.energy,
    });
}

export function toBaseDTO(pl: Planet): Readonly<BaseDTO> {
    // Caller must ensure pl.isBase === true
    return Object.freeze({
        side: pl.side,
        position: Object.freeze({ v: pl.position.v, h: pl.position.h }),
        energy: pl.energy,
    });
}

export function toStarDTO(s: Star): Readonly<StarDTO> {
    return Object.freeze({
        position: Object.freeze({ v: s.position.v, h: s.position.h }),
    });
}

export function toBlackholeDTO(b: Blackhole): Readonly<BlackholeDTO> {
    return Object.freeze({
        position: Object.freeze({ v: b.position.v, h: b.position.h }),
    });
}

export function toSummaryDTO(args: {
    players: readonly Player[];
    planets: readonly Planet[];
    stars: readonly Star[];
    blackholes: readonly Blackhole[];
    federationBases: readonly Planet[];
    empireBases: readonly Planet[];
}): Readonly<SummaryDTO> {
    const { players, planets, stars, blackholes, federationBases, empireBases } = args;

    const ships = players.filter((p): p is Player & { ship: Ship } => Boolean(p.ship));
    const federationShips = ships.filter(p => p.ship.side === "FEDERATION").length;
    const empireShips = ships.filter(p => p.ship.side === "EMPIRE").length;

    return Object.freeze({
        timestamp: Date.now(),
        counts: Object.freeze({
            players: players.length,
            ships: ships.length,
            planets: planets.length,
            stars: stars.length,
            blackholes: blackholes.length,
            federationShips,
            empireShips,
            federationBases: federationBases.length,
            empireBases: empireBases.length,
        }),
    });
}

######## api/dtoRateLimiter.ts
// src/http/dtoRateLimiter.ts
import type { Request, Response, NextFunction } from "express";

type KeyFn = (req: Request) => string;
type Options = {
    max?: number;                  // max requests allowed in window (default: 5)
    windowMs?: number;             // rolling window size in ms (default: 5000)
    key?: KeyFn;                   // bucket key function (default: req.ip)
    headerRetryAfter?: boolean;    // send Retry-After header (default: true)
    verbose?: boolean;             // console log decisions (default: true)
    cleanupAfterMs?: number;       // evict idle buckets after this idle time (default: 10 * windowMs)
};

type Bucket = number[]; // ascending timestamps (ms) of recent requests within window

export function dtoRateLimiter(opts: Options = {}) {
    const max = Math.max(1, Math.floor(opts.max ?? 5));
    const windowMs = Math.max(1, Math.floor(opts.windowMs ?? 5000));
    const keyFn: KeyFn = opts.key ?? ((req) => req.ip || "unknown");
    const verbose = opts.verbose !== false;
    const sendRetryAfter = opts.headerRetryAfter !== false;
    const cleanupAfterMs = Math.max(windowMs, Math.floor(opts.cleanupAfterMs ?? 10 * windowMs));

    const buckets = new Map<string, { q: Bucket; lastSeen: number }>();

    return function limiter(req: Request, res: Response, next: NextFunction) {
        const now = Date.now();
        const key = keyFn(req);

        const bucket = buckets.get(key) ?? { q: [], lastSeen: now };
        const q = bucket.q;

        // purge timestamps outside the rolling window
        const cutoff = now - windowMs;
        while (q.length && q[0] <= cutoff) q.shift();

        bucket.lastSeen = now;

        if (q.length < max) {
            // allow: record this request timestamp
            q.push(now);
            buckets.set(key, bucket);
            if (verbose) {
                console.log(`[DTO-RL] allow key=${key} path=${req.path} used=${q.length}/${max}`);
            }
            return next();
        }

        // deny: compute precise wait until the earliest timestamp leaves the window
        const retryInMs = Math.max(1, q[0] + windowMs - now);
        if (sendRetryAfter) {
            res.setHeader("Retry-After", String(Math.ceil(retryInMs / 1000)));
        }

        if (verbose) {
            console.warn(
                `[DTO-RL] 429 key=${key} path=${req.path} used=${q.length}/${max} waitMs=${retryInMs}`
            );
        }

        return res.status(429).json({
            error: "rate_limited",
            message: `DTO limited to ${max} requests per ${windowMs / 1000}s (sliding window).`,
            retryInMs,
        });
    };
}

// Optional: lightweight periodic cleanup (call once at startup)
export function startDtoRlCleanup(map: Map<string, { q: number[]; lastSeen: number }>, idleMs: number) {
    const interval = Math.max(10_000, Math.floor(idleMs / 2));
    return setInterval(() => {
        const now = Date.now();
        for (const [k, v] of map) {
            if (now - v.lastSeen > idleMs) map.delete(k);
        }
    }, interval);
}

######## api/events.ts
// src/api/events.ts
import type { Player } from "../player.js";
import { ran } from "../util/random.js";
import type { Planet } from "../planet.js";
import type { Side } from "../settings.js";

/* =========================
 * Public event catalog/types
 * ========================= */

export type EventType =
    // movement & combat
    | "ship_moved"
    | "phaser"
    | "torpedo"
    | "collapse_phaser"
    | "collapse_torpedo"
    | "ship_hit"
    | "ship_hull_changed"
    // planets/bases
    | "planet_hit"
    | "planet_builds_changed"
    | "planet_energy_changed"
    | "planet_captured"
    | "base_built"             // kept for back-compat with emitBaseBuilt()
    | "planet_base_created"
    | "planet_base_removed"
    | "base_destroyed"
    | "score_changed"
    // ship lifecycle
    | "ship_joined"
    | "ship_left"
    | "ship_destroyed"
    | "ship_docked"
    | "ship_undocked"
    // misc world
    | "nova_triggered"
    | "object_displaced"
    // shields (two complementary signals)
    | "shields_toggled"        // up/down + ship energy snapshot (for logs/UI)
    | "shields_changed"        // numeric pool change before/after
    // comms
    | "comms"
    // romulan
    | "romulan_spawned"
    | "romulan_cloak_toggled"
    | "romulan_moved"
    | "romulan_target_acquired"
    | "romulan_phaser"
    | "romulan_torpedo"
    | "romulan_energy_changed"
    | "romulan_destroyed"
    | "romulan_comms"
    // fallback
    | "other";

// --- simple shared shapes ---
export type GridCoord = { v: number; h: number };

export type PlanetRef = {
    name: string;
    side: Side;
    position: GridCoord;
    isBase: boolean;
    energy: number;
    builds: number;
};

export type ShipRef = { shipName: string; side: Side };

export type AttackerRef = {
    ship?: ShipRef | null;
};

// --- targeting union for weapon events ---
export type TargetRef =
    | { kind: "ship"; name: string; side: Side; position: GridCoord }
    | { kind: "base"; name: string; side: Side; position: GridCoord }
    | { kind: "planet"; name: string; side: Side; position: GridCoord }
    | { kind: "star"; position: GridCoord }
    | { kind: "blackhole"; position: GridCoord };

/* =========================
 * Event payload types
 * ========================= */

export type DockReason = "manual" | "auto" | "repair" | "resupply";
export type UndockReason = "manual" | "launch" | "forced" | "base_destroyed" | "nova" | "other" | "blackhole";

export type CommsRecipient =
    | { kind: "GLOBAL" }
    | { kind: "SIDE"; side: Side }
    | { kind: "SHIP"; shipName: string; side: Side };

export type CommsEventPayload = {
    id: string;          // server-generated id
    at: number;          // Date.now()
    from: ShipRef;       // { shipName, side }
    to: CommsRecipient;
    text: string;
};

export type NovaTriggeredPayload = {
    at: GridCoord;              // where the nova detonated
    radius: number;             // display-friendly radius
    by?: AttackerRef;           // who caused it (torp shooter)
};

export type ObjectDisplacedPayload = {
    kind: "ship" | "planet" | "base";
    name?: string;       // optional
    from: GridCoord;
    to: GridCoord;
    reason: "nova" | "blackhole" | "other";
};

export type PhaserEventPayload = {
    by: ShipRef;
    from: GridCoord;
    to: GridCoord;                 // aimed sector
    distance: number;
    energySpent: number;           // actual energy consumed
    target?: TargetRef;            // resolved target (if any)
    result: "hit" | "miss" | "no_effect" | "friendly_block" | "out_of_range" | "no_target";
    damage?: number;               // post-shield hull damage
    shieldsBefore?: number;        // target shield pool (ship/base)
    shieldsAfter?: number;
    crit?: { device?: string; amount?: number } | null;
    killed?: boolean;
};

export type TorpedoEventPayload = {
    by: ShipRef;
    from: GridCoord;
    // what the shooter asked for
    aim: GridCoord;
    // what actually happened
    collision:
    | { kind: "ship"; name: string; side: Side; position: GridCoord }
    | { kind: "base"; name: string; side: Side; position: GridCoord }
    | { kind: "planet"; name: string; side: Side; position: GridCoord }
    | { kind: "star"; position: GridCoord }
    | { kind: "blackhole"; position: GridCoord }
    | { kind: "boundary"; position: GridCoord }
    | { kind: "none" };
    result: "hit" | "deflected" | "no_effect" | "out_of_range" | "self_target" | "fizzled";
    distance?: number;             // Chebyshev distance resolved (normalized in emit)
    damage?: number;               // applied hull/base damage (normalized in emit)
    crit?: { device?: string; amount?: number } | null;
    shieldsBefore?: number;
    shieldsAfter?: number;
    killed?: boolean;
    novaTriggered?: boolean;
};

export type ShipMovedPayload = {
    shipName: string;
    side: Side;
    from: GridCoord;
    to: GridCoord;
    distance: number;   // chebyshev
    ts?: number;
    meta?: Record<string, unknown>;
};

export type ShipDockedPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;      // planet/base coords
    planet: PlanetRef;
    player: string;     // display name
    reason?: DockReason;
};

export type ShipUndockedPayload = {
    shipName: string;
    side: Side;
    from: GridCoord;    // planet/base coords
    planet: PlanetRef;
    player: string;
    reason?: UndockReason;
};

export type ShipJoinedPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    player: string;
    reason?: "assign" | "launch" | "reconnect" | "manual";
};

export type ShipLeftPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    player: string;
    reason?: "logout" | "dock" | "timeout" | "idle" | "manual" | "disconnect" | "endgame";
};

export type PlanetCapturedPayload = {
    planet: PlanetRef;
    prevSide: Side;
    nextSide: Side;
    by?: AttackerRef;
};

export type PlanetBaseRemovedReason =
    | "collapse_phaser"
    | "collapse_torpedo"
    | "base_destroyed"
    | "other";

export type PlanetBaseRemovedPayload = {
    planet: PlanetRef;
    by?: AttackerRef;
    reason?: PlanetBaseRemovedReason;
    previousSide?: Side;
};

export type ShipDestroyedPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    by?: AttackerRef;
    cause?: "combat" | "planet" | "blackhole" | "self" | "other";
};

export type WeaponKind = "phaser" | "torpedo" | "nova" | "collision" | "other";

/** Per-impact record when a ship takes damage (post-shield, hull applied) */
export type ShipHitPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    by?: AttackerRef;
    weapon: WeaponKind;
    amount: number;                 // >= 0 (rounded)
    crit?: { device?: string; amount?: number } | null;
    shieldsBefore?: number;
    shieldsAfter?: number;
    shieldsUpBefore?: boolean;
    shieldsUpAfter?: boolean;
    killed?: boolean;
};

/** Planet/base damage */
export type PlanetHitPayload = {
    planet: PlanetRef;
    weapon: WeaponKind;
    damage: number;
    destroyed?: boolean;
    by?: AttackerRef;
};

/** Numeric hull/energy deltas on a ship (coarse summary) */
export type ShipHullChangedPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    energyBefore: number;
    energyAfter: number;
    damageBefore: number;
    damageAfter: number;
    reason: WeaponKind;
    by?: AttackerRef;
};

/** Discrete shield toggle (UP/DOWN) — carries `up` and ship energy */
export type ShieldsToggledPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    up: boolean;                  // true = raised, false = lowered
    shipEnergy: number;           // after toggle
    energy?: number;              // legacy alias for loggers (same as shipEnergy)
    shieldEnergy: number;         // shield pool after toggle
    delta?: { before: number; after: number }; // optional if caller provides
};

/** Numeric shield pool change (any cause) */
export type ShieldsChangedPayload = {
    shipName: string;
    side: Side;
    at: GridCoord;
    before: number;
    after: number;
    // Compat fields for legacy loggers that expect these on shields_changed:
    up?: boolean;        // mirrors current ship.shieldsUp
    energy?: number;     // mirrors current ship.energy (post-change snapshot)
};

/* =========================
 * Canonical envelope
 * ========================= */

export type AnyEvent<T = unknown> = {
    id: number;   // monotonic id
    ts: number;   // epoch ms
    t: number;    // alias for old clients
    type: EventType;
    payload: T;
};

/* =========================
 * Event hub (buffer + SSE)
 * ========================= */

class EventHub {
    private buffer: AnyEvent[] = [];
    private subscribers = new Set<(e: AnyEvent) => void>();
    private lastId = 0;
    private readonly maxBuffer: number;

    constructor(maxBuffer: number = 5000) {
        this.maxBuffer = maxBuffer;
    }

    emit<E = unknown>(e: Omit<AnyEvent<E>, "id" | "ts" | "t"> & { type: EventType }): AnyEvent<E> {
        const now = Date.now();
        const evt: AnyEvent<E> = { ...e, id: ++this.lastId, ts: now, t: now };
        this.buffer.push(evt);
        if (this.buffer.length > this.maxBuffer) this.buffer.shift();
        for (const cb of this.subscribers) cb(evt);
        return evt;
    }

    /** Subscribe; returns an unsubscribe function */
    subscribe(cb: (e: AnyEvent) => void): () => void {
        this.subscribers.add(cb);
        return () => this.subscribers.delete(cb);
    }

    /** Return events since id (exclusive). Optionally filter by types. */
    getSince(since?: number, types?: EventType[]): AnyEvent[] {
        const startIdx =
            since && Number.isFinite(since)
                ? Math.max(0, this.buffer.findIndex((e) => e.id > (since as number)))
                : 0;
        const sliced = this.buffer.slice(startIdx);
        if (!types || types.length === 0) return sliced;
        const set = new Set(types);
        return sliced.filter((e) => set.has(e.type));
    }

    /** Latest id in the buffer (0 if empty) */
    latestId(): number {
        return this.buffer.at(-1)?.id ?? 0;
    }
}

/** Singleton used across the server/game code */
export const gameEvents = new EventHub();

/* =========================
 * Emit helpers
 * ========================= */

export function planetRef(p: Planet): PlanetRef {
    return {
        name: p.name,
        side: p.side,
        position: { v: p.position.v, h: p.position.h },
        isBase: !!p.isBase,
        energy: p.energy ?? 0,
        builds: p.builds ?? 0,
    };
}

function shipRef(player: Player | null | undefined): ShipRef | undefined {
    if (!player?.ship) return undefined;
    return { shipName: player.ship.name, side: player.ship.side };
}

export function attackerRef(by?: Player | null): AttackerRef | undefined {
    const s = shipRef(by ?? undefined);
    if (!s) return undefined;
    return { ship: s };
}

function displayName(player: Player): string {
    const n = player.settings?.name ?? player.ship?.name ?? "unknown";
    return typeof n === "string" && n.trim().length > 0 ? n : "unknown";
}

export function emitBaseBuilt(planet: Planet, by?: Player | null) {
    return gameEvents.emit({
        type: "base_built",
        payload: { planet: planetRef(planet), by: attackerRef(by) },
    });
}

export function emitPlanetCaptured(planet: Planet, prevSide: Side, nextSide: Side, by?: Player | null) {
    return gameEvents.emit<PlanetCapturedPayload>({
        type: "planet_captured",
        payload: { planet: planetRef(planet), prevSide, nextSide, by: attackerRef(by) },
    });
}

// ship lifecycle
export function emitShipJoined(player: Player, reason: ShipJoinedPayload["reason"] = "assign") {
    if (!player.ship) return;
    return gameEvents.emit<ShipJoinedPayload>({
        type: "ship_joined",
        payload: {
            shipName: player.ship.name,
            side: player.ship.side,
            at: player.ship.position,
            player: displayName(player),
            reason,
        },
    });
}

export function emitShipLeft(player: Player, reason: ShipLeftPayload["reason"] = "logout") {
    if (!player.ship) return;
    return gameEvents.emit<ShipLeftPayload>({
        type: "ship_left",
        payload: {
            shipName: player.ship.name,
            side: player.ship.side,
            at: player.ship.position,
            player: displayName(player),
            reason,
        },
    });
}

export function emitShipDestroyed(
    shipName: string,
    side: Side,
    at: GridCoord,
    by?: AttackerRef,
    cause: ShipDestroyedPayload["cause"] = "combat",
) {
    return gameEvents.emit<ShipDestroyedPayload>({
        type: "ship_destroyed",
        payload: { shipName, side, at, by, cause },
    });
}

// docking
export function emitShipDocked(player: Player, planet: Planet, reason: DockReason = "manual") {
    if (!player.ship) return;
    return gameEvents.emit<ShipDockedPayload>({
        type: "ship_docked",
        payload: {
            shipName: player.ship.name,
            side: player.ship.side,
            at: { ...planet.position },
            planet: planetRef(planet),
            player: displayName(player),
            reason,
        },
    });
}

export function emitShipUndocked(player: Player, planet: Planet, reason: UndockReason = "manual") {
    if (!player.ship) return;
    return gameEvents.emit<ShipUndockedPayload>({
        type: "ship_undocked",
        payload: {
            shipName: player.ship.name,
            side: player.ship.side,
            from: { ...planet.position },
            planet: planetRef(planet),
            player: displayName(player),
            reason,
        },
    });
}

// generic displacement
export function emitObjectDisplaced(
    kind: ObjectDisplacedPayload["kind"],
    name: string | undefined,
    from: GridCoord,
    to: GridCoord,
    reason: ObjectDisplacedPayload["reason"] = "nova"
) {
    return gameEvents.emit<ObjectDisplacedPayload>({
        type: "object_displaced",
        payload: { kind, name, from, to, reason },
    });
}

// combat emitters
export function emitPhaserEvent(payload: PhaserEventPayload) {
    return gameEvents.emit<PhaserEventPayload>({ type: "phaser", payload });
}

export function emitTorpedoEvent(payload: TorpedoEventPayload) {
    // --- normalize so loggers never see undefined ---
    // Compute end position for distance: prefer collision.position, else aim
    const from = payload.from;
    const endPos =
        (payload as any)?.collision?.position
            ? (payload as any).collision.position as GridCoord
            : payload.aim;

    // Chebyshev distance (no import to avoid cycles)
    const dv = Math.abs((endPos?.v ?? from.v) - from.v);
    const dh = Math.abs((endPos?.h ?? from.h) - from.h);
    const distance = Math.max(0, Math.round(payload.distance ?? Math.max(dv, dh)));

    const damage = Math.max(0, Math.round(payload.damage ?? 0));

    // Derive a sensible result if missing
    let result = payload.result;
    if (!result) {
        const k = (payload as any)?.collision?.kind;
        if (k === "boundary") result = "out_of_range";
        else if (k === "none") result = "fizzled";
        else if (damage > 0) result = "hit";
        else result = "no_effect";
    }

    return gameEvents.emit<TorpedoEventPayload>({
        type: "torpedo",
        payload: { ...payload, distance, damage, result },
    });
}


// nova
// If you have a canonical radius constant, import and use it.
// import { NOVA_RADIUS } from "../settings.js";
export function emitNovaTriggered(at: GridCoord, by?: Player | null, radius: number = 5) {
    return gameEvents.emit<NovaTriggeredPayload>({
        type: "nova_triggered",
        payload: { at, radius, by: attackerRef(by ?? undefined) },
    });
}

// shields
export function emitShieldsToggled(
    player: Player,
    up: boolean,
    delta?: { before: number; after: number }
) {
    if (!player.ship) return;
    const shipEnergy = player.ship.energy ?? 0;
    return gameEvents.emit<ShieldsToggledPayload>({
        type: "shields_toggled",
        payload: {
            shipName: player.ship.name,
            side: player.ship.side,
            at: { v: player.ship.position.v, h: player.ship.position.h },
            up,
            shipEnergy,
            energy: shipEnergy, // legacy alias – keeps existing logs happy
            shieldEnergy: player.ship.shieldEnergy,
            ...(delta ? { delta } : {}),
        },
    });
}

export function emitShieldsChanged(p: Player, before: number, after: number) {
    if (!p.ship) return;
    if (before === after) return;
    return gameEvents.emit<ShieldsChangedPayload>({
        type: "shields_changed",
        payload: {
            shipName: p.ship.name,
            side: p.ship.side,
            at: { v: p.ship.position.v, h: p.ship.position.h },
            before,
            after,
            // fill compat fields so loggers never see `undefined`
            up: p.ship.shieldsUp === true,
            energy: p.ship.energy ?? 0,
        },
    });
}

// damage summaries
export function emitShipHit(
    target: Player,
    weapon: WeaponKind,
    amount: number,
    opts?: {
        by?: Player | null;
        crit?: { device?: string; amount?: number } | null;
        shieldsBefore?: number;
        shieldsAfter?: number;
        shieldsUpBefore?: boolean;
        shieldsUpAfter?: boolean;
        killed?: boolean;
    }
) {
    if (!target.ship) return;
    const {
        by = undefined,
        crit = null,
        shieldsBefore,
        shieldsAfter,
        shieldsUpBefore,
        shieldsUpAfter,
        killed,
    } = opts || {};
    return gameEvents.emit<ShipHitPayload>({
        type: "ship_hit",
        payload: {
            shipName: target.ship.name,
            side: target.ship.side,
            at: { ...target.ship.position },
            by: attackerRef(by),
            weapon,
            amount: Math.max(0, Math.round(amount)),
            crit,
            shieldsBefore,
            shieldsAfter,
            shieldsUpBefore,
            shieldsUpAfter,
            killed: !!killed,
        },
    });
}

export function emitShipHullChanged(
    victim: Player,
    energyBefore: number,
    energyAfter: number,
    damageBefore: number,
    damageAfter: number,
    reason: ShipHullChangedPayload["reason"],
    byPlayer?: Player | null
) {
    if (!victim.ship) return;
    return gameEvents.emit<ShipHullChangedPayload>({
        type: "ship_hull_changed",
        payload: {
            shipName: victim.ship.name,
            side: victim.ship.side,
            at: { v: victim.ship.position.v, h: victim.ship.position.h },
            energyBefore,
            energyAfter,
            damageBefore,
            damageAfter,
            reason,
            by: attackerRef(byPlayer),
        },
    });
}

export function emitPlanetHit(
    planet: Planet,
    weapon: WeaponKind,
    damage: number,
    destroyed?: boolean,
    by?: Player | null
) {
    return gameEvents.emit<PlanetHitPayload>({
        type: "planet_hit",
        payload: {
            planet: planetRef(planet),
            weapon,
            damage: Math.max(0, Math.round(damage)),
            destroyed: !!destroyed,
            by: attackerRef(by),
        },
    });
}

export function emitPlanetBaseRemoved(
    planet: Planet,
    reason: PlanetBaseRemovedReason = "other",
    by?: Player | null,
    previousSide?: Side
) {
    return gameEvents.emit<PlanetBaseRemovedPayload>({
        type: "planet_base_removed",
        payload: {
            planet: planetRef(planet),
            by: attackerRef(by),
            reason,
            previousSide,
        },
    });
}

/* =========================
 * Comms
 * ========================= */

const msgId = () => ran().toString(36).slice(2) + Date.now().toString(36);

export function emitComms(from: Player, to: CommsRecipient, text: string) {
    if (!from.ship) return;
    gameEvents.emit<CommsEventPayload>({
        type: "comms",
        payload: {
            id: msgId(),
            at: Date.now(),
            from: { shipName: from.ship.name, side: from.ship.side },
            to,
            text,
        },
    });
}

export function emitCommsSent(from: Player, to: CommsRecipient, text: string, id?: string): void {
    if (!from.ship) return;
    const payload: CommsEventPayload = {
        id: id ?? msgId(),
        at: Date.now(),
        from: { shipName: from.ship.name, side: from.ship.side },
        to,
        text,
    };
    gameEvents.emit({ type: "comms", payload });
}

/* =========================
 * Romulan
 * ========================= */

export type RomulanSpawnedPayload = { at: GridCoord; erom: number };
export type RomulanCloakToggledPayload = { at: GridCoord; cloaked: boolean };
export type RomulanMovedPayload = { from: GridCoord; to: GridCoord; distance: number };
export type RomulanTargetAcquiredPayload = { target: TargetRef; distance: number };
export type RomulanWeaponPayload = { from: GridCoord; to: GridCoord; distance: number; damage?: number };
export type RomulanEnergyChangedPayload = { before: number; after: number; reason: "phaser_hit" | "torpedo_hit" | "other" };
export type RomulanDestroyedPayload = { at: GridCoord; by?: AttackerRef };

export const emitRomulanSpawned = (at: GridCoord, erom: number) =>
    gameEvents.emit<RomulanSpawnedPayload>({ type: "romulan_spawned", payload: { at, erom } });

export const emitRomulanCloakToggled = (at: GridCoord, cloaked: boolean) =>
    gameEvents.emit<RomulanCloakToggledPayload>({ type: "romulan_cloak_toggled", payload: { at, cloaked } });

export const emitRomulanMoved = (from: GridCoord, to: GridCoord, distance: number) =>
    gameEvents.emit<RomulanMovedPayload>({ type: "romulan_moved", payload: { from, to, distance } });

export const emitRomulanTarget = (target: TargetRef, distance: number) =>
    gameEvents.emit<RomulanTargetAcquiredPayload>({ type: "romulan_target_acquired", payload: { target, distance } });

export const emitRomulanPhaser = (p: RomulanWeaponPayload) =>
    gameEvents.emit<RomulanWeaponPayload>({ type: "romulan_phaser", payload: p });

export const emitRomulanTorpedo = (p: RomulanWeaponPayload) =>
    gameEvents.emit<RomulanWeaponPayload>({ type: "romulan_torpedo", payload: p });

export const emitRomulanEnergyChanged = (before: number, after: number, reason: RomulanEnergyChangedPayload["reason"]) =>
    gameEvents.emit<RomulanEnergyChangedPayload>({ type: "romulan_energy_changed", payload: { before, after, reason } });

export const emitRomulanDestroyed = (at: GridCoord, by?: AttackerRef) =>
    gameEvents.emit<RomulanDestroyedPayload>({ type: "romulan_destroyed", payload: { at, by } });

export const emitRomulanComms = (text: string, at: GridCoord) =>
    gameEvents.emit<{ at: GridCoord; text: string }>({ type: "romulan_comms", payload: { at, text } });

######## api/pagination.ts
// Tiny, lint-safe pagination helper

export type PageParams = Readonly<{
    page?: number;      // 1-based
    pageSize?: number;  // max items per page
    maxPageSize?: number; // enforcement cap
}>;

export type PageResult<T> = Readonly<{
    page: number;
    pageSize: number;
    total: number;
    items: readonly T[];
}>;

export function paginate<T>(
    source: readonly T[],
    params: PageParams = {}
): PageResult<T> {
    const total = source.length;
    const maxPageSize = Math.max(1, params.maxPageSize ?? 500);
    const pageSize = Math.min(Math.max(1, params.pageSize ?? 50), maxPageSize);
    const page = Math.max(1, params.page ?? 1);

    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    const items = source.slice(start, end);

    return { page, pageSize, total, items };
}

######## api/provider.ts
// Read-only provider interface the API consumes (no game imports here)
import type {
    SummaryDTO,
    PlayerDTO,
    PlanetDTO,
    StarDTO,
    BlackholeDTO,
    BaseDTO,
} from "./dto.js";

export interface GameStateProvider {
    getSummary(): Readonly<SummaryDTO>;
    listPlayers(): readonly Readonly<PlayerDTO>[];
    listPlanets(): readonly Readonly<PlanetDTO>[];
    listStars(): readonly Readonly<StarDTO>[];
    listBlackholes(): readonly Readonly<BlackholeDTO>[];
    listBases(): readonly Readonly<BaseDTO>[];
}

######## api/server.ts
// src/api/server.ts
import express, { type Request, type Response } from "express";
import cors from "cors";

import type { GameStateProvider } from "./provider.js";
import { gameEvents, type EventType } from "./events.js";
import { paginate } from "./pagination.js";
import { sseRouter } from "./sse.js";
import { dtoRateLimiter } from "./dtoRateLimiter.js";

/**
 * Start the read-only API server with a provider injected from the game process.
 * The API stays decoupled from game internals (no game imports here, only the event hub).
 */
export function startApiServer(provider: GameStateProvider, opts?: { port?: number }) {
    const app = express();

    // Ensure per-IP works behind proxies/load balancers
    app.set("trust proxy", true);

    app.use(cors());
    app.use(express.json());

    // Strict sliding window limiter:
    // <= 5 requests in any rolling 5-second period per client
    const dtoLimiter = dtoRateLimiter({ max: 5, windowMs: 5000, verbose: true });

    // ---- basic state endpoints ----
    app.get("/api/health", (_req: Request, res: Response) => {
        res.json({ ok: true });
    });

    // DTO endpoints (limited)
    app.get("/api/summary", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.getSummary());
    });

    app.get("/api/players", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.listPlayers());
    });

    app.get("/api/planets", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.listPlanets());
    });

    app.get("/api/stars", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.listStars());
    });

    app.get("/api/blackholes", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.listBlackholes());
    });

    app.get("/api/bases", dtoLimiter, (_req: Request, res: Response) => {
        res.json(provider.listBases());
    });

    /* -------------------------
     * LIVE EVENTS (SSE + snapshot)
     * ------------------------- */

    // Events API (limited):
    // - GET /api/events        (SSE stream)
    // - GET /api/events/snapshot
    // Apply limiter to the router so SSE connection attempts are limited too.
    app.use("/api", dtoLimiter, sseRouter);

    // GET /api/events/snapshot
    //   ?types=phaser,torpedo            (optional filter)
    //   ?since=1234                      (optional catch-up id)
    //   ?page=1&pageSize=200             (optional pagination)
    app.get("/api/events/snapshot", dtoLimiter, (req: Request, res: Response) => {
        const sinceRaw = req.query.since as string | undefined;
        const sinceNum = sinceRaw ? Number(sinceRaw) : undefined;
        const since = Number.isFinite(sinceNum!) ? (sinceNum as number) : undefined;

        const typesRaw = (req.query.types as string | undefined) ?? "";
        const typesArr = typesRaw
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean) as EventType[];

        // pagination with sane bounds
        const pageRaw = req.query.page as string | undefined;
        const pageSizeRaw = req.query.pageSize as string | undefined;
        const page = Math.max(1, Number.isFinite(Number(pageRaw)) ? Number(pageRaw) : 1);
        const requestedPageSize = Number.isFinite(Number(pageSizeRaw)) ? Number(pageSizeRaw) : 100;
        const pageSize = Math.min(Math.max(1, requestedPageSize), 1000);

        const events = gameEvents.getSince(
            since,
            typesArr.length ? typesArr : undefined
        );

        // latest id from entire buffer (prefer helper if present)
        const globalLatest = gameEvents.latestId();

        const result = paginate(events, { page, pageSize, maxPageSize: 1000 });

        res.json({
            latest: globalLatest,
            count: result.total,
            page: result.page,
            pageSize: result.pageSize,
            events: result.items,
        });
    });

    const port = Number(process.env.API_PORT ?? opts?.port ?? 3001);
    return app.listen(port, () => {
        console.log(`[api] listening on http://localhost:${port} (DTO RL: ≤5 req / 5s, sliding)`);
    });
}

######## api/sse.ts
// src/api/sse.ts
import { Router, type Request, type Response } from "express";
import { gameEvents, type AnyEvent } from "./events.js";

export const sseRouter = Router();

/**
 * GET /api/events
 *  - Live SSE stream.
 *  - Supports Last-Event-ID header or ?since=<id>
 *  - Filter by ?types=phaser,torpedo,planet_captured
 */
sseRouter.get("/events", (req: Request, res: Response) => {
    // NOTE: CORS should be enabled in server.ts. We only set SSE-specific headers here.
    res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
    res.setHeader("Cache-Control", "no-cache, no-transform");
    res.setHeader("Connection", "keep-alive");

    // Some proxies need an immediate flush to start streaming
    res.flushHeaders?.();

    // Tell the client how long to wait before retrying the connection (ms)
    res.write(`retry: 5000\n\n`);

    // Determine starting point (either ?since= or Last-Event-ID)
    const sinceParam = req.query.since ? Number(req.query.since) : undefined;
    const lastIdHeader = req.header("Last-Event-ID");
    const since = Number.isFinite(sinceParam)
        ? sinceParam
        : lastIdHeader
            ? Number(lastIdHeader)
            : undefined;

    // Optional type filter: ?types=foo,bar
    const typesParam = typeof req.query.types === "string" ? req.query.types : undefined;
    const types = typesParam
        ? (typesParam.split(",").map((s) => s.trim()).filter(Boolean) as Array<AnyEvent["type"]>)
        : undefined;
    const typeSet = types ? new Set(types) : undefined;

    // 1) Send backlog to catch up
    const backlog = gameEvents.getSince(since, types);
    for (const e of backlog) writeEvent(res, e);

    // 2) Subscribe to live events (explicit param typing to avoid TS7006)
    const sub = gameEvents.subscribe((e: AnyEvent) => {
        if (typeSet && !typeSet.has(e.type)) return;
        writeEvent(res, e);
    });

    // 3) Keepalive comments (helps load balancers / proxies)
    const ping = setInterval(() => {
        res.write(`: ping ${Date.now()}\n\n`);
    }, 25_000);

    // 4) Cleanup on disconnect
    const cleanup = () => {
        clearInterval(ping);
        sub(); // unsubscribe
        try {
            res.end();
        } catch {
            /* noop */
        }
    };

    req.on("close", cleanup);
    req.on("aborted", cleanup);
});

function writeEvent(res: Response, e: AnyEvent): void {
    res.write(`id: ${e.id}\n`);
    res.write(`event: ${String(e.type)}\n`);
    res.write(`data: ${JSON.stringify(e)}\n\n`);
}

######## bases.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";

export function basesCommand(player: Player, command: Command): void {
    const newArgs = ["BASES", ...command.args];
    listCommand(player, { ...command, args: newArgs });
}

######## blackhole.ts
import { findObjectAtPosition, Position } from './coords.js';
import { GRID_HEIGHT, GRID_WIDTH } from './settings.js';
import { blackholes } from './game.js';
import { getRandom } from './util/random.js';


export class Blackhole {
    position: Position;

    constructor(v: number, h: number) {
        this.position = { v, h };
    }

    static generate(count: number = 10): Blackhole[] {
        let attempts = 0;

        while (blackholes.length < count && attempts < 1000) {
            const v = Math.floor(getRandom() * GRID_HEIGHT) + 1;
            const h = Math.floor(getRandom() * GRID_WIDTH) + 1;

            if (!findObjectAtPosition(v, h)) {
                blackholes.push(new Blackhole(v, h));
            }

            attempts++;
        }
        return blackholes;
    }
}



######## bots/general.ts
// src/bots/general.ts
// Command-line bot: composes player commands and queues them via the dispatcher.

import { Player } from "../player.js";
import { NullSocket } from "../util/nullsocket.js";
import { GRID_HEIGHT, GRID_WIDTH, MAX_SHIELD_ENERGY } from "../settings.js";
import { players, bases } from "../game.js";
import { ran, iran } from "../util/random.js";
import { getAvailableShips } from "../pregame.js";
import { Planet } from "../planet.js";
import { chebyshev, findEmptyLocation } from "../coords.js";
import { queueCommands } from "../command.js"; // <- all actions go through here

// ===== Tuning ===============================================================
type Side = "FEDERATION" | "EMPIRE";

const KRANGE = 20;            // search/engage window (Chebyshev)
const CLOSE_RANGE = 6;        // inside this, start firing
const MOVE_MAX_STEP = 5;      // cap each MOVE to Chebyshev <= 5 (user asked: < 6)
const PHA_COOLDOWN_MS = 1200; // pacing so we don’t spam
const TORP_COOLDOWN_MS = 2000;
const FIRE_BIAS = 0.55;       // prefer phasers when both ready
// ===========================================================================

// Per-bot cooldowns
const phaUntil = new WeakMap<Player, number>();
const torpUntil = new WeakMap<Player, number>();
const nextChatterAt = new WeakMap<Player, number>(); // chatter rate-limiter

function tagAsBot(p: Player): void {
    (p as any).__cmdBot = true;
    if (p.ship) p.ship.romulanStatus = { isRomulan: false, isRevealed: true, cloaked: false };
    const now = Date.now();
    phaUntil.set(p, now + 500);
    torpUntil.set(p, now + 1000);
    nextChatterAt.set(p, now + 3000);
}

export function isBotPlayer(p: Player): boolean {
    if ((p as any).__cmdBot === true) return true;
    const n = p.settings.name ?? "";
    return /^BOT-/.test(n);
}

export function spawnSideBot(side: Side, name = `BOT-${side[0]}${iran(1000)}`): Player | null {
    // Abort early if no ship names are available for this side.
    const available = getAvailableShips(side);
    if (available.length === 0) return null;

    const pl = new Player(new NullSocket());
    pl.settings.name = name;
    (pl.settings as any).location = "virtual";
    (pl.settings as any).ip = "virtual";
    (pl.settings as any).userAgent = "virtual-bot";
    if (!pl.ship) return null;

    pl.ship.side = side;
    pl.ship.romulanStatus = { isRomulan: false, isRevealed: true, cloaked: false };
    pl.ship.energy = 5000;
    pl.ship.shieldEnergy = 500;
    pl.ship.damage = 0;

    // Assign a real, unused ship name, chosen at random from the available list.
    if (!pl.ship.name || /^NEUTRAL$/i.test(pl.ship.name)) {
        const pick = available[iran(available.length)];
        pl.ship.name = pick;
    }

    const pos = findEmptyLocation();
    if (!pos) return null;
    pl.ship.position = pos;

    players.push(pl);
    tagAsBot(pl);
    return pl;
}

// Keep a global pool of N bots alive, alternating sides for balance.
export function ensureBots(desiredTotal: number): void {
    const live = players.filter(p => p.ship && isBotPlayer(p));
    let need = desiredTotal - live.length;
    if (need <= 0) return;

    // Track counts live and as we spawn.
    let fed = players.filter(p => p.ship && isBotPlayer(p) && p.ship!.side === "FEDERATION").length;
    let emp = players.filter(p => p.ship && isBotPlayer(p) && p.ship!.side === "EMPIRE").length;

    // Try to spawn until we reach desiredTotal or run out of ship names.
    while (need > 0) {
        // Randomize selection order each pass.
        const order: Side[] = ran() < 0.5 ? ["FEDERATION", "EMPIRE"] : ["EMPIRE", "FEDERATION"];
        let spawned = false;

        for (const side of order) {
            // Skip if no ships left for this side.
            if (getAvailableShips(side).length === 0) continue;

            const name = `BOT-${side[0]}${iran(10000)}`;
            const p = spawnSideBot(side, name);
            if (p && p.ship) {
                if (side === "FEDERATION") fed++; else emp++;
                need--;
                spawned = true;
                break; // one at a time
            }
        }

        // If we couldn't spawn on either side (no ships left), abort.
        if (!spawned) break;
    }
}

// Drive every bot each sweep
export function updateSideBots(): void {
    for (const bot of players) {
        if (!bot.ship) continue;
        if (!isBotPlayer(bot)) continue;
        driveBot(bot);
    }
}

// ===== Core AI ==============================================================
type Target =
    | { kind: "ship"; player: Player; distance: number }
    | { kind: "base"; planet: Planet; distance: number };

function driveBot(bot: Player): void {
    if (!bot.ship) return;

    // light captain chatter at roughly the same cadence as Romulan speech
    maybeChatter(bot);

    const target = findClosestTarget(bot);
    if (!target) {
        randomWander(bot);
        return;
    }

    const tpos = target.kind === "ship" ? target.player.ship!.position : target.planet.position;
    const dist = chebyshev(bot.ship.position, tpos);

    if (dist > CLOSE_RANGE) {
        moveToward(bot, tpos);
        return;
    }

    // Cooldown gating
    const now = Date.now();
    const phaReady = now >= (phaUntil.get(bot) ?? 0);
    const torpReady = now >= (torpUntil.get(bot) ?? 0);

    if (!phaReady && !torpReady) return;

    // Choose weapon (both paths emit real commands)
    if (phaReady && torpReady) {
        if (ran() < FIRE_BIAS) firePhasers(bot, target);
        else fireTorpedo(bot, target);
    } else if (phaReady) {
        firePhasers(bot, target);
    } else {
        fireTorpedo(bot, target);
    }
}

function findClosestTarget(bot: Player): Target | null {
    if (!bot.ship) return null;
    const pos = bot.ship.position;
    const enemySide: Side = bot.ship.side === "FEDERATION" ? "EMPIRE" : "FEDERATION";

    let best: Target | null = null;

    // Prefer enemy ships
    for (const p of players) {
        if (!p.ship || p === bot) continue;
        if (p.ship.side !== enemySide) continue;
        const d = chebyshev(p.ship.position, pos);
        if (d > KRANGE) continue;
        if (!best || d < best.distance) best = { kind: "ship", player: p, distance: d };
    }

    // Then enemy bases
    const list = enemySide === "FEDERATION" ? bases.federation : bases.empire;
    for (const base of list) {
        const d = chebyshev(base.position, pos);
        if (d > KRANGE) continue;
        if (!best || d < best.distance) best = { kind: "base", planet: base, distance: d };
    }

    return best;
}

// ===== Chatter ==============================================================
function maybeChatter(bot: Player): void {
    if (!bot.ship) return;
    const now = Date.now();
    const notBefore = nextChatterAt.get(bot) ?? 0;
    // ~10% chance when allowed, then cooldown 8–15s
    if (now < notBefore || ran() > 0.10) return;

    // pick audience: 60% SIDE, 30% ALL, 10% single friendly ship
    const roll = ran();
    let audience = "ALL";
    if (roll < 0.60) {
        audience = bot.ship.side; // tell your own side
    } else if (roll < 0.90) {
        audience = "ALL";
    } else {
        const friend = players.find(p => p !== bot && p.ship && p.ship.side === bot.ship!.side);
        audience = friend?.ship?.name ?? bot.ship.side;
    }

    const line = generateCaptainLine(bot);
    // TELL <audience>; message
    queueCommands(bot, `TELL ${audience}; ${line}`);
    // set next window
    nextChatterAt.set(bot, now + (8000 + iran(7000)));
}

function generateCaptainLine(bot: Player): string {
    if (!bot.ship) return "Standing by.";
    const { position, shieldEnergy, name } = bot.ship;
    const shieldPct = Math.max(0, Math.min(100, Math.round((shieldEnergy / Math.max(1, MAX_SHIELD_ENERGY)) * 100)));
    const here = `${position.v}-${position.h}`;

    const setA = [
        `Eyes up—contact near ${here}.`,
        `Moving to intercept at ${here}.`,
        `Phasers hot, targeting now.`,
        `Tube one ready—launching soon.`,
        `Shields holding at ${shieldPct}%.`,
        `Requesting cover at ${here}.`,
        `Plotting a short hop toward target.`,
        `We have them on scopes, closing.`,
        `All hands, stand by for maneuvers.`,
        `${name} on station at ${here}.`,
    ];
    return setA[iran(setA.length)];
}

// ===== Helper: clamp a relative vector to Chebyshev <= maxStep ==============
function clampChebyshev(dv: number, dh: number, maxStep = MOVE_MAX_STEP): [number, number] {
    const mag = Math.max(Math.abs(dv), Math.abs(dh));
    if (mag <= maxStep) return [dv, dh];
    const scale = maxStep / mag;
    // round toward zero to avoid overshoot; ensure not both zero
    let rv = Math.trunc(dv * scale);
    let rh = Math.trunc(dh * scale);
    if (rv === 0 && dv !== 0) rv = Math.sign(dv);
    if (rh === 0 && dh !== 0) rh = Math.sign(dh);
    // after rounding, still guarantee Chebyshev <= maxStep
    const clamp = (n: number) => Math.max(-maxStep, Math.min(maxStep, n));
    rv = clamp(rv); rh = clamp(rh);
    return [rv, rh];
}

// ===== Issue real commands ==================================================

// Movement: use MOVE in RELATIVE mode; each command keeps Chebyshev <= 5.
function moveToward(bot: Player, targetPos: { v: number; h: number }): void {
    if (!bot.ship) return;
    const from = bot.ship.position;
    const dv = targetPos.v - from.v;
    const dh = targetPos.h - from.h;

    const [rv, rh] = clampChebyshev(dv, dh, MOVE_MAX_STEP);

    // Bound to grid in case the command parser doesn’t; parser will also validate.
    const toV = Math.max(1, Math.min(GRID_HEIGHT, from.v + rv));
    const toH = Math.max(1, Math.min(GRID_WIDTH, from.h + rh));
    const rvBound = toV - from.v;
    const rhBound = toH - from.h;

    // Queue: MOVE R <rv> <rh>
    queueCommands(bot, `MOVE R ${rvBound} ${rhBound}`);
}

function firePhasers(bot: Player, target: Target): void {
    if (!bot.ship) return;
    const from = bot.ship.position;
    const tpos = target.kind === "ship" ? target.player.ship!.position : target.planet.position;

    // RELATIVE offsets, clamped to phaser max range in the command layer (we still clamp to 10)
    const rv = Math.max(-10, Math.min(10, tpos.v - from.v));
    const rh = Math.max(-10, Math.min(10, tpos.h - from.h));

    // Default energy (200) chosen by the command itself.
    // Command: PH R <rv> <rh>
    queueCommands(bot, `PH R ${rv} ${rh}`);

    phaUntil.set(bot, Date.now() + PHA_COOLDOWN_MS);
}

function fireTorpedo(bot: Player, target: Target): void {
    if (!bot.ship) return;
    const from = bot.ship.position;
    const tpos = target.kind === "ship" ? target.player.ship!.position : target.planet.position;

    // RELATIVE offsets for torpedo; one tube
    const rv = tpos.v - from.v;
    const rh = tpos.h - from.h;

    // Command: TO R 1 <rv> <rh>
    queueCommands(bot, `TO R 1 ${rv} ${rh}`);

    torpUntil.set(bot, Date.now() + TORP_COOLDOWN_MS);
}

// ===== Fallback if no targets: small MOVE R jitter ==========================
function randomWander(bot: Player): void {
    if (!bot.ship) return;

    // pick a random Chebyshev step size 1..MOVE_MAX_STEP and move in that square
    const step = 1 + iran(MOVE_MAX_STEP); // 1..5

    // random offsets in [-step, step], with a non-zero displacement
    let dv = iran(2 * step + 1) - step;
    let dh = iran(2 * step + 1) - step;
    if (dv === 0 && dh === 0) dv = 1; // ensure some movement

    // clamp to board and re-derive the actually valid offsets
    const from = bot.ship.position;
    const toV = Math.max(1, Math.min(GRID_HEIGHT, from.v + dv));
    const toH = Math.max(1, Math.min(GRID_WIDTH, from.h + dh));
    const rv = toV - from.v;
    const rh = toH - from.h;

    if (rv !== 0 || rh !== 0) {
        // Single MOVE command with Chebyshev distance ≤ step (≤ MOVE_MAX_STEP)
        queueCommands(bot, `MOVE R ${rv} ${rh}`);
    }
}

######## build.ts
import { getCoordsFromCommandArgs, chebyshev, ocdefCoords } from "./coords.js";
import { ran } from "./util/random.js";
import { planets, bases } from "./game.js";
import {
    MAX_BUILDS_PER_PLANET,
    BUILD_DELAY_MIN_MS,
    BUILD_DELAY_RANGE,
    MAX_BASES_PER_TEAM,
} from "./settings.js";
import {
    putClientOnHold,
    releaseClient,
    sendOutputMessage,
    sendMessageToClient,
} from "./communication.js";
import { Player } from "./player.js";
import { Command } from "./command.js";

// NEW: make sure these are exported from your events module per our earlier patch
import { gameEvents, planetRef, attackerRef } from "./api/events.js";

export function buildCommand(player: Player, command: Command, done?: () => void): void {
    // ---- quick argument / state checks ----
    if (command.args.length < 2) {
        sendMessageToClient(
            player,
            "Usage: BUILD [A|R] <vpos> <hpos> — specify vertical and horizontal coordinates."
        );
        done?.();
        return;
    }
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to build.");
        done?.();
        return;
    }

    const {
        position: { v: targetV, h: targetH },
        mode,
        error,
    } = getCoordsFromCommandArgs(
        player,
        command.args,
        player.ship.position.v,
        player.ship.position.h,
        false
    );

    if (error) {
        sendMessageToClient(player, `${error} for mode ${mode}`);
        done?.();
        return;
    }

    // must be adjacent to the target planet
    if (chebyshev(player.ship.position, { v: targetV, h: targetH }) > 1) {
        sendMessageToClient(
            player,
            "BUILD failed: you must be adjacent (1 grid unit) to the target planet."
        );
        done?.();
        return;
    }

    const planet = planets.find((p) => p.position.h === targetH && p.position.v === targetV);

    if (!planet) {
        const coords = ocdefCoords(
            player.settings.ocdef,
            player.ship.position,
            { v: targetV, h: targetH }
        );
        sendMessageToClient(player, `No known planet at ${coords}. BUILD aborted.`);
        done?.();
        return;
    }

    if (planet.side === "NEUTRAL") {
        sendMessageToClient(player, "Planet not yet captured.");
        done?.();
        return;
    }

    if (!player.ship || planet.side !== player.ship.side) {
        sendMessageToClient(player, `BUILD denied: planet is held by the ${planet.side}.`);
        done?.();
        return;
    }

    if (planet.isBase) {
        sendMessageToClient(player, "This planet is already a starbase.");
        done?.();
        return;
    }

    if (planet.builds >= MAX_BUILDS_PER_PLANET) {
        sendMessageToClient(player, "BUILD limit reached: this planet is fully fortified.");
        done?.();
        return;
    }

    // ---- async build action with jitter ----
    const delayMs = BUILD_DELAY_MIN_MS + ran() * BUILD_DELAY_RANGE;

    putClientOnHold(player, "Building...");
    const timer = setTimeout(() => {
        releaseClient(player);

        // Re-validate state — things may have changed while we waited
        if (!player.ship) {
            sendMessageToClient(player, "You must be in a ship to build.");
            done?.();
            return;
        }

        // Planet could have changed ownership or become a base in the meantime
        if (planet.side !== player.ship.side) {
            sendMessageToClient(player, `BUILD denied: planet is now held by the ${planet.side}.`);
            done?.();
            return;
        }
        if (planet.isBase) {
            sendMessageToClient(player, "This planet is already a starbase.");
            done?.();
            return;
        }
        if (planet.builds >= MAX_BUILDS_PER_PLANET) {
            sendMessageToClient(player, "BUILD limit reached: this planet is fully fortified.");
            done?.();
            return;
        }

        // Apply the build
        planet.builds += 1;

        gameEvents.emit({
            type: "planet_builds_changed",
            payload: {
                planet: planetRef(planet),
                delta: +1,
                newBuilds: planet.builds,
                reason: "build",
                by: attackerRef(player),
            },
        });

        // award points the instant the 5th build lands (kept to your original rule)
        if (planet.builds === 5) {
            player.points.basesBuilt += 1;
        }

        // If we just hit or exceeded the cap, try to promote to a base
        if (planet.builds >= MAX_BUILDS_PER_PLANET) {
            const teamBases = player.ship.side === "FEDERATION" ? bases.federation : bases.empire;

            // enforce the real cap (no +10 fudge)
            if (teamBases.length >= MAX_BASES_PER_TEAM) {
                sendMessageToClient(
                    player,
                    `Maximum number of ${player.ship.side} starbases already active.`
                );
                done?.();
                return;
            }

            // promote atomically; if another thread already promoted, isBase will be true and we just message
            if (!planet.isBase) {
                planet.makeBase(player.ship.side);
            }

            const coords = ocdefCoords(
                player.settings.ocdef,
                player.ship.position,
                { v: targetV, h: targetH }
            );

            sendOutputMessage(player, {
                SHORT: `Base created.`,
                MEDIUM: `Starbase built at ${coords}.`,
                LONG: `Planet at ${coords} has been promoted to a fully operational starbase.`,
            });

            gameEvents.emit({
                type: "planet_base_created",
                payload: {
                    planet: planetRef(planet),
                    by: attackerRef(player),
                },
            });

            done?.();
            return;
        }

        // Otherwise, just report progress
        {
            const coords = ocdefCoords(
                player.settings.ocdef,
                player.ship.position,
                { v: targetV, h: targetH }
            );
            sendOutputMessage(player, {
                SHORT: `+1 build.`,
                MEDIUM: `Now ${planet.builds} build${planet.builds === 1 ? "" : "s"}.`,
                LONG: `One build added. Planet at ${coords} now has ${planet.builds} build${planet.builds === 1 ? "" : "s"}.`,
            });
        }

        done?.();
    }, delayMs);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player); // TODO: Add starbase phaser defense
}

######## capture.ts
import { Command } from "./command.js";
import { ran } from "./util/random.js";
import { CAPTURE_DELAY_MIN_MS } from "./settings.js";
import {
    sendMessageToClient,
    putClientOnHold,
    releaseClient,
    sendOutputMessage,
    sendMessageToOthers,
} from "./communication.js";
import { getCoordsFromCommandArgs, ocdefCoords, chebyshev } from "./coords.js";
import { Player } from "./player.js";
import { planets, pointsManager, players, blackholes, stars, checkEndGame } from "./game.js";
import { applyDamage } from "./torpedo.js"; // adjust path if your applyDamage lives elsewhere
import { gameEvents, planetRef, attackerRef } from "./api/events.js";


//  import { starbasePhaserDefense } from "./phaser.js"; //TODO: verify this isn't a real part of classic game

export function captureCommand(player: Player, command: Command, done?: () => void): void {
    if (command.args.length < 2) {
        sendMessageToClient(
            player,
            "Usage: CAPTURE [A|R] <vpos> <hpos> — must specify coordinates of target planet. Example: CAPTURE 10 25\r\n"
        );
        done?.();
        return;
    }

    if (player.ship === null) {
        sendMessageToClient(player, "You must be in a ship to use the capture command.\r\n");
        done?.();
        return;
    }

    const { position: { v: targetV, h: targetH }, mode, error } = getCoordsFromCommandArgs(
        player,
        command.args,
        player.ship.position.v,
        player.ship.position.h,
        false
    );

    if (error) {
        sendMessageToClient(player, `${error} for mode ${mode}\r\n`);
        done?.();
        return;
    }

    const planet = planets.find(p => p.position.h === targetH && p.position.v === targetV);
    if (!planet) {
        const shipAtTarget = players.some(p => p.ship && p.ship.position.h === targetH && p.ship.position.v === targetV);
        const blackHoleAtTarget = blackholes.some(bh => bh.position.h === targetH && bh.position.v === targetV);
        const starAtTarget = stars.some(star => star.position.h === targetH && star.position.v === targetV);

        if (shipAtTarget || blackHoleAtTarget || starAtTarget) {
            sendMessageToClient(player, "Capture THAT??  You have GOT to be kidding!!!\r\n");
            done?.();
            return;
        } else {
            sendMessageToClient(player, `No planet at those coordinates, Captain.\r\n`);
            done?.();
            return;
        }
    }

    if (planet.isBase && planet.side !== player.ship.side) {
        sendMessageToClient(player, `Captain, the enemy refuses our surrender ultimatum!\r\n`);
        done?.();
        return;
    }

    if (chebyshev(player.ship.position, { v: targetV, h: targetH }) > 1) {
        sendMessageToClient(player, `${player.ship.name} not adjacent to planet.\r\n`);
        done?.();
        return;
    }

    if (planet.side === player.ship.side) {
        const val = ran();
        if (val < 0.33) {
            sendMessageToClient(player, `Planet already captured, sir.\r\n`);
        } else if (val < 0.66) {
            sendMessageToClient(player, `But Captain, he's already on our side!\r\n`);
        } else {
            sendMessageToClient(player, `Captain, are you feeling well?\r\nWe are orbiting a FEDERATION planet!\r\n`);
        }
        done?.();
        return;
    }

    if (planet.captureLock.status) {
        sendMessageToClient(player, `The planet's government refuses to surrender.\r\n`);
        done?.();
        return;
    }

    // removed via Harris reported bug
    // if (player.ship.shieldsUp && player.ship.shieldEnergy > 0) {
    //     sendMessageToClient(player, "CAPTURE denied: shields must be lowered.");
    //     done?.();
    //     return;
    // }

    const hit = 50 + (planet.builds * 30);
    const captureDelayMs = planet.builds * 1000 + CAPTURE_DELAY_MIN_MS;

    if (planet.side !== "NEUTRAL" && planet.side !== player.ship.side) {
        const energyCost = planet.builds * 50;

        if (player.ship.energy < energyCost) {
            sendMessageToClient(player, `Insufficient energy: ${energyCost} required to CAPTURE this planet.\r\n`);
            done?.();
            return;
        }

        player.ship.energy -= energyCost;
    }

    const coords = ocdefCoords(player.settings.ocdef,
        player.ship!.position,
        { v: targetV, h: targetH });

    planet.captureLock = {
        status: true,
        time: Date.now(),
    };

    putClientOnHold(player, `${player.ship.name} capturing ${planet.side} planet ${coords}...`);

    const timer = setTimeout(() => {
        // Always unlock + release + done, no matter what path we take
        try {
            // If the player left their ship during the delay, we’re done
            if (!player.ship) return;

            // Snapshot old state BEFORE mutating
            const oldSide = planet.side;
            const wasBase = !!planet.isBase;
            const oldBuilds = planet.builds;

            // Flip ownership + reset fortifications
            planet.side = player.ship.side;
            planet.isBase = false;
            planet.builds = 0;

            // Human-readable coords (fall back if you already computed `coords` earlier)
            const coords =
                typeof ocdefCoords === "function"
                    ? ocdefCoords(player.settings.ocdef, player.ship.position, planet.position)
                    : `(${planet.position.v},${planet.position.h})`;

            // Broadcast messages
            const othersMsg =
                oldSide === "NEUTRAL"
                    ? `${player.ship.name} has captured a neutral planet at ${coords}.`
                    : `${player.ship.name} has captured a planet at ${coords} from the ${oldSide}.`;

            pointsManager.addPlanetsCaptured(1, player, player.ship.side);
            sendMessageToOthers(player, othersMsg);
            sendOutputMessage(player, {
                SHORT: `captured.`,
                MEDIUM: `captured.`,
                LONG: `captured.`,
            });

            // ---- Emit normalized events ----
            // 1) Ownership change
            gameEvents.emit({
                type: "planet_captured",
                payload: {
                    planet: planetRef(planet),
                    prevSide: oldSide,
                    nextSide: planet.side,
                    by: attackerRef(player),
                },
            });

            // 2) If it used to be a base, announce removal
            if (wasBase) {
                gameEvents.emit({
                    type: "planet_base_removed",
                    payload: {
                        planet: planetRef(planet),
                        reason: "demoted",
                        by: attackerRef(player),
                    },
                });
            }

            // 3) If builds were wiped, announce the delta
            if (oldBuilds > 0) {
                gameEvents.emit({
                    type: "planet_builds_changed",
                    payload: {
                        planet: planetRef(planet),
                        delta: -oldBuilds,
                        newBuilds: 0,
                        reason: "capture",
                        by: attackerRef(player),
                    },
                });
            }

            // ---- Backlash damage (unchanged semantics) ----
            const res = applyDamage(planet, player, hit, ran());

            if (res.hita > 0) {
                sendMessageToClient(
                    player,
                    `Planetary resistance hit your ship for ${Math.round(res.hita)} damage.`
                );
            }
            if (res.isDestroyed) {
                checkEndGame();
            }
        } finally {
            // single place that resets the lock and releases UI
            planet.captureLock.status = false;
            releaseClient(player);
            done?.();
        }
    }, captureDelayMs);


    player.currentCommandTimer = timer;
}

######## command.ts
import { Player } from './player.js';
import { promoteCommand } from './util/admin.js';
import { usersCommand } from './users.js';
import { moveCommand } from './move.js';
import { helpCommand } from './help.js';
import { shieldCommand } from './shield.js';
import { radioCommand } from './radio.js';
import { planetsCommand } from './planets.js';
import { captureCommand } from './capture.js';
import { buildCommand } from './build.js';
import { dockCommand } from './dock.js';
import { shortRangeScanCommand } from './srs.js';
import { statusCommand } from './status.js';
import { pointsCommand } from './points.js';
import { summaryCommand } from './summary.js';
import { listCommand } from './list.js';
import { basesCommand } from './bases.js';
import { targetsCommand } from './targets.js';
import { tellCommand } from './tell.js';
import { setCommand } from './set.js';
import { phaserCommand } from './phaser.js';
import { newsCommand } from './news.js';
import { torpedoCommand } from './torpedo.js';
import { repairCommand } from './repair.js';
import { scanCommand } from './scan.js';
import { timeCommand } from './time.js';
import { tractorCommand } from './tractor.js';
import { impulseCommand } from './move.js';
import { energyCommand } from './energy.js';
import { damagesCommand } from './damage.js';
import { typeCommand } from './type.js';
import { gripeCommand } from './gripe.js';
import { quitCommand } from './quit.js';
import { restartCommand } from './util/restart.js';
import { clearCommand } from './util/clear.js';
import { sendMessageToClient } from './communication.js';
import { oveCommand } from './ove.js';
import { tweakCommand } from './tweak.js';
import { matchesPattern } from './util/util.js';
import { processTimeConsumingMove, nudgeTCMIdle } from './game.js';

interface TokenizedInput {
    tokens: string[][];
}

// --- Command Class ---

export type CommandHandler = (player: Player, command: Command, done?: () => void) => void;

export class Command {
    constructor(
        public key: string,
        public args: string[],
        public raw: string,
    ) {
        this.key = key;
        this.args = args;
        this.raw = raw;
    }
}

// --- Command Registry ---

const decwarCommands = new Map<string, CommandHandler>([
    ["BAses", basesCommand],
    ["BUild", buildCommand],
    ["CApture", captureCommand],
    ["CLear", clearCommand],
    ["DAmages", damagesCommand],
    ["DOck", dockCommand],
    // //["UD", defaultHandler],
    ["Energy", energyCommand],
    ["GRipe", gripeCommand],
    ["Help", helpCommand],
    ["?", helpCommand],
    ["Impulse", impulseCommand],
    ["LIst", listCommand],
    ["Move", moveCommand],
    ["News", newsCommand],
    ["PHasers", phaserCommand],
    ["PLanets", planetsCommand],
    ["POints", pointsCommand],
    ["PRomote", promoteCommand],
    ["Quit", quitCommand],
    ["RAdio", radioCommand],
    ["REpair", repairCommand],
    ["RStart", restartCommand],
    ["SCan", scanCommand],
    ["SEt", setCommand],
    ["SHield", shieldCommand],
    ["SRscan", shortRangeScanCommand],
    ["STatus", statusCommand],
    ["SUmmary", summaryCommand],
    ["TArgets", targetsCommand],
    ["TEll", tellCommand],
    ["TIme", timeCommand],
    ["TOrpedo", torpedoCommand],
    ["TRactor", tractorCommand],
    ["TYpe", typeCommand],
    ["Users", usersCommand],
    ["Over", oveCommand],
    ["TWeak", tweakCommand]
]);

// --- Tokenization ---

export function tokenize(input: string): TokenizedInput {
    const commandPart = input.replace(/;/g, ' ; ');

    const rawCommands = commandPart
        .split("/")
        .map(cmd => cmd.trim())
        .filter(Boolean);

    const commands = rawCommands.map(cmd =>
        cmd
            .split(/[\s,]+/)
            .map(token => token.trim())
            .filter(Boolean)
    );

    return {
        tokens: commands
    };
}

export function queueCommands(player: Player, input: string): void {
    const parsed = tokenize(input);
    if (!parsed.tokens.length) return;

    for (const commandTokens of parsed.tokens) {
        player.commandQueue.push(commandTokens.join(" "));
    }

    processNextCommand(player);
}

export function processNextCommand(player: Player): void {

    if (player.processingCommand || player.commandQueue.length === 0) {
        sendMessageToClient(player, "", false, true);
        return;
    }

    const raw = player.commandQueue.shift();
    if (!raw) return;

    const tokens = raw.split(/\s+/);
    const commandKey = tokens[0].toUpperCase();
    const commandObject = new Command(commandKey, tokens.slice(1), raw);

    const matchedCommand = [...decwarCommands.entries()].find(
        ([key]) => matchesPattern(commandKey, key)
    )?.[1];

    if (!matchedCommand) {
        sendMessageToClient(player, `Unknown command: ${commandKey}`);
        return processNextCommand(player);
    }

    player.processingCommand = true;

    // Check arity to support legacy sync commands
    if (matchedCommand.length < 3) {
        matchedCommand(player, commandObject);
        player.processingCommand = false;
        // Light, debounced nudge so the world advances if players only use sync cmds.
        // IMPORTANT: keep this non-attributed so it does NOT tick life support.
        nudgeTCMIdle();
        //sendAllPendingMessages()
        processNextCommand(player);
    } else {
        matchedCommand(player, commandObject, () => {
            //gameSettings.timeConsumingMoves++;  PUT BACK TODO
            player.processingCommand = false;
            // Actor-only, attributed TCM: LS tick will happen inside game epilogue for this actor only.
            processTimeConsumingMove(player, { attributed: true });
            processNextCommand(player);
        });
    }
}
######## communication.ts
import { players } from "./game.js";
import { chebyshev } from "./coords.js";
import { Player } from "./player.js";
import { Planet } from "./planet.js";

export type OutputVariants = {
    SHORT: string;
    MEDIUM: string;
    LONG: string;
};

export function addPendingMessage(player: Player, message: string): void {
    player.pendingMessages.push(message);
}

export function sendPendingMessages(player: Player): void {
    sendMessageToClient(player, '\r\n', false, false);
    const len = player.pendingMessages.length;
    for (let i = 0; i < len; i++) {
        const message = player.pendingMessages[i];
        if (i === len - 1) {
            sendMessageToClient(player, message, true, true);
        } else {
            sendMessageToClient(player, message, true, false);
        }
    }
    player.pendingMessages = [];
}

export function sendAllPendingMessages(): void {
    for (const player of players) {
        if (player.pendingMessages.length > 0) {
            sendPendingMessages(player);
        }
    }
}

export function sendMessageToClient(
    player: Player,
    message: string,
    returns = true,  // put return in output
    command = false   // if command then print prompt after
): void {
    if (!player.socket) return; // bots don't have a socket
    try {
        //player.socket.write('\r\x1b[K');

        if (returns) player.socket.write(`${message}\r\n`);
        else player.socket.write(`${message}`);
        if (command && !player.isOnHold) player.socket.write(`${player.getPrompt()}${player.inputBuffer}`);
    } catch (err: unknown) {
        console.error('Error in sendMessageToClient:', err instanceof Error ? err.message : String(err));
    }
}

export function sendMessageToOthers(player: Player | Planet, message: string, range: number = 10): void {
    let origin = { v: 0, h: 0 };
    if (player instanceof Player && player.ship) {
        origin = player.ship.position;
    } else if (player instanceof Planet) {
        origin = player.position;
    }

    for (const other of players) {
        if (other === player || !other.ship || !other.radioOn) continue;

        if (chebyshev(origin, other.ship.position) <= range) {
            sendMessageToClient(other, "\r\n" + message, true, true);
        }
    }
}

export function sendMessageToOthersWithFormat(
    origin: Player,
    formatter: (recipient: Player) => string
): void {
    players.forEach((recipient) => {
        if (recipient !== origin && recipient.ship) {
            const msg = formatter(recipient);
            addPendingMessage(recipient, msg);
        }
    });
}

export function sendOutputMessage(player: Player, variants: OutputVariants): void {
    const level = player.settings.output;
    const message = variants[level] ?? variants.LONG;
    sendMessageToClient(player, message);
}

// export function safeBroadcastMessage(
//     message: string,
//     returns = true,
//     command = true
// ): void {
//     for (const [socket, clientState] of clients.entries()) {
//         try {
//             socket.write('\r\x1b[K');
//             if (returns) socket.write(`${message}\r\n`);
//             else socket.write(`${message}`);
//             if (command) socket.write(` ${clientState.inputBuffer}`);
//         } catch (err: unknown) {
//             console.error('Error in safeBroadcastMessage:', err instanceof Error ? err.message : String(err));
//         }
//     }
// }

export function putClientOnHold(player: Player, message: string): void {
    player.isOnHold = true;
    if (message !== "") {
        sendMessageToClient(player, message, false, false);
    }
}

export function releaseClient(player: Player, message: string | null = null): void {
    player.isOnHold = false;
    if (message) {
        sendMessageToClient(player, message);
    }
}
######## coords.ts
import { players, planets, blackholes, stars } from "./game.js";
import { Planet } from "./planet.js";
import { Blackhole } from "./blackhole.js";
import { Star } from "./star.js";
import { Player } from "./player.js";
import { Ship } from "./ship.js";
import { GRID_HEIGHT, GRID_WIDTH, OCDEF, CoordMode } from "./settings.js";
import { iran } from "./util/random.js";
import { sendMessageToClient } from "./communication.js";

export type Position = {
    v: number;
    h: number;
}

export function chebyshev(a: Position, b: Position): number {
    return Math.max(Math.abs(a.v - b.v), Math.abs(a.h - b.h));
}

/**
 * Finds a Planet, BlackHole, or Ship at the given (v, h) position.
 * Returns { v, h, obj } if found, otherwise null.
 */
export function findObjectAtPosition(
    v: number,
    h: number,
    ignoreBlackholes: boolean = false
): { v: number; h: number; obj: Ship | Planet | Star | Blackhole } | null {
    for (const player of players) {
        if (player.ship && player.ship.position.v === v && player.ship.position.h === h) {
            return { v, h, obj: player.ship };
        }
    }

    for (const planet of planets) {
        if (planet.position.v === v && planet.position.h === h) {
            return { v, h, obj: planet };
        }
    }

    for (const star of stars) {
        if (star.position.v === v && star.position.h === h) {
            return { v, h, obj: star };
        }
    }
    if (!ignoreBlackholes) {
        for (const bh of blackholes) {
            if (bh.position.v === v && bh.position.h === h) {
                return { v, h, obj: bh };
            }
        }
    }
    return null;
}

export function findEmptyLocation(): Position | null {
    for (let attempts = 0; attempts < 1000; attempts++) {
        const v = iran(GRID_HEIGHT) + 1;
        const h = iran(GRID_WIDTH) + 1;

        if (!findObjectAtPosition(v, h)) {
            return { v, h };
        }
    }
    return null; // fallback if map is saturated
}

export interface ParsedCoords {
    position: Position;
    cursor: number;
    mode: CoordMode;
    error?: string;
}

/**
 * Parses coordinates from a command's argument list.
 * - Allows optional mode prefix ("A", "R", or "C").
 * - Returns absolute coordinates with mode info.
 * - If COMPUTED is used but not allowed, returns an error.
 */
export function getCoordsFromCommandArgs(
    player: Player,
    args: string[],
    currentV: number,
    currentH: number,
    allowComputed: boolean = false
): ParsedCoords {
    let cursor = 0;
    let mode: CoordMode = "ABSOLUTE";

    const modeArg = args[0]?.toUpperCase();
    if (modeArg === "R" || modeArg === "RELATIVE") {
        mode = "RELATIVE";
        cursor++;
    } else if (modeArg === "A" || modeArg === "ABSOLUTE") {
        mode = "ABSOLUTE";
        cursor++;
    } else if (modeArg === "C" || modeArg === "COMPUTED") {
        if (!allowComputed) {
            return { position: { v: 0, h: 0 }, cursor, mode: "COMPUTED", error: "COMPUTED coordinates are not allowed for this command." };
        }
        mode = "COMPUTED";
        cursor++;
    } else {
        if (player.settings.icdef) {
            mode = player.settings.icdef;
        }
    }

    if (mode === "COMPUTED") {
        const shipArg = args[cursor];
        return getComputedCoordsFromCommandArg(player, shipArg, cursor, mode);
    }

    const v = parseInt(args[cursor++], 10);
    const h = parseInt(args[cursor++], 10);

    if (Number.isNaN(h) || Number.isNaN(v)) {
        return { position: { v: 0, h: 0 }, cursor, mode, error: "Invalid coordinates." };
    }

    const resultV = mode === "RELATIVE" ? currentV + v : v;
    const resultH = mode === "RELATIVE" ? currentH + h : h;
    return {
        position: { v: resultV, h: resultH },
        cursor,
        mode,
        error: undefined
    };
}

function getComputedCoordsFromCommandArg(player: Player, shipArg: string, cursor: number, mode: CoordMode) {
    if (!shipArg) {
        return { position: { v: 0, h: 0 }, cursor, mode, error: "Ship name required for COMPUTED coordinates." };
    }
    if (!player.ship!.isDeviceOperational("computer")) {
        sendMessageToClient(player, "COMPUTER MALFUNCTION — unable to compute target coordinates.");
        return { position: { v: 0, h: 0 }, cursor, mode, error: "COMPUTER MALFUNCTION — unable to compute target coordinates." };
    }
    cursor++;

    const ship = Ship.findShipByPartialName(shipArg);
    if (!ship) {
        const shipName = Ship.findShipByPartialName(shipArg);
        if (shipName) {
            return { position: { v: 0, h: 0 }, cursor, mode, error: `Ship ${shipName} not in game.` };
        } else {
            return { position: { v: 0, h: 0 }, cursor, mode, error: `Unknown computed target ${shipArg}.` };
        }
    }
    return { position: { v: ship.position.v, h: ship.position.h }, cursor, mode, error: undefined };
}

export function ocdefCoords(
    ocdef: OCDEF,
    source: Position,
    location: Position
): string {
    const abs = `${location.v}-${location.h}`;
    const relV = location.v - source.v;
    const relH = location.h - source.h;
    const rel = `${relV >= 0 ? "+" : ""}${relV} ${relH >= 0 ? "+" : ""}${relH}`;

    switch (ocdef) {
        case "RELATIVE":
            return rel;
        case "BOTH":
            return `${abs} (${rel})`;
        case "ABSOLUTE":
        default:
            return abs;
    }
}

// Bresenham line generator
export function* bresenhamLine(v0: number, h0: number, v1: number, h1: number) {
    const dh = Math.abs(h1 - h0),
        dv = Math.abs(v1 - v0),
        sh = h0 < h1 ? 1 : -1,
        sv = v0 < v1 ? 1 : -1;
    let err = dh - dv;

    while (true) {
        yield { h: h0, v: v0 };
        if (h0 === h1 && v0 === v1) break;
        const e2 = err * 2;
        if (e2 > -dv) { err -= dv; h0 += sh; }
        if (e2 < dh) { err += dh; v0 += sv; }
    }
}

export function isAdjacent(pos1: Position, pos2: Position): boolean {
    const dv = Math.abs(pos1.v - pos2.v);
    const dh = Math.abs(pos1.h - pos2.h);
    return (dh <= 1 && dv <= 1) && !(dh === 0 && dv === 0);
}

export function getTrailingPosition(origin: Position, destination: Position): Position | null {
    // Sort origin's adjacent positions by distance to destination
    const sortedOriginAdjacents = getAdjacentPositions(origin)
        .filter(pos => isInBounds(pos.v, pos.h) && !findObjectAtPosition(pos.v, pos.h))
        .sort((a, b) => distance(b, destination) - distance(a, destination)); // trailing = farther from destination

    if (sortedOriginAdjacents.length > 0) {
        const result = sortedOriginAdjacents[0];
        if (isInBounds(result.v, result.h)) { // Explicit check for clarity
            return result;
        }
        // If somehow not in bounds (shouldn't happen), proceed to fallback
    }

    // Fallback: try positions around the destination
    const sortedDestinationAdjacents = getAdjacentPositions(destination)
        .filter(pos => isInBounds(pos.v, pos.h) && !findObjectAtPosition(pos.v, pos.h))
        .sort((a, b) => distance(a, origin) - distance(b, origin)); // prefer closer to the line from origin to destination

    if (sortedDestinationAdjacents.length > 0) {
        const result = sortedDestinationAdjacents[0];
        if (isInBounds(result.v, result.h)) { // Explicit check for clarity
            return result;
        }
        // If somehow not in bounds (shouldn't happen), return null
    }

    // No valid trailing position found
    return null;
}

function distance(a: Position, b: Position): number {    // is thislegit? why
    return Math.hypot(a.v - b.v, a.h - b.h);
}

function getAdjacentPositions(pos: Position): Position[] {
    const deltas = [
        { v: 0, h: -1 }, // up
        { v: 0, h: 1 },  // down
        { v: -1, h: 0 }, // left
        { v: 1, h: 0 },  // right
        { v: -1, h: -1 }, // up-left
        { v: 1, h: -1 },  // up-right
        { v: -1, h: 1 },  // down-left
        { v: 1, h: 1 },   // down-right
    ];
    return deltas.map(delta => ({ v: pos.v + delta.v, h: pos.h + delta.h }));
}

export function isInBounds(v: number, h: number): boolean {
    return h >= 1 && h <= GRID_WIDTH && v >= 1 && v <= GRID_HEIGHT;
}
######## damage.ts
import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';
import { Player } from './player.js';
import { Ship } from './ship.js';


export function damagesCommand(player: Player, command: Command): void {
    if (!player.ship) return;
    const devices = player.ship.devices;
    const args = command.args.map(a => a.toUpperCase());

    // Device mappings: token to full name and device key
    const deviceMappings: { [key: string]: { name: string; key: keyof Ship['devices']; minLength: number } } = {
        'WARP': { name: 'Warp', key: 'warp', minLength: 1 },
        'IMPULSE': { name: 'Impulse', key: 'impulse', minLength: 1 },
        'TORPEDO': { name: 'Torpedo', key: 'torpedo', minLength: 2 },
        'PHASER': { name: 'Phasers', key: 'phaser', minLength: 1 },
        'SHIELD': { name: 'Shields', key: 'shield', minLength: 1 },
        'COMPUTER': { name: 'Computer', key: 'computer', minLength: 1 },
        'RADIO': { name: 'Radio', key: 'radio', minLength: 1 },
        'TRACTOR': { name: 'Tractor', key: 'tractor', minLength: 2 },
        'LIFESUPPORT': { name: 'Life Sup', key: 'lifeSupport', minLength: 1 }
    };

    // Deduplicate args array to avoid duplicate device reports
    const seenArgs = new Set<string>();
    let args2 = args.filter(arg => {
        if (seenArgs.has(arg)) return false;
        seenArgs.add(arg);
        return true;
    });
    let showAll = false;
    let hasDamage = false;

    if (args2.length == 0) {
        args2 = ["W", "I", "TO", "P", "S", "C", "R", "TR", "L"];
    } else {
        showAll = true;
    }

    const output: string[] = [];
    for (const arg of args2) {
        const matchedDevice = Object.entries(deviceMappings).find(([fullToken, { minLength }]) =>
            arg.length >= minLength && fullToken.startsWith(arg)
        );
        if (matchedDevice) {
            const { name, key } = matchedDevice[1];
            const damage = devices[key as keyof typeof devices];
            //const damage = Math.random() * 300;  test
            if ((damage <= 0 && showAll) || damage > 0)
                output.push(`${name.padEnd(11)}${damage.toFixed(1).padStart(7)}`);
            if (damage > 0) hasDamage = true;
        }
    }
    if (!hasDamage) {
        sendMessageToClient(player, 'All systems operational.\r\n');
        return;
    } else {
        // Output header and aligned lines
        output.unshift('');
        output.unshift('Device       Damage');
        output.push('');
        output.forEach(line => sendMessageToClient(player, line));
    }
    return;


    // // General damage report
    // const reportLines: string[] = [];
    // for (const { name, key } of Object.values(deviceMappings)) {
    //     const damage = devices[key as keyof typeof devices];
    //     if (damage > 0) {
    //         reportLines.push(`${name.padEnd(16)}${damage.toFixed(0).padStart(6)}`);
    //     }
    // }
    // if (reportLines.length === 0) {
    //     sendMessageToClient(player, 'All systems operational.');
    // } else {
    //     sendMessageToClient(player, 'Damage Report:');
    //     sendMessageToClient(player, 'Device           Damage');
    //     reportLines.forEach(line => sendMessageToClient(player, line));
    // }
}
######## db/user-records.ts
import { ScanSetting, PromptSetting, OCDEF, ICDEF, OutputSetting } from "../settings.js";
import flatfilePkg from 'flat-file-db';
import { Player } from "../player.js";

const flatfile = (flatfilePkg as { default?: typeof flatfilePkg }).default || flatfilePkg;
const db = flatfile('playerSettings.db');

type Settings = {
    scan: ScanSetting;
    prompt: PromptSetting;
    ocdef: OCDEF;
    icdef: ICDEF;
    output: OutputSetting;
};

let dbOpen = false;


db.on('open', () => {
    dbOpen = true;
});


export function getPlayerSettings(player: Player): Settings | null {
    if (!dbOpen || !player.auth.email) {
        return null;
    }

    const settings = player.settings;//db.get(player.auth.email);
    if (settings) {
        //player.settings = settings;
        return player.settings;
    } else {
        return null;
    }
}

export function setPlayerSettings(player: Player): void {
    if (!dbOpen || !player.auth.email) {
        return;
    }

    db.put(player.auth.email, player.settings);
}

######## dock.ts
// src/dock.ts (or wherever this lives)
import { Command } from "./command.js";
import { ran } from "./util/random.js";
import { Player } from "./player.js";
import { putClientOnHold, sendMessageToClient, releaseClient } from "./communication.js";
import { planets } from "./game.js";
import { statusCommand } from "./status.js";
import {
    MAX_SHIP_ENERGY,
    MAX_SHIELD_ENERGY,
    MAX_TORPEDOES,
    DOCK_DELAY_MIN_MS,
    DOCK_DELAY_RANGE,
} from "./settings.js";
import { isAdjacent } from "./coords.js";
import type { Planet } from "./planet.js";
import { emitShipDocked } from "./api/events.js"; // ← NEW

export function dockCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to dock.");
        done?.();
        return;
    }

    if (player.ship.docked) {
        sendMessageToClient(player, "You are already docked.");
        done?.();
        return;
    }

    // if (player.ship.shieldsUp && player.ship.shieldEnergy > 0) {
    //   sendMessageToClient(player, "Shields must be down to dock.");
    //   done?.();
    //   return;
    // }

    let isBase = false;
    let nearPlanet = false;
    let dockPlanet: Planet | null = null; // ← remember where we’re docking

    const side = player.ship.side;

    for (const planet of planets) {
        if (planet.side === side && isAdjacent(player.ship.position, planet.position)) {
            nearPlanet = true;
            dockPlanet = planet;              // ← capture the specific planet/base
            if (planet.isBase) isBase = true;
            break;
        }
    }

    if (!nearPlanet || !dockPlanet) {
        sendMessageToClient(player, "No friendly base or captured planet nearby to dock.");
        done?.();
        return;
    }

    const showStatus = command.args.length > 0 && "STATUS".startsWith(command.args[0].toUpperCase());
    if (command.args.length > 0 && !showStatus) {
        sendMessageToClient(player, "Invalid command. Use 'STATUS' to show status.");
        done?.();
        return;
    }

    const statusArgs = showStatus ? command.args.slice(1).map((a) => a.toUpperCase()) : [];

    const delayMs = DOCK_DELAY_MIN_MS + ran() * DOCK_DELAY_RANGE;
    putClientOnHold(player, "Docking...");

    const timer = setTimeout(() => {
        releaseClient(player);

        if (!player.ship) {
            sendMessageToClient(player, "You must be in a ship to dock.");
            done?.();
            return;
        }

        // Re-validate docking target still makes sense (edge-case: state changed during delay)
        if (!dockPlanet || dockPlanet.side !== player.ship.side || !isAdjacent(player.ship.position, dockPlanet.position)) {
            sendMessageToClient(player, "Docking aborted: target no longer available.");
            done?.();
            return;
        }

        const ship = player.ship;
        const wasFullyRepaired =
            ship.energy >= MAX_SHIP_ENERGY &&
            ship.shieldEnergy >= MAX_SHIELD_ENERGY &&
            ship.torpedoes >= MAX_TORPEDOES &&
            ship.damage <= 0;

        // Dock status
        const wasAlreadyDocked = ship.docked;
        ship.docked = true;
        ship.dockPlanet = dockPlanet;
        ship.condition = "GREEN";

        // Repair / refuel rates
        const energyGain = isBase ? 1000 : 500;
        const shieldGain = isBase ? 500 : 250;
        const torpGain = isBase ? 10 : 5;
        const damageRepair = isBase ? 100 : 50;
        const dockedBonus = isBase ? 200 : 100;

        ship.energy = Math.min(MAX_SHIP_ENERGY, ship.energy + energyGain);
        ship.shieldEnergy = Math.min(MAX_SHIELD_ENERGY, ship.shieldEnergy + shieldGain);
        ship.shieldsUp = false;
        ship.torpedoes = Math.min(MAX_TORPEDOES, ship.torpedoes + torpGain);
        ship.damage = Math.max(0, ship.damage - damageRepair - (wasAlreadyDocked ? dockedBonus : 0));
        ship.devices.lifeSupport = 0;

        // Messages
        if (wasFullyRepaired) {
            sendMessageToClient(player, "Docking has no effect. Ship fully supplied.");
        } else {
            sendMessageToClient(player, "Docking complete. Supplies replenished.");
        }
        sendMessageToClient(player, "Ship condition is now GREEN.");

        // 🔔 Emit ship_docked for clients/telemetry
        // Reason "resupply" fits best here; change to "manual" if you prefer.
        emitShipDocked(player, dockPlanet, "resupply");

        if (showStatus) {
            statusCommand(player, {
                ...command,
                args: statusArgs,
            });
        }

        done?.();
    }, delayMs);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player); TODO: Add starbase phaser defense
}

######## energy.ts
import { sendMessageToClient, sendOutputMessage } from "./communication.js";
import { Player } from "./player.js";
import { Command } from "./command.js";
import { players } from "./game.js";
import { Ship } from "./ship.js";
import { chebyshev } from "./coords.js";
import { MAX_SHIP_ENERGY } from "./settings.js";

/**
 * ENERGY <shipName> <units>
 * Transfers energy to an adjacent allied ship, losing 10% in transit.
 */
export function energyCommand(player: Player, command: Command): void {
    const args = command.args;

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use ENERGY.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    if (args.length < 2) {
        sendMessageToClient(player, 'Usage: ENERGY <shipName> <amount>');
        return;
    }

    const targetInput = args[0].toUpperCase();
    const requested = parseInt(args[1], 10);
    if (isNaN(requested) || requested <= 0) {
        sendMessageToClient(player, 'Invalid energy amount.');
        return;
    }

    if (player.ship.energy < requested) {
        sendMessageToClient(player, 'Insufficient energy to transfer.');
        return;
    }

    // Match alive players with partial ship name match
    const name = Ship.resolveShipName(targetInput);
    if (!name) {
        sendMessageToClient(player, `No ship found matching "${targetInput}".`);
        return;
    }

    const matches = [...players].filter(p => p.ship && p.ship.name.toUpperCase() === name);

    if (matches.length === 0) {
        sendMessageToClient(player, `Ship "${targetInput}" not in service.`);
        return;
    } else if (matches.length > 1) {
        const names = matches.map(p => p.ship ? p.ship.name : "Unknown").join(', ');
        sendMessageToClient(player, `Ambiguous ship name "${targetInput}". Matches: ${names}`);
        return;
    }

    const target = matches[0];

    if (target.ship) {

        // Check adjacency
        if (chebyshev(player.ship.position, target.ship.position) > 1) {
            sendMessageToClient(player, `Target ${target.ship.name} is not adjacent.`);
            return;
        }

        // Energy transfer math
        const availableRoom = MAX_SHIP_ENERGY - target.ship.energy;
        if (availableRoom <= 0) {
            sendMessageToClient(player, `${target.ship.name} cannot accept more energy.`);
            return;
        }

        const sendAmount = Math.min(requested, availableRoom);
        player.ship.energy -= sendAmount;
        const received = Math.floor(sendAmount * 0.9);
        target.ship.energy += received;

        // Sender output
        sendOutputMessage(player, {
            SHORT: `ENERGY: ${sendAmount} → ${target.ship.name} (${received} recv)`,
            MEDIUM: `Transferred ${sendAmount} units to ${target.ship.name}; they received ${received} (10% lost).\nYour energy: ${player.ship.energy}\nTheir energy: ${target.ship.energy}`,
            LONG: `Energy transfer complete.\n${sendAmount} units sent to ${target.ship.name}.\n${target.ship.name} received ${received} units (10% lost in transmission).\nYour remaining energy: ${player.ship.energy}`
        });

        // Target output
        sendOutputMessage(target, {
            SHORT: `${received} ENERGY UNITS FROM ${player.ship.name}`,
            MEDIUM: `${received} units of energy received from ${player.ship.name}.`,
            LONG: `Incoming energy transfer from ${player.ship.name}.\nReceived ${received} units of energy.`
        });

    } {
        sendMessageToClient(player, `${name} ship not found.`);
        return;
    }
}

######## game.ts
import { Blackhole } from "./blackhole.js";
import { Planet } from "./planet.js";
import { Player } from "./player.js";
import { Star } from "./star.js";
import { setRandomSeed, iran, getRandom } from './util/random.js';
import { PointsManager } from "./points.js";
import { settings, INACTIVITY_TIMEOUT } from "./settings.js";
import { updateRomulan, maybeSpawnRomulan } from "./romulan.js";
import { sendAllPendingMessages, sendMessageToClient } from "./communication.js";
import net from "net";
import { chebyshev } from "./coords.js";
import { pointsCommand } from "./points.js";
import { basphaFireOnce } from "./starbase_phasers.js";
import { planetPhaserDefense } from "./phaser.js";
import { baseEnergyRegeneration } from "./planet.js";
import { autoRepairTick } from './repair.js';
// DECWAR help text: ship destroyed at 2500 units of damage
export const SHIP_FATAL_DAMAGE = 2500;
import { romulanApproachTick } from "./romulan.js";
import { emitShipDestroyed, emitShipLeft } from "./api/events.js";


// bot imports
import { spawnSideBot, updateSideBots, ensureBots } from "./bots/general.js";


export const players: Player[] = [];
export const limbo: Player[] = [];
export let planets: Planet[] = [];
export const bases = {
    federation: [] as Planet[],
    empire: [] as Planet[],
};
export const stars: Star[] = [];
export const blackholes: Blackhole[] = [];
// Global stardate is not used (per-player stardate is shown). Removing to avoid confusion.
// export const stardate: number = 0;
export const pointsManager: PointsManager = new PointsManager();

export const PLANET_PHASER_RANGE = 2; // Fortran pdist <= 2

// ---- lightweight TCM debounce + idle fallback ---------------------------
let tcmRunning = false;
let tcmLastRun = 0;
const IDLE_NUDGE_MS = 3000;  // sync-command nudge at most ~once/2s
const MAX_IDLE_MS = 5000;    // advance at least every 5s during total lulls
// -------------------------------------------------------------------------

// mark existing player objects as bots
// spawnAndRegisterBot("aggressor", "FEDERATION", "BOT-KIRK");
// spawnAndRegisterBot("defender", "EMPIRE", "BOT-KOL");





export function generateGalaxy(seed?: string): void {
    if (!seed) {
        seed = settings.tournamentSeed;
    }
    setRandomSeed(seed);

    //     nstar = int(51 * ran(0)) * 5 + 100
    //     nhole = int(41.0 * ran(0) + 10)
    //    c-- nplnet = int(20.0 + ran(0) * 61.0)
    //     nplnet = 60 ! ALWAYS insert max. # of planets

    const nstar = iran(51) * 5 + 100;
    const nhole = iran(41) + 10;
    const nplnet = 80; // to jibe with 2.2, start with 80, 20 of which will become bases

    planets = Planet.generate(nplnet);
    console.log("generated planets");
    Planet.generateBases();  // 10 each
    console.log("generated bases");
    Star.generate(nstar);
    if (settings.blackholes) {
        console.log("generating blackholes");
        Blackhole.generate(nhole);
    }
    console.log("generated stars");
    console.log(nstar, nhole, nplnet);
    settings.generated = true;

    // No explicit spawns; rely on ensureBots() during sweeps.
}

// export function processTimeConsumingMove(player: Player) {
//     if (!player.ship) return;
//     if (player.ship.side == "FEDERATION") {
//         settings.teamTurns.federation += 1;
//     } else if (player.ship.side == "EMPIRE") {
//         settings.teamTurns.empire += 1;
//     } else if (player.ship.side == "ROMULAN") {
//         settings.teamTurns.romulan += 1;
//     }

//     player.stardate += 1;
//     settings.dotime += 1;
//     const numply = players.length;

//     // Perform periodic actions if dotime >= numply (mirrors if (dotime .lt. numply) goto 3501)
//     if (settings.dotime >= numply) {
//         settings.dotime = 0; // Reset dotime (mirrors dotime = 0)

//         // Periodic actions (mirrors basbld, baspha, plnatk, romdrv)
//         baseEnergyRegeneration(player); // Mirrors BASBLD
//         performPlanetOrBaseAttacks(true); // Mirrors BASPHA (enemy bases)
//         performPlanetOrBaseAttacks(false); // Mirrors PLNATK (neutral/enemy planets)
//         updateRomulan(); // Mirrors romdrv (partially)
//         if (settings.romulans) {
//             maybeSpawnRomulan(); // Mirrors romdrv (Romulan spawning)
//         }
//     }

//     for (const player of players) {
//         player.updateLifeSupport();
//     }
// }
// `actor` is who consumed time; attributed=true means a real TCM (not idle sweep).
export function processTimeConsumingMove(actor?: Player | null, opts?: { attributed?: boolean }) {
    // prevent overlap; keep DECWAR feel (no precise scheduling)
    if (tcmRunning) return;
    tcmRunning = true;
    const attributed = !!opts?.attributed && !!actor?.ship;
    const ctx: Player | undefined = actor ?? players.find(pl => pl.ship);
    if (process.env.DEBUG_TCM === "1") {
        console.log("processTimeConsumingMove", attributed && actor?.ship ? actor.ship.name : "idle");
    }

    // Team turn bookkeeping (only when attributed)
    if (attributed && actor?.ship) {
        if (actor.ship.side === "FEDERATION") {
            settings.teamTurns.federation += 1;
        } else if (actor.ship.side === "EMPIRE") {
            settings.teamTurns.empire += 1;
        } else if (actor.ship.side === "ROMULAN") {
            settings.teamTurns.romulan += 1;
        }
    }

    // Stardates: actor gets +1 only when attributed; GLOBAL stardate always advances per TCM.
    if (attributed && actor?.ship) actor.stardate += 1;
    settings.stardate += 1;
    settings.dotime += 1;

    // ACTIVE human players only (exclude Romulan), never 0; fatal threshold
    const isAliveHuman = (p: Player) =>
        !!p?.ship && p.ship.side !== "ROMULAN" && p.ship.energy > 0 && p.ship.damage < SHIP_FATAL_DAMAGE;
    const numply = Math.max(1, players.filter(isAliveHuman).length);

    // Once per full sweep of players
    if (settings.dotime >= numply) {
        settings.dotime = 0; // reset sweep
        // If there is no live ship context (e.g., empty server), skip ship-scoped routines.
        if (ctx?.ship) {
            // Count teammates using the SAME alive predicate used for numply
            const alivePlayers = players.filter(isAliveHuman);
            const moverSide = ctx.ship.side;
            const numsid = Math.max(1, alivePlayers.filter(p => p.ship!.side === moverSide).length);
            // === Defense & regen in DECWAR order ===
            basphaFireOnce(ctx, numply);                 // BASPHA (enemy bases fire once)
            planetPhaserDefense(ctx, { numply });        // PLNATK (planet auto-phasers)
            baseEnergyRegeneration(ctx, { numply, numsid }); // BASBLD (heal a little)
            // ======================================

            // Log current game state
            console.log(`TCM: Planets=${planets.length}, Bases: FED=${bases.federation.length}, EMP=${bases.empire.length}`);
        }

        // Romulan driver (spawn + behavior), gated at sweep boundary
        if (settings.romulans) {
            updateRomulan();         // ROMDRV weapon logic (fires if cooldowns ready)
            romulanApproachTick();   // approach/steering
            maybeSpawnRomulan();     // ROMDRV spawn cadence
        }

        // General side-playing bots (testing only). Guard with env to avoid unintended CPU use.
        if (true || process.env.SPAWN_SIDE_BOTS === "1") {
            ensureBots(2);      // keep exactly two bot ships alive
            updateSideBots();   // drive them this sweep
        }
    } else {
        // If bots should act every time-consuming move instead, keep them here:
        // updateBots();
        // botChatterTick();
    }

    // === Life-support tick (actor-only, only on attributed TCMs, and only if undocked) ===
    if (opts?.attributed && actor?.ship && !actor.ship.docked) {
        actor.updateLifeSupport();
    }

    // FORTRAN parity: after every time-consuming move, apply automatic device repair to the mover.
    // (Normal turn repair: 30 units per damaged device; silent; no time added.)
    if (opts?.attributed && actor?.ship) {
        autoRepairTick(actor);
    }

    checkEndGame();
    tcmLastRun = Date.now();
    tcmRunning = false;
}

// Idle nudge used when players spam non-TCM commands.
// IMPORTANT: Non-attributed — should NOT tick any life support.
export function nudgeTCMIdle(): void {
    const now = Date.now();
    if (tcmRunning) return;
    if (now - tcmLastRun < IDLE_NUDGE_MS) return;
    // advance world unattributed; do not bump any ship stardate/turns
    processTimeConsumingMove(null, { attributed: false });
}

function updateGame(): void {
    checkForDisconnectedPlayers();
    checkForInactivity();
    releaseStalePlanetCaptureLocks()
    if (settings.blackholes) {
        checkForBlackholes();
    }

    // Idle fallback: advance TCM at least every 5s even if nobody does any
    // time-consuming moves. This complements nudgeTCMIdle() (called after bursts).
    if (!tcmRunning && Date.now() - tcmLastRun >= MAX_IDLE_MS) {
        // advance world unattributed; do not bump any ship stardate/turns
        processTimeConsumingMove(undefined, { attributed: false });
    }

    setTimeout(updateGame, 1000);
}
updateGame();

function releaseStalePlanetCaptureLocks() {
    const now = Date.now();
    for (const planet of planets) {
        if (planet.captureLock.status === true &&
            (now - planet.captureLock.time > 10000)
        ) {
            planet.captureLock.status = false;
        }
    }
}



function checkForPendingMessages(): void {
    sendAllPendingMessages();
    setTimeout(checkForPendingMessages, 30);
}
setTimeout(checkForPendingMessages, 1000);


function checkForInactivity() {
    for (const player of players) {
        if (!player.ship) continue;

        const inactiveTime = Date.now() - player.lastActivity;

        if (inactiveTime >= INACTIVITY_TIMEOUT) {
            sendMessageToClient(player, "Captain, you have been inactive for too long. You have been removed from the game.");
            emitShipLeft(player, "timeout");
            removePlayerFromGame(player);

        }
    }
}


// function planetOrBasePhaserDamage(distance: number, target: Player): number {
//     let baseHit = Math.pow(0.9 + 0.02 * Math.random(), distance); // Fortran: pwr(0.9–0.92, id)
//     if (target.ship && (target.ship.devices.phaser > 0 || target.ship.devices.computer > 0)) {
//         baseHit *= 0.8; // Fortran: hit *= 0.8 if damaged
//     }
//     return baseHit;
// }

export function performPlanetOrBaseAttacks(base: boolean = false): void {
    for (const planet of planets) {
        if (planet.isBase !== base) continue; // Bases if base=true, planets if base=false
        if (planet.side === "NEUTRAL") {
            if (!base && getRandom() < 0.5) continue;
        }

        for (const player of players) {
            if (!player.ship) continue;
            if (player.ship.side === planet.side) continue;
            if (player.ship.romulanStatus.cloaked) continue;

            const range = chebyshev(planet.position, player.ship.position);
            const maxRange = base ? 4 : 2; // 4 sectors for bases, 2 for planets
            if (range > maxRange) continue;
            //const phit = base ? 200 : 100; // 200 energy for bases, 100 for planets


            // DO_DAMANGE
            // calcShipFromPlanetPhaserDamage(phit, planet, player);
        }
    }
}

function checkForDisconnectedPlayers() {
    for (const player of players) {
        if (!isSocketLive(player.socket)) {
            emitShipLeft(player, "disconnect");
            removePlayerFromGame(player);
        }
    }
}

export function isSocketLive(socket: net.Socket): boolean {
    return (!socket.destroyed && socket.writable && socket.readable);
}

export function checkEndGame(): void {
    // From 1978 docs:
    // This routine is called whenever a base or planet is destroyed
    // to see if the game is over. (all the planets gone, and one
    // side's bases).  If so, the appropriate message is printed out
    // and the job is returned to monitor level.

    //console.log("Checking for end game");
    if (settings.winner != null || !settings.generated) return;

    // Check if any planets (excluding bases) still exist - game continues if so
    const planetsExist = planets.some(p => !p.isBase);
    if (planetsExist) {
        console.log("Planets exist, game continues");
        return;
    }

    const fedBasesExist = bases.federation.length > 0;
    const empBasesExist = bases.empire.length > 0;

    // console.log("Checking for bases");
    // console.log("empBasesExist", empBasesExist);
    // console.log("fedBasesExist", fedBasesExist);
    if (!empBasesExist && fedBasesExist) {
        settings.winner = "FEDERATION";
    } else if (!fedBasesExist && empBasesExist) {
        settings.winner = "EMPIRE";
    } else if (!empBasesExist && !fedBasesExist) {
        settings.winner = "NEUTRAL";
    } else {
        return;
    }
    //console.log(settings.winner);

    let message = ``;
    if (settings.winner) {
        message += `\r\nTHE WAR IS OVER!!!\r\n`;
        if (settings.winner === "NEUTRAL") {
            message += `The entire known galaxy has been depopulated.\r\n`;
        } else {
            if (settings.winner === "FEDERATION") {
                message += `The Federation has successfully repelled the Klingon hordes!!\r\n`;
            } else {
                message += `The Klingon Empire is VICTORIOUS!!!\r\n`;
            }
        }

        for (let i = players.length - 1; i >= 0; i--) {
            const player = players[i];
            emitShipLeft(player, "endgame");
            removePlayerFromGame(player);
            if (!player.ship) continue;

            if (settings.winner === "FEDERATION" && player.ship.side === "FEDERATION") {
                message += `Congratulations. Freedom again reigns the galaxy.\r\n`;
            } else if (settings.winner === "EMPIRE" && player.ship.side === "EMPIRE") {
                message += `The Empire salutes you. Begin slave operations immediately.\r\n`;
            } else if (settings.winner === "FEDERATION" && player.ship.side === "EMPIRE") {
                message += `The Empire has fallen. Initiate self-destruction procedure.\r\n`;
            } else if (settings.winner === "EMPIRE" && player.ship.side === "FEDERATION") {
                message += `Please proceed to the nearest Klingon slave planet."\r\n`;
            }

            sendMessageToClient(player, message);
            pointsCommand(player, { key: 'POINTS', args: ['all'], raw: 'points all' });
            sendMessageToClient(player, "", true, true);

        }
        settings.generated = false;
        settings.winner = null;
        settings.gameNumber += 1;
    }
}


export function checkForBlackholes(): void {
    for (const player of players) {
        const ship = player.ship;
        if (!ship) continue;
        const { v, h } = ship.position;

        // if that ship happens to be on a black‑hole sector…
        if (blackholes.some(bh => bh.position.v === v && bh.position.h === h)) {
            sendMessageToClient(player,
                "\r\nYou have fallen into a black hole. Your ship is crushed and annihilated.");
            emitShipDestroyed(ship.name, ship.side, { v, h }, /* by */ undefined, "blackhole");

            removePlayerFromGame(player);
            sendMessageToClient(player, "", true, true);
        }
    }
}

export function removePlayerFromGame(player: Player): void {
    // Remove from global players list
    const idx = players.findIndex(p => p === player);
    if (idx !== -1) players.splice(idx, 1);
    // Remove ship from destroyedShips list if present
    // const shipIdx = destroyedShips.indexOf(player.ship.name ?? "");
    // if (shipIdx !== -1) destroyedShips.splice(shipIdx, 1);
    // Close their socket
    // playerCache.push(player);
    // player.socket?.end();
    // player.socket?.destroy();
}

// function getHitProbability(distance: number): number {
//     const maxProb = 0.65; // 65% at 0 sectors
//     const minProb = 0.05; // 5% at max range (4 for bases, 2 for planets)
//     const maxRange = 4; // or 2 for planets
//     return minProb + (maxProb - minProb) * (1 - distance / maxRange);
// }


######## gripe.ts
import { sendMessageToClient } from './communication.js';
import { Player } from './player.js';
import { players, limbo, blackholes } from './game.js';
import { Blackhole } from './blackhole.js';
import * as fs from 'fs';


//export function gripeCommand(player: Player, command: Command, done?: () => void): void {
export function gripeCommand(player: Player): void {
    if (player.ship && player.ship.condition == "RED") {
        sendMessageToClient(player, 'You are not permitted to GRIPE\nwhile under RED alert!');
        return;
    }
    player.currentPrompt = "Enter gripe, end with ^Z\r\n";
    //sendMessageToClient(player, player.currentPrompt, true, false);
    if (player.ship) {
        swapBackholeForPlayer(player);
    }
    player.multiLine = true;
    player.callBack = (pl, resp) => {
        pl.multiLine = false;
        const nowMs = Date.now();
        const currentDateTime = new Date(nowMs).toLocaleString('en-US', {
            hour12: false
        });
        fs.appendFileSync('DECWAR.GRP', `${currentDateTime} ${pl.ship?.name || 'Unknown'}: ${resp}\r\n`);
        if (limbo.includes(player) && player.ship) {
            swapPlayerForBackhole(player);
        }
        sendMessageToClient(player, 'Your gripe has been noted.', true, true);
    }
}

export function swapBackholeForPlayer(player: Player): void {
    if (!player.ship) {
        return;
    }
    const { v, h } = player.ship.position;

    // 1. Create and store the new black hole
    const bh = new Blackhole(v, h);
    blackholes.push(bh);
    limbo.push(player);

    // 2. Remove player from global players list
    const index = players.indexOf(player);
    if (index !== -1) {
        players.splice(index, 1);
    }
}

export function swapPlayerForBackhole(player: Player): void {
    if (!player.ship) {
        return;
    }
    const { v, h } = player.ship.position;

    // Find the black hole at the player's location
    const blackHoleIndex = blackholes.findIndex(bh => bh.position.v === v && bh.position.h === h);

    // If a black hole is found, remove it
    if (blackHoleIndex !== -1) {
        blackholes.splice(blackHoleIndex, 1);
    }
    const index = limbo.indexOf(player);
    if (index !== -1) {
        limbo.splice(index, 1);
    }
    players.push(player);
}

######## help.ts
import { sendMessageToClient } from "./communication.js";
import { Command } from "./command.js";
import { Player } from "./player.js";
import fs from 'fs';
import path from 'path';

const helpData = loadHelpData();
const helpCommands = getHelpCommands();
const pgCommands = ['CTl-c', 'INTRO', 'HInts', 'INput', 'Output', 'PAuses', 'PRegame'];

export function helpCommand(player: Player, command: Command): void {

    const arg = command.args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use HELP.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;


    const condition = player.ship.computeCondition();
    if (condition === 'RED') {
        sendMessageToClient(player, 'You cannot get HELP while under RED alert!');
        return;
    }

    if (!arg) {
        sendMessageToClient(player, `For a list of commands type HELP *`);
        sendMessageToClient(player, `For help on a particular command type HELP command\r\n`);
        sendMessageToClient(player, `Besides commands, help is also available for:\r\n`);
        sendMessageToClient(player, `CTL-C     INTRO     HInts     INput     Output    PAuses`);
        sendMessageToClient(player, `PRegame\r\n`);
        sendMessageToClient(player, `Upper case letters mark the shortest acceptable abbreviation.\r\n`);
    } else if (arg === '*') {
        const cmds = helpCommands;
        const lines: string[] = [];
        for (let i = 0; i < cmds.length; i += 7) {
            const row = cmds.slice(i, i + 7)
                .map(cmd => cmd.padEnd(10, ' '))
                .join('');
            lines.push(row.trimEnd());
        }

        sendMessageToClient(player, `Commands are:\r\n`);
        for (const line of lines) {
            sendMessageToClient(player, line);
        }
    } else {
        const cmd = findCommandForArg(arg, helpCommands);
        if (helpData[cmd]) {
            sendMessageToClient(player, helpData[cmd]);
        } else {
            const pgcmd = findCommandForArg(arg, pgCommands);
            console.log(">>" + pgcmd);
            if (helpData[pgcmd]) {
                sendMessageToClient(player, helpData[pgcmd]);
            } else {
                sendMessageToClient(player, `No help available for "${arg}".`);
            }
        }
    }
}

/**
 * Reads the DECWAR help file and splits it into a map from
 * COMMAND → its full help text.
 *
 * Commands are recognized by lines starting with ".COMMAND".
 */
export function loadHelpData(): Record<string, string> {
    const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/DECWAR.HLP');
    const raw = fs.readFileSync(filePath, 'utf8');
    const lines = raw.split(/\r?\n/);

    const helpData: Record<string, string> = {};
    let currentCmd: string | null = null;
    let buffer: string[] = [];

    for (const line of lines) {
        const match = line.match(/^\.(\S+)\s*$/);
        if (match) {
            if (currentCmd) {
                helpData[currentCmd] = buffer.join('\n').trim();
            }
            currentCmd = match[1].toUpperCase();
            buffer = [];
        } else if (currentCmd) {
            buffer.push(line + '\r'); // Add CR for Telnet formatting
        }
    }

    if (currentCmd) {
        helpData[currentCmd] = buffer.join('\n').trim();
    }
    return helpData;
}
export function getHelpCommands(): string[] {
    const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/DECWAR.HLP');
    const raw = fs.readFileSync(filePath, 'utf8');
    const lines = raw.split(/\r?\n/);

    const commands: string[] = [];
    const syntaxRegex = /^Syntax:\s+([A-Za-z]+)(?:\s|$)/;

    for (const line of lines) {
        const match = line.match(syntaxRegex);
        if (match) {
            const cmd = match[1];
            if (!commands.includes(cmd)) {
                commands.push(cmd);
            }
        }
    }
    return commands;
}

function findCommandForArg(arg: string, commands: string[]): string {
    // Normalize the argument for matching
    const argUpper = arg.toUpperCase();

    for (const helpCommand of commands) {
        // The canonical command, e.g., "TRACTOR"
        const cmdUpper = helpCommand.toUpperCase();

        // Find the uppercase prefix (e.g., "TR" in "TRactor")
        const match = helpCommand.match(/^([A-Z]+)/);
        if (!match) continue;
        const prefix = match[1];
        const rest = helpCommand.slice(prefix.length);

        // The arg must start with the prefix
        if (!argUpper.startsWith(prefix)) continue;

        // Now, argUpper after the prefix must be a subset (in order) of the rest (case-insensitive)
        const argRest = argUpper.slice(prefix.length);
        let restIdx = 0;
        let matched = true;
        for (let i = 0; i < argRest.length; ++i) {
            const ch = argRest[i];
            // Find ch in rest, in order
            restIdx = rest.toUpperCase().indexOf(ch, restIdx);
            if (restIdx === -1) {
                matched = false;
                break;
            }
            restIdx += 1;
        }
        if (matched) {
            return cmdUpper;
        }
    }
    return "";
}
######## list.ts
// Fully FORTRAN-faithful LIST command for DECWAR
import { Player } from './player.js';
import { Command } from './command.js';
import {
    players,
    planets,
    bases,
} from './game.js';
import { sendMessageToClient } from './communication.js';
import { Planet } from './planet.js';
import { Ship } from './ship.js';
import { chebyshev } from './coords.js';
import { DEFAULT_SCAN_RANGE, MAX_SHIELD_ENERGY, OutputSetting, SYMBOL_BASE_FED, SYMBOL_BASE_EMP, INITIAL_BASE_STRENGTH, Side } from './settings.js';
import { teamMemory } from './memory.js';

type ListClause = {
    objectFilters: string[];
    sideFilters: string[];
    rangeFilters: (string | number)[];
    locationFilters: { vpos: number; hpos: number }[];
    modes: string[];
    controlKeywords: string[];
    shipNames: string[];
};

type ParseSuccess = {
    ok: true;
    clauses: ListClause[];
};

type ParseError = {
    ok: false;
    error: string;
};

type ParseResult = ParseSuccess | ParseError;

const OBJECT_FILTERS = ["SHIPS", "BASES", "PLANETS", "PORTS"];
const SIDE_FILTERS = ["FEDERATION", "HUMAN", "EMPIRE", "KLINGON", "FRIENDLY", "ENEMY", "TARGETS", "NEUTRAL", "CAPTURED"];
const MODES = ["LIST", "SUMMARY"];
const CONTROL_KEYWORDS = ["AND", "&"];
const RANGE_KEYWORDS = ["CLOSEST", "ALL"];

export function listCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, false);
}

export function listCommandHelper(player: Player, command: Command, onlySummarize: boolean = false): void {
    const result: ParseResult = parseListCommand(command.raw);
    let ship: Ship;
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use LIST.");
        return;
    } else {
        ship = player.ship;
    }

    if (!result.ok) {
        sendMessageToClient(player, result.error);
        return;
    }

    const outputMode: OutputSetting = player.settings.output ?? "LONG";

    for (const clause of result.clauses) {
        if (clause.objectFilters.length == 0) {
            clause.objectFilters = ["SHIPS", "BASES", "PLANETS"];
        }

        let range = DEFAULT_SCAN_RANGE;
        let explicitRange = false;
        let allShips: Ship[] = [];
        let allBases: Planet[] = [];
        let allPlanets: Planet[] = [];
        const outputLines: string[] = [];

        // Determine range per DECWAR semantics:
        // - If a numeric radius is provided, use it (explicitRange = true).
        // - Otherwise, SUMMARY, CLOSEST, or ALL imply infinite radius.
        const hasAll = clause.rangeFilters.includes("ALL");
        const hasClosest = clause.rangeFilters.includes("CLOSEST");
        const hasSummary = clause.modes.includes("SUMMARY");

        const numericRanges = clause.rangeFilters.filter(r => typeof r === "number") as number[];
        if (numericRanges.length > 0) {
            range = Math.max(...numericRanges);
            explicitRange = true;
        }
        if (!explicitRange && (hasAll || hasClosest || hasSummary)) {
            range = Infinity;
        }

        // filter by objects first

        if (clause.objectFilters.includes("SHIPS")) {
            allShips = players.map(p => p.ship).filter((ship): ship is Ship => ship !== null);
        }
        if (
            clause.objectFilters.includes("BASES") ||
            clause.objectFilters.includes("PORTS")) {
            allBases = [...bases.federation, ...bases.empire];
        }
        if (clause.objectFilters.includes("PLANETS") ||
            clause.objectFilters.includes("PORTS")) {
            allPlanets = [...planets];
        }

        allPlanets = dedup(allPlanets, [...bases.federation, ...bases.empire]);

        // filters by side
        if (allShips.length > 0) {
            const filter = new Set(clause.sideFilters);
            allShips = allShips.filter(ship => isSideMatch(player, filter, ship));
        }

        if (allBases.length > 0) {
            const filter = new Set(clause.sideFilters);
            allBases = allBases.filter(base => isSideMatch(player, filter, base));
        }

        if (allPlanets.length > 0) {
            const filter = new Set(clause.sideFilters);
            allPlanets = allPlanets.filter(planet => isSideMatch(player, filter, planet));
        }

        // filters by range
        if (clause.rangeFilters.length > 0) {
            if (clause.rangeFilters.includes("CLOSEST")) {
                if (allShips.length > 0) {
                    const closestShip = allShips.reduce((a, b) =>
                    // Find the closest ship to player.ship, but skip player.ship itself
                    (a === player.ship ? b : b === player.ship ? a :
                        (chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b))
                    );
                    allShips = [closestShip];
                }
                if (allBases.length > 0) {
                    const closestBase = allBases.reduce((a, b) =>
                        chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b
                    );
                    allBases = [closestBase];
                }
                if (allPlanets.length > 0) {
                    const closestPlanet = allPlanets.reduce((a, b) =>
                        chebyshev(ship.position, a.position) <= chebyshev(ship.position, b.position) ? a : b
                    );
                    allPlanets = [closestPlanet];
                }
            }
        }

        // filter by range (collection stage)
        if (range !== Infinity) {
            allShips = allShips.filter(s => chebyshev(ship.position, s.position) <= range);
            allBases = allBases.filter(b => chebyshev(ship.position, b.position) <= range);
            allPlanets = allPlanets.filter(p => chebyshev(ship.position, p.position) <= range);
        }

        // filter by location

        // If there are any location filters, filter objects to those locations
        if (clause.locationFilters.length > 0) {
            // For ships, match if their position matches any location filter
            allShips = allShips.filter(ship =>
                clause.locationFilters.some(loc =>
                    ship.position.h === loc.hpos && ship.position.v === loc.vpos
                )
            );
            // For bases, match if their x/y matches any location filter
            allBases = allBases.filter(base =>
                clause.locationFilters.some(loc =>
                    base.position.h === loc.hpos && base.position.v === loc.vpos
                )
            );
            // For planets, match if their position matches any location filter
            allPlanets = allPlanets.filter(planet =>
                clause.locationFilters.some(loc =>
                    planet.position.h === loc.hpos && planet.position.v === loc.vpos
                )
            );
        }

        const summarize = clause.modes.includes("SUMMARY");
        const viewRadius = range === Infinity ? Number.POSITIVE_INFINITY : range;
        // SUMMARY/CLOSEST/ALL behave like an explicit wide query; show coords even if normally "out of range".
        const bypassMemory = explicitRange || hasAll || hasClosest || hasSummary;

        // Show full object listings (as in 2.2 LIST default)
        const finalShips = [];
        const finalBases = [];
        const finalPlanets = [];
        let needReturn = false;

        const qualifier = explicitRange ? "in specified range" : "in game";

        for (const ship of allShips) {
            const line = formatShipLine(ship, outputMode, player, viewRadius, bypassMemory);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalShips.push(ship);
            }
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const shipSummary: ListSummary = summarizeShips(finalShips);
            printSummary(shipSummary, "ships", qualifier, outputLines);
            if (finalShips.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        for (const base of allBases) {
            const line = formatBaseLine(base, outputMode, player, viewRadius, bypassMemory);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalBases.push(base);
            }
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const baseSummary: ListSummary = summarizeBases(finalBases);
            printSummary(baseSummary, "bases", qualifier, outputLines);
            if (finalBases.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        for (const planet of allPlanets) {
            const line = formatPlanetLine(planet, outputMode, player, viewRadius, bypassMemory);
            if (line) {
                if (!onlySummarize) {
                    outputLines.push(line);
                    needReturn = true;
                }
                finalPlanets.push(planet);
            }
        }


        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (summarize) {
            const planetSummary: ListSummary = summarizePlanets(finalPlanets);
            printSummary(planetSummary, "planets", qualifier, outputLines);
            if (finalPlanets.length > 0) needReturn = true;
        }

        if (needReturn) {
            outputLines.push("");
            needReturn = false;
        }

        if (outputLines.length === 0) {
            sendMessageToClient(player, "Nothing matches your LIST criteria.");
        } else {
            for (const line of outputLines) {
                sendMessageToClient(player, line);
            }
        }

    }

}

function formatShipLine(
    ship: Ship,
    mode: OutputSetting,
    viewer: Player,
    viewRadius: number = DEFAULT_SCAN_RANGE,
    bypassMemory: boolean = false
): string | null {
    if (ship.romulanStatus.isRomulan && ship.romulanStatus.cloaked) {
        return null;
    }
    if (!viewer.ship) {
        return null;
    }

    const distance = chebyshev(ship.position, viewer.ship.position);
    const isEnemy = ship.side !== viewer.ship.side;
    const isOutOfRange = isEnemy && distance > viewRadius;
    //const { v, h } = ship.position;
    const flag = (ship.side !== viewer.ship.side) ? "*" : " ";

    let coord = 'out of range';
    const name = ship.name ?? '??';
    let fullName = (name[0].toUpperCase() + name.slice(1).toLowerCase()).padEnd(12);
    let percent = "%";
    const shieldPct = (ship.shieldEnergy / MAX_SHIELD_ENERGY) * 100;
    let shieldDisplay = `+${shieldPct.toFixed(0)}${percent}`.padStart(7);


    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = name[0].toUpperCase().padEnd(3);
        percent = " ";
    }

    if (!isOutOfRange) {
        coord = `${formatCoordsForPlayer2(ship.position.v, ship.position.h, viewer)}`;
        if (mode === "SHORT" || mode === "MEDIUM") {
            shieldDisplay = `+${shieldPct.toFixed(1)}${percent}`.padStart(9);
        } else {
            coord = `@${coord}`;
        }
    } else {
        // If caller asked for extended list (ALL / explicit radius), still show coords
        if (bypassMemory) {
            coord = `${formatCoordsForPlayer2(ship.position.v, ship.position.h, viewer)}`;
        } else {
            shieldDisplay = '';
        }
    }

    if (mode === "SHORT" || mode === "MEDIUM") {
        return `${flag}${fullName}${coord} ${shieldDisplay}`;
    } else {
        return `${flag}${fullName}${coord}${shieldDisplay}`;
    }
}

function formatBaseLine(
    base: Planet,
    mode: OutputSetting,
    viewer: Player,
    viewRadius: number = DEFAULT_SCAN_RANGE,
    bypassMemory: boolean = false
): string | null {
    if (!viewer.ship) {
        return null;
    }
    const distance = chebyshev(base.position, viewer.ship.position);
    if (distance > viewRadius && base.side !== viewer.ship.side && !bypassMemory) {
        const memory = viewer.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
        if (!memory.has(`${base.position.v},${base.position.h}`)) {
            return null;
        }
    }

    const name = base.side.slice(0, 3).charAt(0).toUpperCase() + base.side.slice(1, 3).toLowerCase();
    const isEnemy = base.side !== viewer.ship.side;
    const flag = isEnemy ? "*" : " ";
    let fullName;
    let percent;

    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = (base.side === "FEDERATION" ? SYMBOL_BASE_FED : base.side === "EMPIRE" ? SYMBOL_BASE_EMP : base.side.slice(0, 3)).padEnd(3);
        percent = " ";
    } else {
        fullName = ((name[0].toUpperCase() + name.slice(1).toLowerCase()) + " Base").padEnd(12);
        percent = "%";
    }

    const coord = `${formatCoordsForPlayer2(base.position.v, base.position.h, viewer)}`;
    //const delta = `${dx >= 0 ? "+" : ""}${dx},${dy >= 0 ? "+" : ""}${dy}`.padStart(9);
    const shieldPct = (base.energy / INITIAL_BASE_STRENGTH) * 100;
    let shieldDisplay = `+${shieldPct.toFixed(1)}${percent}`.padStart(9);
    if (mode === "SHORT" || mode === "MEDIUM") {
        shieldDisplay = `${shieldPct.toFixed(0)}${percent}`.padStart(8);
        return `${flag}${fullName}${coord}${shieldDisplay}`;
    } else {
        return `${flag}${fullName}@${coord}${shieldDisplay}`;
    }
}

function formatPlanetLine(
    planet: Planet,
    mode: OutputSetting,
    viewer: Player,
    viewRadius: number = DEFAULT_SCAN_RANGE,
    bypassMemory: boolean = false
): string | null {
    if (!viewer.ship) {
        return null;
    }
    const distance = chebyshev(planet.position, viewer.ship.position);
    if (distance > viewRadius && !bypassMemory) {
        const memory = viewer.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
        if (!memory.has(`${planet.position.v},${planet.position.h}`)) {
            return null;
        }
    }

    const name = planet.side.slice(0, 3).charAt(0).toUpperCase() + planet.side.slice(1, 3).toLowerCase() + " planet";
    const isEnemy = planet.side !== viewer.ship.side && planet.side !== "NEUTRAL";
    let flag;
    if (isEnemy) {
        flag = "*";
    } else if (planet.side === "NEUTRAL") {
        flag = " ";
    } else {
        flag = "-";
    }

    let fullName, builds;
    let coord = `${formatCoordsForPlayer2(planet.position.v, planet.position.h, viewer)}`
    if (mode === "SHORT" || mode === "MEDIUM") {
        fullName = "@";
        builds = (planet.builds + "").padStart(6);
        if (planet.builds == 0) builds = "";
        return ` ${flag}${fullName} ${coord}${builds}`;
    } else {
        builds = planet.builds + " builds".padStart(5);
        fullName = name.padEnd(12);
        const pad = (viewer.settings.ocdef !== "BOTH") ? 10 : 18;
        coord = coord.padEnd(pad);
        if (planet.builds == 0) builds = "";
        const sep = (viewer.settings.ocdef === "RELATIVE") ? "" : "@";
        return `${flag}${fullName}${sep}${coord}${builds}`;
    }
}

export function parseListCommand(input: string): ParseResult {
    try {
        const tokens = tokenize(input.toUpperCase());
        const clauses: ListClause[] = [];
        let current: ListClause = emptyClause();

        while (tokens.length > 0) {
            const token = tokens[0];

            if (matchesKeyword(token, CONTROL_KEYWORDS)) {
                tokens.shift();
                clauses.push(current);
                current = emptyClause();
            } else if (matchesKeyword(token, OBJECT_FILTERS)) {
                current.objectFilters.push(matchAndShift(tokens, OBJECT_FILTERS)!);
            } else if (matchesKeyword(token, SIDE_FILTERS)) {
                current.sideFilters.push(matchAndShift(tokens, SIDE_FILTERS)!);
            } else if (matchesKeyword(token, MODES)) {
                current.modes.push(matchAndShift(tokens, MODES)!);
            } else if (matchesKeyword(token, RANGE_KEYWORDS)) {
                current.rangeFilters.push(matchAndShift(tokens, RANGE_KEYWORDS)!);
            } else if (!isNaN(Number(token))) {
                const vpos = Number(tokens.shift());
                if (tokens.length > 0 && /^[0-9]+$/.test(tokens[0])) {
                    const hpos = Number(tokens.shift());
                    current.locationFilters.push({ vpos, hpos });
                } else {
                    current.rangeFilters.push(vpos);
                }
            } else if (/^[A-Z]+$/.test(token)) {
                current.shipNames.push(tokens.shift()!);
            } else {
                return { ok: false, error: "Unknown token: " + token };
            }
        }

        clauses.push(current);
        return { ok: true, clauses };
    } catch (e: unknown) {
        return { ok: false, error: e instanceof Error ? e.message : "Unexpected parsing error" };
    }
}

function emptyClause(): ListClause {
    return {
        objectFilters: [],
        sideFilters: [],
        rangeFilters: [],
        locationFilters: [],
        modes: [],
        controlKeywords: [],
        shipNames: [],
    };
}

function tokenize(input: string): string[] {
    return input.trim().split(/\s+/);
}

function matchesKeyword(token: string, options: string[]): boolean {
    return options.some(opt => opt.startsWith(token));
}

function matchAndShift(tokens: string[], options: string[]): string | null {
    const token = tokens[0];
    const match = options.find(opt => opt.startsWith(token));
    if (match) {
        tokens.shift();
        return match;
    }
    return null;
}

//isSideMatch(player, ship.side, filter, ship));

function isSideMatch(player: Player, filter: Set<string>, target: Ship | Planet): boolean {
    if (!player.ship) {
        return false;
    }
    const playerSide = player.ship.side;
    const targetSide = target.side;

    if (filter.size === 0) return true;

    if (filter.has("CAPTURED")) {
        if (target instanceof Planet) {
            if (target.side === "NEUTRAL") return false;
        } else {
            return false;
        }
    }
    if (filter.has("HUMAN") || filter.has("FEDERATION")) {
        if (targetSide === "EMPIRE" || targetSide === "ROMULAN" || targetSide === "NEUTRAL") return false;
    }
    if (filter.has("KLINGON") || filter.has("EMPIRE")) {
        if (targetSide === "FEDERATION" || targetSide === "ROMULAN" || targetSide === "NEUTRAL") return false;
    }
    if (filter.has("FRIENDLY") && (playerSide !== targetSide || targetSide === "NEUTRAL")) return false;

    if (filter.has("ENEMY") || filter.has("TARGETS")) {
        if ((playerSide === targetSide) || targetSide === "NEUTRAL" as Side) return false;
    }
    if (filter.has("NEUTRAL") && (targetSide as Side) !== "NEUTRAL") return false;

    return true;
}

export function formatCoordsForPlayer2(
    targetV: number,
    targetH: number,
    player: Player
): string {
    if (!player.ship) {
        return "";
    }
    const abs = `${targetV.toString().padStart(2, ' ')}-${targetH.toString().padStart(2, ' ')}`;
    const relV = targetV - player.ship.position.v;
    const relH = targetH - player.ship.position.h;

    // Format with sign only for non-zero
    const formatRel = (num: number) => {
        if (num === 0) return "0";
        return (num > 0 ? "+" : "") + num;
    };

    const rel = `${formatRel(relV)},${formatRel(relH).padStart(3)}`.padStart(7);


    //@48-70 -10, +5
    switch (player.settings.ocdef) {
        case "RELATIVE":
            return rel;
        case "BOTH":
            return `${abs} ${rel}`;
        case "ABSOLUTE":
        default:
            return abs;
    }
}

function dedup(planets: Planet[], bases: Planet[]): Planet[] {
    // Create a Set of base coordinates as "y-x" strings for fast lookup
    const baseCoords = new Set(bases.map(b => `${b.position.v}-${b.position.h}`));
    // Filter out any planet whose coords match a base
    return planets.filter(p => !baseCoords.has(`${p.position.v}-${p.position.h}`));
}

function printSummary(summary: ListSummary, label: string, qualifier: string, outputLines: string[]): void {
    if (summary.FEDERATION > 0) outputLines.push(summary.FEDERATION + ` Federation ${label} ${qualifier}`);
    if (summary.EMPIRE > 0) outputLines.push(summary.EMPIRE + ` Empire ${label} ${qualifier}`);
    if (summary.ROMULAN > 0) outputLines.push(summary.ROMULAN + ` Romulan ${label} ${qualifier}`);
    if (summary.NEUTRAL > 0) outputLines.push(summary.NEUTRAL + ` Neutral ${label} ${qualifier}`);
}


export function summaryCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, true);
}

export interface ListSummary {
    FEDERATION: number;
    EMPIRE: number;
    ROMULAN: number;
    NEUTRAL: number;
}

/**
 * Counts ships by side (FEDERATION, EMPIRE, ROMULAN) from the provided array.
 * Assumes all ships in the array are vetted and valid.
 * @param ships - Array of Player objects representing ships to count.
 * @returns A ShipSummary object containing counts of ships by side.
 */
export function summarizeShips(ships: Ship[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const ship of ships) {
        if (ship.romulanStatus?.isRomulan) {
            summary.ROMULAN += 1;
        } else if (ship.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (ship.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        }
    }

    return summary;
}


/**
 * Counts bases by side (FEDERATION, EMPIRE) from the provided array.
 * Assumes all bases in the array are vetted and valid.
 * @param bases - Array of Base objects to count.
 * @returns A BaseSummary object containing counts of bases by side.
 */
export function summarizeBases(bases: Planet[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const base of bases) {
        if (base.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (base.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        }
    }

    return summary;
}

/**
 * Counts planets by side (FEDERATION, EMPIRE, NEUTRAL) from the provided array.
 * Assumes all planets in the array are vetted and valid, with no base overlaps.
 * @param planets - Array of Planet objects to count.
 * @returns A PlanetSummary object containing counts of planets by side.
 */
export function summarizePlanets(planets: Planet[]): ListSummary {
    const summary: ListSummary = {
        FEDERATION: 0,
        EMPIRE: 0,
        ROMULAN: 0,
        NEUTRAL: 0
    };

    for (const planet of planets) {
        if (planet.side === 'FEDERATION') {
            summary.FEDERATION += 1;
        } else if (planet.side === 'EMPIRE') {
            summary.EMPIRE += 1;
        } else if (planet.side === 'NEUTRAL') {
            summary.NEUTRAL += 1;
        }
    }

    return summary;
}
######## memory.ts
import { Player } from "./player.js";
import { Planet } from "./planet.js";


export const teamMemory = {
    federation: new Map<string, Planet>(),
    empire: new Map<string, Planet>()
};

// export function addBaseToMemory(player: Player, base: Base): void {
//     const memory = player.ship.side === "FEDERATION" ? teamBaseMemory.federation : teamBaseMemory.empire;
//     memory.bases.set(`${base.y},${base.x}`, base);
// }

export function addPlanetToMemory(player: Player, planet: Planet): void {
    if (!player.ship) return;

    const memory = player.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
    memory.set(`${planet.position.v},${planet.position.h}`, planet);
}

// export function removeBaseFromMemory(base: Base): void {
//     teamMemory.federation.bases.delete(`${base.y},${base.x}`);
//     teamMemory.empire.bases.delete(`${base.y},${base.x}`);
// }

export function removePlanetFromMemory(planet: Planet): void {
    teamMemory.federation.delete(`${planet.position.v},${planet.position.h}`);
    teamMemory.empire.delete(`${planet.position.v},${planet.position.h}`);
}

// export function isBaseInMemory(player: Player, base: Base): boolean {
//     const memory = player.ship.side === "FEDERATION" ? teamBaseMemory.federation : teamBaseMemory.empire;
//     return memory.bases.has(`${base.y},${base.x}`);
// }

export function isPlanetInMemory(player: Player, planet: Planet): boolean {
    if (!player.ship) return false;
    const memory = player.ship.side === "FEDERATION" ? teamMemory.federation : teamMemory.empire;
    return memory.has(`${planet.position.v},${planet.position.h}`);
}
######## move.ts
import {
    sendMessageToClient,
    putClientOnHold,
    releaseClient,
    sendOutputMessage,
    addPendingMessage
} from "./communication.js";
import { Ship, applyDeviceDamage } from "./ship.js";
import { bresenhamLine } from "./coords.js";
import { GRID_WIDTH, GRID_HEIGHT, WARP_DELAY_MIN_MS, WARP_DELAY_RANGE, IMPULSE_DELAY_MS, IMPULSE_DELAY_RANGE } from "./settings.js";
import { ran, iran } from "./util/random.js";
import { isInBounds, getCoordsFromCommandArgs, findObjectAtPosition, ocdefCoords, isAdjacent, getTrailingPosition } from "./coords.js";
import { Player } from "./player.js";
import { Command } from "./command.js";
import { gameEvents } from "./api/events.js";
import { ShipMovedPayload, emitShipUndocked } from "./api/events.js";


import { disconnectTractor } from "./tractor.js";

export function moveCommand(player: Player, command: Command, done?: () => void): void {

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        done?.();
        return;
    }

    const args = command.args;
    const ship = player.ship;

    if (!player.ship.isDeviceOperational("warp")) {
        done?.();
        return;
    }

    if (!args.length) {
        sendMessageToClient(player, "Usage: MOVE/IMPULSE [A|R|C] <vpos> <hpos> OR MOVE C <ship>");
        done?.();
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        args,
        ship.position.v,
        ship.position.h,
        true
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "MOVE > BAD COORD",
            MEDIUM: `Bad MOVE input (${mode})`,
            LONG: `Invalid MOVE command: ${error} in ${mode}`
        });
        done?.();
        return;
    }

    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "MOVE > OUT OF BOUNDS",
            MEDIUM: "Invalid MOVE target sector.",
            LONG: `Target sector must be within 1–${GRID_WIDTH}.`
        });
        done?.();
        return;
    }

    const startV = ship.position.v;
    const startH = ship.position.h;
    const dv = Math.abs(targetVInput - startV);
    const dh = Math.abs(targetHInput - startH);
    const warp = Math.max(dv, dh);

    if (warp === 0) {
        sendOutputMessage(player, {
            SHORT: "MOVE > SAME",
            MEDIUM: "Already there.",
            LONG: "You're already at that position."
        });
        done?.();
        return;
    }

    if (warp > 6) {
        sendOutputMessage(player, {
            SHORT: "MOVE > WARP MAX",
            MEDIUM: "Warp too far. Max 6.",
            LONG: "Warp factor too high. Maximum warp is 6 sectors."
        });
        done?.();
        return;
    }

    maybeDamageFromWarp(ship, warp);

    let multiplier = 1;
    if (ship.shieldsUp) {
        multiplier = 2;
    }
    if (ship.tractorPartner) {
        multiplier = 3;
    }

    const energyCost = 4 * warp * warp * multiplier;

    if (ship.energy < energyCost) {
        sendOutputMessage(player, {
            SHORT: `MOVE > NO E`,
            MEDIUM: `Energy too low: need ${energyCost}`,
            LONG: `Not enough energy. Needed: ${energyCost}, Available: ${ship.energy}`
        });
        done?.();
        return;
    }

    if (ship.docked) {
        const planet = ship.dockPlanet; // full Planet object (may be null)

        // flip state first
        ship.docked = false;
        ship.dockPlanet = null;

        // emit SSE event (only if we know where we were docked)
        if (planet) {
            emitShipUndocked(player, planet, "launch");
            const where = planet.isBase ? `${planet.side} base ${planet.name}` : `planet ${planet.name}`;
            sendMessageToClient(player, `You have undocked from ${where}.`);
        } else {
            // fallback (edge cases where the planet ref was lost)
            sendMessageToClient(player, "You have undocked from the base.");
        }
    }

    // —— Collision Detection ——  
    const destination = { v: targetVInput, h: targetHInput };
    let prevPoint = { v: startV, h: startH };
    let collisionDetected = false;

    for (const pt of bresenhamLine(startV, startH, destination.v, destination.h)) {
        const { v, h } = pt;
        if (v === startV && h === startH) continue;

        if (findObjectAtPosition(v, h)) {
            destination.h = prevPoint.h;
            destination.v = prevPoint.v;
            collisionDetected = true;
            break;
        }

        prevPoint = pt;
    }

    const originalEnergy = ship.energy;
    ship.energy -= energyCost;

    //updateShipCondition(player);  TODO    

    maybeMisnavigate(player, destination);

    const delayMs = WARP_DELAY_MIN_MS + ran() * WARP_DELAY_RANGE;
    const formattedTarget = ocdefCoords(player.settings.ocdef, player.ship.position, { v: destination.v, h: destination.h });

    putClientOnHold(player, `Warping to ${formattedTarget} (warp ${warp})...`);

    const message = collisionDetected
        ? "Navigation Officer: Collision averted, Captain!"
        : `${ship.name} now in sector ${formattedTarget}.`;

    const timer = setTimeout(() => {
        // Check again just before moving
        if (findObjectAtPosition(destination.v, destination.h)) {
            releaseClient(player);
            ship.energy = originalEnergy;
            sendMessageToClient(player, "Warp aborted: sector is now occupied.");
        } else {
            releaseClient(player);
            const from = { v: ship.position.v, h: ship.position.h };
            ship.position = { v: destination.v, h: destination.h };
            const to = { v: destination.v, h: destination.h };

            // add if emitting todo
            gameEvents.emit<ShipMovedPayload>({
                type: "ship_moved",
                payload: {
                    shipName: ship.name,
                    side: ship.side,
                    from,
                    to,
                    distance: Math.max(Math.abs(to.v - from.v), Math.abs(to.h - from.h)),
                },
            });

            sendMessageToClient(player, message);
            if (ship.tractorPartner) tractorShip(ship);
        }
        done?.();
    }, delayMs);
    player.currentCommandTimer = timer;
    //starbasePhaserDefense(player); TODO
}

function maybeDamageFromWarp(ship: Ship, warpDistance: number): void {
    if (warpDistance <= 4) return;

    if (warpDistance >= 5) {
        sendMessageToClient(ship.player, `Warning: warp factor ${warpDistance} may damage engines`);
        let damage = 0;
        if (warpDistance === 5 && ran() < 0.2) {
            damage = 100;
        } else if (warpDistance >= 6 && ran() < 0.5) {
            damage = 200;
        }

        if (damage > 0) {
            const status = damage >= 300 ? "destroyed" : "damaged";
            applyDeviceDamage(ship, damage, ["warp"]);
            sendMessageToClient(ship.player, `Warp engines ${status}`);
        }
    }
}

export function impulseCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        done?.();
        return;
    }

    const ship = player.ship;

    if (!ship.isDeviceOperational("impulse")) {
        done?.();
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        command.args,
        ship.position.v,
        ship.position.h,
        false // COMPUTED not allowed for IMPULSE
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "IMP > BAD COORD",
            MEDIUM: `Bad IMPULSE input (${mode})`,
            LONG: `Invalid IMPULSE command: ${error} in ${mode}`
        });
        done?.();
        return;
    }

    const destination = { v: targetVInput, h: targetHInput };

    // DECWAR: only cardinal directions allowed
    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "IMP > RANGE",
            MEDIUM: "Not in bounds.",
            LONG: "IMPULSE move must be to a sector within the grid."
        });
        done?.();
        return;
    }

    // DECWAR: only cardinal directions allowed
    if (!isAdjacent(ship.position, destination)) {
        sendOutputMessage(player, {
            SHORT: "IMP > RANGE",
            MEDIUM: "Not adjacent.",
            LONG: "IMPULSE move must be to an adjacent sector."
        });
        done?.();
        return;
    }

    if (findObjectAtPosition(destination.v, destination.h)) {
        sendOutputMessage(player, {
            SHORT: "IMP > OCCUPIED",
            MEDIUM: "Impulse failed: blocked.",
            LONG: "IMPULSE failed: destination sector is occupied."
        });
        done?.();
        return;
    }

    let energyCost = 1;   // TODO check this to match move
    if (ship.shieldsUp) {
        energyCost *= 2;
    }
    // TODO tractor?

    if (ship.energy < energyCost) {
        sendOutputMessage(player, {
            SHORT: "IMP > NO E",
            MEDIUM: "Not enough energy.",
            LONG: "IMPULSE failed: not enough energy."
        });
        done?.();
        return;
    }

    if (ship.docked) {
        const planet = ship.dockPlanet; // full Planet object (may be null)

        // flip state first
        ship.docked = false;
        ship.dockPlanet = null;

        // emit SSE event (only if we know where we were docked)
        if (planet) {
            emitShipUndocked(player, planet, "launch");
            const where = planet.isBase ? `${planet.side} base ${planet.name}` : `planet ${planet.name}`;
            sendMessageToClient(player, `You have undocked from ${where}.`);
        } else {
            // fallback (edge cases where the planet ref was lost)
            sendMessageToClient(player, "You have undocked from the base.");
        }
    }

    ship.energy -= 4 * energyCost;

    // updateShipCondition(player);  TODO

    maybeMisnavigate(player, destination);  // TODO TEST

    putClientOnHold(player, "Impulse power...");


    const delayMs = IMPULSE_DELAY_MS + ran() * IMPULSE_DELAY_RANGE;

    const timer = setTimeout(() => {
        releaseClient(player);
        if (findObjectAtPosition(destination.v, destination.h)) {
            sendOutputMessage(player, {
                SHORT: "IMP > NOW BLOCKED",
                MEDIUM: "Impulse failed: now occupied.",
                LONG: "IMPULSE failed: destination sector is now occupied."
            });
            done?.();
            return;
        }

        const coords = ocdefCoords(player.settings.ocdef, ship.position, destination);
        ship.position = destination;
        sendMessageToClient(player, `IMPULSE complete to sector ${coords}`);

        tractorShip(ship);
        done?.();
    }, delayMs);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player);  TODO
}

function maybeMisnavigate(player: Player, destination: { v: number; h: number }): void {
    if (!player.ship) return;
    const ship = player.ship;

    if (ship.devices.computer >= 300) {
        sendMessageToClient(player, "Navigation is inexact: computer inoperative.");

        const offsetV = iran(3) - 1;
        const offsetH = iran(3) - 1; // -1..+1

        destination.v = Math.max(1, Math.min(GRID_HEIGHT, destination.v + offsetV));
        destination.h = Math.max(1, Math.min(GRID_WIDTH, destination.h + offsetH));
    }
}

function tractorShip(ship: Ship): void {
    if (!ship.tractorPartner) return;

    const trailingPosition = getTrailingPosition(ship.position, ship.tractorPartner.position);
    if (!trailingPosition) {
        disconnectTractor(ship);
    } else {
        ship.tractorPartner.position = trailingPosition;
        const coords = ocdefCoords(ship.tractorPartner.player.settings.ocdef, ship.tractorPartner.position, trailingPosition);
        sendMessageToClient(ship.tractorPartner.player, `${ship.name} has moved to ${coords}.`);
        addPendingMessage(ship.tractorPartner.player, `You were tractored to @${trailingPosition.v}-${trailingPosition.h}}.`);
    }
}


######## news.ts
import { sendMessageToClient } from './communication.js';
import { Player } from './player.js';
import fs from 'fs';
import path from 'path';

let newsLog: string[] = [];

export function newsCommand(player: Player): void {
    if (newsLog.length === 0) {
        const filePath = path.resolve(path.dirname(new URL(import.meta.url).pathname), 'help/news.txt');
        const raw = fs.readFileSync(filePath, 'utf8');
        newsLog = raw.split(/\r?\n/);
    }

    if (newsLog.length === 0) {
        sendMessageToClient(player, "No news at this time.");
        return;
    }

    for (const line of newsLog) {
        sendMessageToClient(player, `${line}`);
    }
    sendMessageToClient(player, "");
}

######## nova.ts
import { sendMessageToClient, sendMessageToOthersWithFormat } from "./communication.js";
import { ran } from "./util/random.js";
import { players, stars, pointsManager, removePlayerFromGame, planets, bases, checkEndGame, blackholes, SHIP_FATAL_DAMAGE } from "./game.js";
import { Player } from "./player.js";
import { ocdefCoords, isAdjacent } from "./coords.js";
import { disconnectTractorWithReason } from "./tractor.js";
import { Planet } from "./planet.js";
import { Ship } from "./ship.js";
import { emitShipUndocked, emitNovaTriggered, emitObjectDisplaced } from "./api/events.js";

// Check if a position is within the galaxy (Fortran: ingal)
function isInGalaxy(v: number, h: number): boolean {
    // Assuming galaxy is 0–99 for both v and h (adjust based on your game)
    return v >= 0 && v <= 99 && h >= 0 && h <= 99;
}

// Check if a position is empty or contains a black hole (Fortran: dispc)
function getPositionType(v: number, h: number): string {
    if (blackholes.some(bh => bh.position.v === v && bh.position.h === h)) {
        return "BLACK_HOLE";
    }

    if (
        players.some(p => p.ship && p.ship.position.v === v && p.ship.position.h === h) ||
        planets.some(p => p.position.v === v && p.position.h === h) ||
        bases.federation.some(b => b.position.v === v && b.position.h === h) ||
        bases.empire.some(b => b.position.v === v && b.position.h === h)
    ) {
        return "OCCUPIED";
    }
    return "EMPTY";
}

// Displace a ship or base to a new position (Fortran: setdsp)
function displaceObject(
    obj: Ship | Planet,
    newV: number,
    newH: number,
    reason: "nova" | "blackhole" | "other" = "nova"
): void {
    // Ship path
    if (obj instanceof Ship) {
        const ship = obj;
        const from = { v: ship.position.v, h: ship.position.h };
        const wasDockPlanet = ship.docked ? ship.dockPlanet : null;

        // Move ship
        ship.position.v = newV;
        ship.position.h = newH;
        ship.condition = "RED";

        // If docked, nova/blackhole knocks it loose → emit ship_undocked(reason)
        if (ship.docked) {
            ship.docked = false;
            ship.dockPlanet = null;

            // attribute event/message to the current owner of this ship, if any
            const owner = players.find((p) => p.ship === ship);
            if (owner && wasDockPlanet) {
                emitShipUndocked(owner, wasDockPlanet, reason);
                const where = wasDockPlanet.isBase
                    ? `${wasDockPlanet.side} base ${wasDockPlanet.name}`
                    : `planet ${wasDockPlanet.name}`;
                sendMessageToClient(owner, `Shock dislodged you from ${where}.`);
            }
        }

        // Broadcast generic displacement for the ship
        emitObjectDisplaced("ship", ship.name, from, { v: newV, h: newH }, reason);
        return;
    }

    // Planet path
    const planet = obj as Planet;
    const from = { v: planet.position.v, h: planet.position.h };

    planet.position.v = newV;
    planet.position.h = newH;

    // Keep bases array in sync if this planet is a base
    if (planet.isBase) {
        const arr = planet.side === "FEDERATION" ? bases.federation : bases.empire;
        const idx = arr.findIndex((b) => b === planet);
        if (idx !== -1) {
            arr[idx].position.v = newV;
            arr[idx].position.h = newH;
        }
    }

    // Broadcast generic displacement for the planet
    emitObjectDisplaced("planet", planet.name, from, { v: newV, h: newH }, reason);
}


export function triggerNovaAt(player: Player, v: number, h: number): void {
    if (!player.ship) return;

    emitNovaTriggered({ v, h }, player);
    communicateNova(player, v, h);

    const directions = [
        { disV: -1, disH: 0 }, // Up
        { disV: 1, disH: 0 },  // Down
        { disV: 0, disH: -1 }, // Left
        { disV: 0, disH: 1 },  // Right
    ];

    // Handle ships
    for (const other of players) {
        if (!other.ship) continue;

        if (isAdjacent(other.ship.position, { v, h })) {
            const damage = 1000 + ran() * 2000;
            applyNovaDamageShip(player, other, damage, v, h);

            // Find tractoring player (if any)
            const tractoringShip = other.ship.tractorPartner

            // Attempt displacement (Fortran: JUMP)
            const oldV = other.ship.position.v;
            const oldH = other.ship.position.h;

            for (const { disV, disH } of directions) {
                const newV = oldV + disV;
                const newH = oldH + disH;

                if (!isInGalaxy(newV, newH)) continue;
                if (!isAdjacent({ v: oldV, h: oldH }, { v: newV, h: newH })) continue;

                const posType = getPositionType(newV, newH);
                if (posType === "BLACK_HOLE") {
                    destroyShipByNova(other, newV, newH);
                    sendMessageToClient(other, `Your ship was displaced into a black hole at ${newV}-${newH} by a nova!`);
                    if (player !== other && player.ship) {
                        pointsManager.addEnemiesDestroyed(1, player, player.ship.side);
                    }
                    if (tractoringShip) {
                        disconnectTractorWithReason(tractoringShip, `Target destroyed by black hole at ${newV}-${newH}`);
                    }
                    break;
                } else if (posType === "EMPTY") {
                    displaceObject(other.ship, newV, newH);
                    sendMessageToClient(other, `Your ship was displaced to ${newV}-${newH} by a nova!`);
                    break;
                }
                //TODO and what if another ship or planet?
            }
            // Removed: if (!displaced) { disconnectTractorWithReason(other.ship, "nova"); }
        }
    }

    // Handle planets and bases
    for (const planet of planets) {
        if (isAdjacent(planet.position, { v, h })) {
            if (planet.isBase) {
                const side = planet.side;
                if (side !== "FEDERATION" && side !== "EMPIRE") continue;
                const basesArray = side === "FEDERATION" ? bases.federation : bases.empire;
                const base = basesArray.find(b => b.position.v === planet.position.v && b.position.h === planet.position.h);
                if (!base) continue;

                const oldV = base.position.v;
                const oldH = base.position.h;

                for (const { disV, disH } of directions) {
                    const newV = oldV + disV;
                    const newH = oldH + disH;

                    if (!isInGalaxy(newV, newH)) continue;
                    if (!isAdjacent({ v: oldV, h: oldH }, { v: newV, h: newH })) continue;

                    const posType = getPositionType(newV, newH);
                    if (posType === "BLACK_HOLE") {
                        base.energy = 0;
                        planet.isBase = false;
                        basesArray.splice(basesArray.indexOf(base), 1);
                        sendMessageToClient(player, `Base at ${oldV}-${oldH} was displaced into a black hole at ${newV}-${newH} by a nova!`);
                        if (player.ship.side !== side) {
                            pointsManager.addDamageToBases(10000, player, player.ship.side);
                        } else {
                            pointsManager.addDamageToBases(-10000, player, player.ship.side);
                        }
                        checkEndGame();
                        break;
                    } else if (posType === "EMPTY") {
                        displaceObject(base, newV, newH);
                        planet.position.v = newV;
                        planet.position.h = newH;
                        sendMessageToClient(player, `Base at ${oldV}-${oldH} was displaced to ${newV}-${newH} by a nova!`);
                        break;
                    }
                }
            }

            applyNovaDamagePlanet(player, planet, v, h);
        }
    }

    removeStarAt(v, h);
    pointsManager.addStarsDestroyed(1, player, player.ship.side);

    let time = 300;
    for (const star of stars.slice()) {
        if (isAdjacent(star.position, { v, h }) && ran() < 0.8) {
            setTimeout(() => {
                triggerNovaAt(player, star.position.v, star.position.h);
            }, time);
            time += 200;
        }
    }
}

function communicateNova(player: Player, v: number, h: number): void {
    if (!player.ship) return;
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });

    const shooterMsg = player.settings.output === "SHORT"
        ? `NOVA @${coords}`
        : `A nova has detonated at ${coords}!`;
    sendMessageToClient(player, shooterMsg);

    sendMessageToOthersWithFormat(player, (recipient) => {
        const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
        return recipient.settings.output === "SHORT"
            ? `NOVA @${formatted}`
            : `A nova has detonated at ${formatted}!`;
    });
}

function applyNovaDamageShip(attacker: Player, player: Player, damage: number, v: number, h: number): void {
    if (!player.ship) return;
    player.ship.energy = Math.max(0, player.ship.energy - damage);
    player.ship.damage += damage / 2;
    player.ship.condition = "RED";

    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });
    const msg = player.settings.output === "SHORT"
        ? `HIT -${Math.round(damage)}`
        : `You were hit by a nova at ${coords} for ${Math.round(damage)} damage!`;
    sendMessageToClient(player, msg);

    if (player.ship.energy <= 0 || player.ship.damage >= SHIP_FATAL_DAMAGE) {
        // Credit kill once (ship or installation path elsewhere). For ship attacker:
        if (attacker && attacker !== player && attacker.ship) {
            if (player.ship && !player.ship.__killCredited) {
                player.ship.__killCredited = true;
                // Nova kill: use legacy API to increment kill counter
                (pointsManager as any).addEnemiesDestroyed?.(1, attacker, attacker.ship.side);
                // If you also want a bonus, uncomment the next line:
                // (pointsManager as any).addDamageToEnemies?.(5000, attacker, attacker.ship.side);
            }
        }
        destroyShipByNova(player, v, h);
    }
}

function applyNovaDamagePlanet(player: Player, planet: Planet, v: number, h: number): void {
    if (!player.ship) return;

    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v, h });
    let msg: string;
    let destroyed = false;

    if (planet.isBase) {
        const side = planet.side;
        if (side !== "FEDERATION" && side !== "EMPIRE") return;
        const basesArray = side === "FEDERATION" ? bases.federation : bases.empire;
        const baseIndex = basesArray.findIndex(b => b.position.v === planet.position.v && b.position.h === planet.position.h);
        if (baseIndex === -1) return;

        const base = basesArray[baseIndex];
        const wasUndamaged = base.energy === 1000;
        const damage = 300 + (ran() * 200 - 100);
        base.energy = Math.max(0, base.energy - damage);

        const ihita = damage * 8 + ran() * 1000;
        if (player.ship.side !== side) {
            pointsManager.addDamageToBases(ihita, player, player.ship.side);
        } else {
            pointsManager.addDamageToBases(-ihita, player, player.ship.side);
        }

        if (wasUndamaged) {
            msg = player.settings.output === "SHORT"
                ? `BASE DST @${coords}`
                : `Base at ${coords} is under attack by a nova!`;
            sendMessageToClient(player, msg);
            sendMessageToOthersWithFormat(player, (recipient) => {
                const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
                return recipient.settings.output === "SHORT"
                    ? `BASE DST @${formatted}`
                    : `Base at ${formatted} is under attack by a nova!`;
            });
        }

        if (base.energy <= 0) {
            destroyed = true;
            planet.isBase = false;
            if (player.ship.side !== side) {
                pointsManager.addDamageToBases(10000, player, player.ship.side);
            } else {
                pointsManager.addDamageToBases(-10000, player, player.ship.side);
            }
            basesArray.splice(baseIndex, 1);
            checkEndGame();
        }

        msg = player.settings.output === "SHORT"
            ? destroyed ? `BASE X @${coords}` : `BASE HIT -${Math.round(damage)} @${coords}`
            : destroyed
                ? `Base at ${coords} was destroyed by a nova!`
                : `Base at ${coords} was hit by a nova for ${Math.round(damage)} damage!`;
        sendMessageToClient(player, msg);

        sendMessageToOthersWithFormat(player, (recipient) => {
            const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
            return recipient.settings.output === "SHORT"
                ? destroyed ? `BASE X @${formatted}` : `BASE HIT -${Math.round(damage)} @${formatted}`
                : destroyed
                    ? `Base at ${formatted} was destroyed by a nova!`
                    : `Base at ${formatted} was hit by a nova for ${Math.round(damage)} damage!`;
        });
    } else {
        planet.builds = Math.max(0, planet.builds - 3);

        if (planet.builds <= 0) {
            destroyed = true;
            pointsManager.addPlanetsDestroyed(1, player, player.ship.side);
            const planetIndex = planets.findIndex(p => p.position.v === v && p.position.h === h);
            if (planetIndex !== -1) {
                planets.splice(planetIndex, 1);
            }
            const basesArray = planet.side === "FEDERATION" ? bases.federation : bases.empire;
            const baseIndex = basesArray.findIndex(base => base.position.v === v && base.position.h === h);
            if (baseIndex !== -1) {
                basesArray.splice(baseIndex, 1);
            }
            planet.isBase = false;
            checkEndGame();
        }

        msg = player.settings.output === "SHORT"
            ? `PLNT HIT -3 @${coords}`
            : destroyed
                ? `Planet at ${coords} was destroyed by a nova!`
                : `Planet at ${coords} lost 3 builds due to a nova!`;
        sendMessageToClient(player, msg);

        sendMessageToOthersWithFormat(player, (recipient) => {
            const formatted = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
            return recipient.settings.output === "SHORT"
                ? `PLNT HIT -3 @${formatted}`
                : destroyed
                    ? `Planet at ${formatted} was destroyed by a nova!`
                    : `Planet at ${formatted} lost 3 builds due to a nova!`;
        });
    }
}

function destroyShipByNova(player: Player, v: number, h: number): void {
    if (!player.ship) return;

    sendMessageToClient(player, `Your ship was destroyed by a nova explosion!`);
    const name = player.ship.name ?? "Unknown";

    sendMessageToOthersWithFormat(player, (recipient) => {
        const coords = ocdefCoords("ABSOLUTE", recipient.ship?.position ?? { v: 0, h: 0 }, { v, h });
        return formatNovaKillMessage(name, coords, recipient.settings.output);
    });

    removePlayerFromGame(player);
}

function formatNovaKillMessage(name: string, coords: string, output: "SHORT" | "MEDIUM" | "LONG"): string {
    switch (output) {
        case "SHORT":
            return `${name[0]} > X @${coords}`;
        case "MEDIUM":
            return `${name} destroyed by nova @${coords}`;
        case "LONG":
        default:
            return `${name} was destroyed by a nova at ${coords}`;
    }
}

function removeStarAt(v: number, h: number): void {
    const index = stars.findIndex(star => star.position.v === v && star.position.h === h);
    if (index !== -1) {
        stars.splice(index, 1);
    }
}
######## ove.ts
import {
    sendMessageToClient,
    sendOutputMessage
} from "./communication.js";

import { GRID_WIDTH } from "./settings.js";
import { isInBounds, getCoordsFromCommandArgs } from "./coords.js";
import { Player } from "./player.js";
import { Command } from "./command.js";



export function oveCommand(player: Player, command: Command): void {

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use this command.");
        return;
    }

    const args = command.args;
    const ship = player.ship;

    if (!player.ship.isDeviceOperational("warp")) {
        return;
    }

    if (!args.length) {
        sendMessageToClient(player, "Usage: MOVE/IMPULSE [A|R|C] <vpos> <hpos> OR MOVE C <ship>");
        return;
    }

    const { position: { v: targetVInput, h: targetHInput }, mode, error } = getCoordsFromCommandArgs(
        player,
        args,
        ship.position.v,
        ship.position.h,
        true
    );

    if (error) {
        sendOutputMessage(player, {
            SHORT: "MOVE > BAD COORD",
            MEDIUM: `Bad MOVE input (${mode})`,
            LONG: `Invalid MOVE command: ${error} in ${mode}`
        });
        return;
    }

    if (!isInBounds(targetVInput, targetHInput)) {
        sendOutputMessage(player, {
            SHORT: "MOVE > OUT OF BOUNDS",
            MEDIUM: "Invalid MOVE target sector.",
            LONG: `Target sector must be within 1–${GRID_WIDTH}.`
        });
        return;
    }

    player.ship.position = { v: targetVInput, h: targetHInput };
    sendMessageToClient(player, `OVER to sector ${targetVInput}-${targetHInput}`);
}

######## phaser.ts
import { Player } from './player.js';
import { Command } from './command.js';
import { ran, iran } from './util/random.js';
import {
    OutputSetting,
    STARBASE_PHASER_RANGE,
    MAX_SHIELD_ENERGY
} from './settings.js';
import { sendMessageToClient, addPendingMessage, sendOutputMessage } from './communication.js';
import { chebyshev, ocdefCoords, getCoordsFromCommandArgs } from './coords.js';
import { Planet } from './planet.js';
import { players, SHIP_FATAL_DAMAGE, planets, bases, removePlayerFromGame, checkEndGame, pointsManager } from './game.js';
import { handleUndockForAllShipsAfterPortDestruction } from './ship.js';
import { PLANET_PHASER_RANGE } from './game.js';
import { attackerRef, emitShipDestroyed } from './api/events.js';
import { emitPhaserEvent, emitShieldsChanged, emitPlanetBaseRemoved } from './api/events.js';

import type { Side } from "./settings.js";

type ScoringAPI = {
    addDamageToEnemies?(amount: number, source: Player, side: Side): void;
    addDamageToBases?(amount: number, source: Player, side: Side): void;
    addEnemiesDestroyed?(count: number, source: Player, side: Side): void;
    addPlanetsCaptured?(count: number, player: Player, side: Side): void;
    incrementShipsCommissioned?(side: Side): void;
};

// Player-visible scale: divide energy before feeding PHADAM core.
// 56 is derived from a distance-4 anchor so 200-in ≈ 200 dmg avg.
const PHADAM_PHIT_DIVISOR = 20;

// If your hits look globally too big/small, tweak this (1 = unchanged).
const PHASER_HULL_SCALE: number = 1;

// (debug helper removed)

export function phaserCommand(player: Player, command: Command): void {
    if (!player.ship) {
        sendMessageToClient(player, "You cannot fire phasers — you have no ship.");
        return;
    }

    let args = command.args;
    const now = Date.now();
    const [ph1, ph2] = player.ship.cooldowns.phasersAvailableAt;
    const bankIndex = ph1 <= ph2 ? 0 : 1;
    let energy = NaN;

    if (!player.ship.isDeviceOperational("phaser")) return;

    if (now < player.ship.cooldowns.phasersAvailableAt[bankIndex]) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > RCHG"); break;
            case "MEDIUM": sendMessageToClient(player, "Phasers unavailable — recharging."); break;
            case "LONG": sendMessageToClient(player, "Both phaser banks are currently recharging."); break;
        }
        return;
    }

    // Parse arguments
    if (command.args.length === 2) {
        args = [player.settings.icdef, ...command.args];  // v h
    } else if (command.args.length === 3) { // either energy v h, or mode v h
        energy = parseInt(command.args[0], 10);
        if (!Number.isNaN(energy)) {
            args[0] = player.settings.icdef; // remove energy and treat as normal
        }
    } else if (command.args.length === 4) { // mode energy v h
        energy = parseInt(command.args[1], 10);
        if (Number.isNaN(energy)) {
            switch (player.settings.output) {
                case "SHORT": sendMessageToClient(player, "PH > BAD E"); break;
                case "MEDIUM": sendMessageToClient(player, "Invalid phaser energy input."); break;
                case "LONG":
                default: sendMessageToClient(player, "Bad energy value provided. Phaser command aborted."); break;
            }
            return;
        } else {
            args = command.args.slice(0, 1).concat(command.args.slice(2));
        }
    }

    if (Number.isNaN(energy)) energy = 200;
    energy = Math.min(Math.max(energy, 50), 500);

    const shieldPenalty = player.ship.shieldsUp ? 200 : 0;
    if (shieldPenalty > 0) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "HS shield control."); break;
            case "MEDIUM": sendMessageToClient(player, "High-speed shield control."); break;
            case "LONG": sendMessageToClient(player, "High speed shield control activated."); break;
        }
    }

    // Pre-check against actual energy model (player units): cost = phit + shieldPenalty
    const totalEnergyCost = Math.floor(energy) + shieldPenalty;
    if (player.ship.energy < totalEnergyCost) {
        const e = player.ship.energy.toFixed(1);
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, `PH > NO E ${e}`); break;
            case "MEDIUM": sendMessageToClient(player, `Insufficient energy: ${e}`); break;
            case "LONG":
            default: sendMessageToClient(player, `Insufficient energy to fire phasers. Available energy: ${e}`); break;
        }
        return;
    }

    const { position: { v: targetV, h: targetH } } =
        getCoordsFromCommandArgs(player, args, player.ship.position.v, player.ship.position.h, true);

    const distance = chebyshev(player.ship.position, { v: targetV, h: targetH });

    if (distance > 10) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > RANGE"); break;
            case "MEDIUM": sendMessageToClient(player, "Target exceeds phaser range."); break;
            case "LONG": sendMessageToClient(player, "Target out of phaser range (maximum 10 sectors)."); break;
        }
        return;
    }

    player.ship.condition = "RED";

    const target = findTargetAt(targetV, targetH);
    if (!target) {
        switch (player.settings.output) {
            case "SHORT": sendMessageToClient(player, "PH > MISS"); break;
            case "MEDIUM": sendMessageToClient(player, "No target present."); break;
            case "LONG": sendMessageToClient(player, "No valid target at that location for phaser strike."); break;
        }
        return;
    }
    const targetSide = target instanceof Planet ? target.side : target.ship?.side;
    if (targetSide === player.ship.side) {
        sendMessageToClient(player, "Cannot fire phasers at a friendly target.");
        return;
    }

    // PHADAM parity: range & device effects applied inside core; pass requested energy.
    const result = applyPhaserDamage(player, target, energy);

    // --- bank cooldown + overheating (DECWAR-style) -----------------------
    // Cool down the **bank we just used**:
    // 3–6 seconds + (phaser device damage / 100) seconds.
    {
        const phaserDamage = Math.max(0, (player.ship.devices?.phaser ?? 0));
        const cooldownMs = computePhaserCooldownMs(phaserDamage);
        player.ship.cooldowns.phasersAvailableAt[bankIndex] = now + cooldownMs;
    }

    // Chance to overheat/damage own phasers based on shot energy
    maybeOverheatPhasers(player, energy);

    if (result.checkEndGame) checkEndGame();
}

function findTargetAt(v: number, h: number): Player | Planet | null {
    // 1) Ship
    const ship = players.find(p => p.ship && p.ship.position.v === v && p.ship.position.h === h);
    if (ship) return ship;

    // 2) Base via planets (preferred if flagged)
    const planetAt = planets.find(p => p.position.v === v && p.position.h === h);
    if (planetAt?.isBase) return planetAt;

    // 3) Base via bases lists (in case isBase flag isn’t synced)
    const baseOnly = [...bases.federation, ...bases.empire]
        .find(b => b.position.v === v && b.position.h === h);
    if (baseOnly) return baseOnly;

    // 4) Plain planet (non-base)
    return planetAt ?? null;
}

export function applyPhaserDamage(
    attacker: Player,
    target: Player | Planet,
    phit: number
): { hita: number; critdv: number; critdm: number; klflg: number; checkEndGame: boolean } {
    if (!attacker.ship) return { hita: 0, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };

    // Spend energy & normalize phit (PHACON parity) — do NOT range-scale here.
    const shieldPenalty = attacker.ship.shieldsUp ? 200 : 0;
    const { phit: phitUsed, energySpent } = preparePhaserShot(attacker, phit, shieldPenalty);

    // If power scaled to zero, do not fire at all (prevents free shield drain in core)
    if (phitUsed <= 0) {
        // Keep parity-friendly wording; this avoids emitting any phaser event as well.
        try {
            sendMessageToClient(attacker, "No energy for phasers.");
        } catch { /* no-op */ }
        return { hita: 0, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };
    }

    // Convert to core scale (floating; FORTRAN used reals)
    const phitForCore = Math.max(0, phitUsed / PHADAM_PHIT_DIVISOR);


    let hita = 0;
    let critdv = 0;
    let critdm = 0;
    let klflg = 0;
    let checkEndGame = false;

    // --- early return: non-base planet (installations only)
    if (target instanceof Planet && !target.isBase) {
        const attackerPos = attacker.ship.position;
        const targetPos = target.position;
        const distance = chebyshev(attackerPos, targetPos);

        emitPhaserEvent({
            by: { shipName: attacker.ship.name, side: attacker.ship.side },
            from: attackerPos,
            to: targetPos,
            distance,
            energySpent,
            target: { kind: "planet", name: target.name, side: target.side, position: target.position },
            result: "no_effect",
        });

        if (ran() < 0.25) {
            if (target.builds > 0) {
                target.builds = Math.max(0, target.builds - 1);
                const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, target.position);
                sendOutputMessage(attacker, {
                    SHORT: `Planet hit @${coords}: Builds -1`,
                    MEDIUM: `Phaser hit reduced builds on planet at ${coords} by 1 (now ${target.builds}).`,
                    LONG: `Phasers damaged planetary installations at ${coords}, reducing builds by 1 to ${target.builds}. Cannot destroy planet.`,
                });
                return { hita: 1, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };
            } else {
                sendMessageToClient(attacker, `Planet at full vulnerability; phasers cannot destroy it.`);
                return { hita: 0, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };
            }
        } else {
            sendMessageToClient(attacker, `Phaser hit on planet had no effect on installations.`);
            return { hita: 0, critdv: 0, critdm: 0, klflg: 0, checkEndGame: false };
        }
    }

    // --- common path (ship OR base)
    const attackerPos = attacker.ship.position;
    const targetPos =
        target instanceof Player && target.ship ? target.ship.position : (target as Planet).position;
    const distance = chebyshev(attackerPos, targetPos);

    const shooterDamaged =
        !!(attacker.ship?.devices?.phaser > 0) || !!(attacker.ship?.devices?.computer > 0);

    const targetIsShip = target instanceof Player && !!target.ship;
    const targetIsBase = target instanceof Planet && target.isBase;

    // Shield pools + max
    let rawShieldEnergy: number;
    let rawShieldMax: number;
    if (targetIsShip) {
        rawShieldEnergy = (target as Player).ship!.shieldEnergy;
        rawShieldMax = MAX_SHIELD_ENERGY;
    } else {
        rawShieldEnergy = (target as Planet).energy; // 0..1000 store for bases
        rawShieldMax = 1000;
    }

    const toPct1000 = (energy: number, max: number) =>
        max > 0 ? Math.max(0, Math.min(1000, (energy / max) * 1000)) : 0;
    const pct = (x: number, max: number) => {
        const raw = (Math.max(0, x) / Math.max(1, max)) * 100;
        return Math.max(0, Math.min(100, Math.round(raw)));
    };

    const prevShieldPct1000 = toPct1000(rawShieldEnergy, rawShieldMax);
    const shieldsBefore = targetIsShip ? (target as Player).ship!.shieldEnergy : (target as Planet).energy;

    // Use the actual **toggle**: ships use shieldsUp, bases behave as shielded.
    const targetShieldsUp = targetIsShip ? Boolean((target as Player).ship!.shieldsUp) : true;

    // ---- PHADAM-parity core (absorb+drain → hull)
    const core = phadamCore({
        targetIsBase,
        targetShieldsUp,
        rawShieldEnergy,
        rawShieldMax,
        distance,
        shooterDamaged,
        phit: phitForCore,
    });

    // Authoritative hull/energy damage AFTER shields
    hita = core.hita;

    hita = Math.max(0, Math.round(hita)); // keep integer ihita like FORTRAN

    // Optional global hull scale (for legacy-feel tuning)
    if (PHASER_HULL_SCALE !== 1) {
        hita = Math.round(hita * PHASER_HULL_SCALE);
    }

    // Safety: if shields are truly UP and were ~100% before, hull must be 0.
    const EPS = 0.005;
    const beforeFrac = Math.max(0, shieldsBefore) / Math.max(1, rawShieldMax);
    if (targetIsShip && (target as Player).ship!.shieldsUp && beforeFrac >= 1 - EPS && hita > 0) {
        hita = 0;
    }

    // Write back drained shields/energy
    if (targetIsShip) {
        (target as Player).ship!.shieldEnergy = Math.max(0, core.newShieldEnergy);
    } else {
        (target as Planet).energy = core.newShieldEnergy;
    }

    const shieldsAfter = targetIsShip ? (target as Player).ship!.shieldEnergy : (target as Planet).energy;

    if (targetIsShip && shieldsBefore !== shieldsAfter) {
        emitShieldsChanged(target as Player, shieldsBefore, shieldsAfter);
    }

    // --- Base collapse crit BEFORE hull (unchanged behavior)
    let baseKilledNow = false;
    if (targetIsBase) {
        const newShieldPct1000 = toPct1000(shieldsAfter, rawShieldMax); // post-drain, pre-hull
        if (prevShieldPct1000 > 0 && newShieldPct1000 === 0) {
            const rana = ran();
            const extra = 50 + Math.floor(100 * rana); // 50..149
            (target as Planet).energy = Math.max(0, (target as Planet).energy - extra);
            critdm = Math.max(critdm, 1);

            if (ran() < 0.1 || (target as Planet).energy <= 0) {
                klflg = 1;

                if (attacker.ship) {
                    const atkSide = attacker.ship.side;
                    const tgtSide = (target as Planet).side;
                    const sign = atkSide !== tgtSide ? 1 : -1;
                    (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, attacker, atkSide);
                }

                const base = target as Planet;
                const prevSide = base.side;

                const baseArray = prevSide === "FEDERATION" ? bases.federation : bases.empire;
                const idx = baseArray.indexOf(base);
                if (idx !== -1) baseArray.splice(idx, 1);

                // Remove from global planets as well (no demotion)
                const pidx = planets.indexOf(base);
                if (pidx !== -1) planets.splice(pidx, 1);

                // BASKIL parity: undock/RED ships that were using this port
                handleUndockForAllShipsAfterPortDestruction(base);

                emitPlanetBaseRemoved(base, "collapse_phaser", attacker, prevSide);
                checkEndGame = true;
                baseKilledNow = true;
            }
        }
    }

    // --- Ship device crit BEFORE hull (ships only)
    if (!baseKilledNow && targetIsShip && hita > 0) {
        const crit = maybeApplyShipCriticalParity(target as Player, hita);
        if (crit.isCrit) {
            hita = crit.hita;
            critdv = crit.critdv;
            critdm = Math.max(critdm, crit.critdm);
            const deviceKeys = Object.keys((target as Player).ship!.devices);
            const deviceName = deviceKeys[critdv]?.toUpperCase?.() ?? "DEVICE";
            if (crit.critdm > 0) {
                addPendingMessage(target as Player, `CRITICAL HIT: ${deviceName} damaged by ${crit.critdm}!`);
            } else {
                addPendingMessage(target as Player, `CRITICAL HIT: ${deviceName} struck!`);
            }
        }
    }

    // --- Apply hull/energy (skip if base just died in collapse)
    if (!baseKilledNow) {
        if (targetIsShip) {
            const ihita = Math.max(0, Math.round(hita));
            const wasAlive = (target as Player).ship!.damage < SHIP_FATAL_DAMAGE;
            (target as Player).ship!.damage += ihita;                 // KSDAM += ihita
            (target as Player).ship!.energy = Math.max(
                0,
                (target as Player).ship!.energy - hita * ran()   // KSNRGY -= hita * RND()
            );
            // Award kill credit if this hit destroyed the ship
            if (wasAlive && (target as Player).ship!.damage >= SHIP_FATAL_DAMAGE) {
                pointsManager.creditShipKill(attacker, (target as Player).ship!.side, 500);
            }
        } else {
            // Bases lose only 1% of the computed hit (DECWAR parity)
            // Bases lose 1% of the computed hit, with a minimum of 1 when hita > 0
            const delta = hita > 0 ? Math.max(1, Math.floor(hita * 0.01)) : 0;
            (target as Planet).energy = Math.max(0, (target as Planet).energy - delta);
        }
    }

    // --- Destruction check
    const isDestroyed =
        (targetIsShip &&
            ((target as Player).ship!.energy <= 0 || (target as Player).ship!.damage >= SHIP_FATAL_DAMAGE)) ||
        (!targetIsShip && (target as Planet).isBase && (target as Planet).energy <= 0);

    if (isDestroyed && !baseKilledNow) {
        klflg = 1;
        if (targetIsShip) {
            // +/-5000 ship kill bonus
            if (attacker.ship) {
                const atkSide = attacker.ship.side;
                const tgtSide = (target as Player).ship!.side;
                const sign = atkSide !== tgtSide ? 1 : -1;
                (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(5000 * sign, attacker, atkSide);
            }

            emitShipDestroyed(
                (target as Player).ship!.name,
                (target as Player).ship!.side,
                { v: (target as Player).ship!.position.v, h: (target as Player).ship!.position.h },
                attackerRef(attacker),
                "combat"
            );

            // Ensure victim sees a direct line before removal
            try {
                sendMessageToClient(
                    target as Player,
                    `Your ship was destroyed by ${attacker.ship?.name ?? "an unknown attacker"}.`
                );
            } catch { /* ignore */ }

            removePlayerFromGame(target as Player);
            if (attacker.ship) {
                pointsManager.addEnemiesDestroyed(1, attacker, attacker.ship.side);
            }
        } else {
            // base died via hull after PHADAM
            if (attacker.ship) {
                const atkSide = attacker.ship.side;
                const tgtSide = (target as Planet).side;
                const sign = atkSide !== tgtSide ? 1 : -1;
                (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, attacker, atkSide);
            }

            {
                const base = target as Planet;
                const prevSide = base.side;

                const baseArray = prevSide === "FEDERATION" ? bases.federation : bases.empire;
                const idx = baseArray.indexOf(base);
                if (idx !== -1) baseArray.splice(idx, 1);

                // Remove from global planets as well (no demotion)
                const pidx = planets.indexOf(base);
                if (pidx !== -1) planets.splice(pidx, 1);

                // BASKIL parity: undock/RED ships that were using this port
                handleUndockForAllShipsAfterPortDestruction(base);

                emitPlanetBaseRemoved(base, "collapse_phaser", attacker, prevSide);
                checkEndGame = true;
            }
        }
    }

    // --- Scoring on actually applied damage
    if (attacker.ship && hita > 0) {
        const atkSide = attacker.ship.side;
        if (!targetIsShip && (target as Planet).isBase) {
            const sign = atkSide !== (target as Planet).side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToBases?.(Math.round(hita) * sign, attacker, atkSide);
        } else if (targetIsShip) {
            const sign = atkSide !== (target as Player).ship!.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(Math.round(hita) * sign, attacker, atkSide);
        }
    }

    // --- Attacker messaging (absorption-aware; unchanged semantics)
    const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, targetPos);
    const fullyAbsorbed = Math.round(hita) === 0 && shieldsAfter !== shieldsBefore;

    if (fullyAbsorbed) {
        const beforePctForUi = pct(shieldsBefore, rawShieldMax);
        const afterPctForUi = pct(shieldsAfter, rawShieldMax);
        sendOutputMessage(attacker, {
            SHORT: `@${coords}: absorbed (${beforePctForUi}%→${afterPctForUi}%)`,
            MEDIUM: `Phaser hit absorbed @${coords} (${beforePctForUi}%→${afterPctForUi}% shields).`,
            LONG: `Phaser hit fully absorbed @${coords}. Shields dropped from ${beforePctForUi}% to ${afterPctForUi}%.`,
        });
        if (targetIsShip) {
            addPendingMessage(target as Player, `Phaser hit from ${attacker.ship!.name} absorbed by shields.`);
        }
    } else {
        sendOutputMessage(attacker, {
            SHORT: `Phaser hit @${coords}: ${Math.round(hita)}`,
            MEDIUM: `Phaser hit on target at ${coords} for ${Math.round(hita)} damage.`,
            LONG: `Phasers struck target at ${coords}, inflicting ${Math.round(hita)} damage. Critical: ${critdm > 0 ? "Yes" : "No"}.`,
        });
        if (targetIsShip) {
            addPendingMessage(target as Player, `Phaser hit from ${attacker.ship!.name} for ${Math.round(hita)} damage!`);
        }
    }

    // ----- authoritative event -----
    try {
        const by = { shipName: attacker.ship.name, side: attacker.ship.side };
        const from = attacker.ship.position;
        const to = targetIsShip ? (target as Player).ship!.position : (target as Planet).position;

        const targetRef =
            targetIsShip
                ? { kind: "ship" as const, name: (target as Player).ship!.name, side: (target as Player).ship!.side, position: { ...(target as Player).ship!.position } }
                : (target as Planet).isBase
                    ? { kind: "base" as const, name: (target as Planet).name, side: (target as Planet).side, position: { ...(target as Planet).position } }
                    : { kind: "planet" as const, name: (target as Planet).name, side: (target as Planet).side, position: { ...(target as Planet).position } };

        emitPhaserEvent({
            by,
            from,
            to,
            distance,
            energySpent,
            target: targetRef,
            result: Math.round(hita) > 0 ? "hit" : "no_effect",
            damage: Math.max(0, Math.round(hita)),
            shieldsBefore,
            shieldsAfter,
            crit: critdm > 0 ? { amount: critdm } : null,
            killed: klflg === 1,
        });
    } catch { /* never let telemetry break combat */ }

    return { hita, critdv, critdm, klflg, checkEndGame };
}

// ----- FORTRAN-style helpers -----
const FINT = (x: number) => (x >= 0 ? Math.floor(x) : Math.ceil(x)); // FORTRAN INT
const CLAMP = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));

// Bank cooldown helper:
// 3–6 seconds (uniform integer) + (phaser damage / 100) seconds.
function computePhaserCooldownMs(phaserDamage: number): number {
    const baseSeconds = 3 + Math.floor(ran() * 4); // 3,4,5,6
    const extra = Math.max(0, phaserDamage) / 100.0;
    return Math.floor((baseSeconds + extra) * 1000);
}

// Overheating model:
// ~5% fail chance at 200 energy, ~65% near 500 energy. Severity scales with energy.
function maybeOverheatPhasers(player: Player, energy: number): void {
    if (!player.ship?.isDeviceOperational("phaser")) return;
    const e = Math.max(50, Math.min(500, Math.floor(energy)));
    // Linear ramp: 200 → 5%, 500 → 65% (clamped on low end)
    let p = 0.05 + ((e - 200) * (0.65 - 0.05)) / 300; // can go below 0.05 if e<200
    p = Math.max(0.005, Math.min(0.80, p));

    // Slightly more likely when already damaged
    const dmg = Math.max(0, player.ship.devices?.phaser ?? 0);
    p *= 1 + Math.min(0.5, dmg / 2000); // up to +50% at very high damage

    if (ran() >= p) return;

    // Severity ~ energy with a little jitter (user-visible device units)
    const add = Math.max(1, Math.round(e * (0.35 + ran() * 0.65))); // ~0.35e..1.0e
    player.ship.devices.phaser = (player.ship.devices.phaser ?? 0) + add;

    // Messaging: warning vs. critical
    const total = player.ship.devices.phaser;
    if (total >= 400) {
        // mirrors classic "critically damaged" vibe
        sendMessageToClient(player, "Phasers critically damaged.");
    } else {
        switch (player.settings.output) {
            case "SHORT":
                sendMessageToClient(player, "OVERHEAT: PHASERS.");
                break;
            case "MEDIUM":
                sendMessageToClient(player, "WARNING! Phasers overheating.");
                break;
            case "LONG":
            default:
                sendMessageToClient(player, "WARNING! WARNING! PHASERS OVERHEATING.");
                break;
        }
    }
}

/**
 * PHADAM-parity core: shield absorption + shield drain + final damage.
 * Uses Fortran shield scale 0..1000 internally and converts back.
 */
export function phadamCore(opts: {
    targetIsBase: boolean;
    targetShieldsUp: boolean;
    rawShieldEnergy: number;
    rawShieldMax: number;
    distance: number;
    shooterDamaged: boolean;
    phit: number;
}): { hita: number; newShieldEnergy: number } {
    const {
        targetIsBase,
        targetShieldsUp,
        rawShieldEnergy,
        rawShieldMax,
        distance,
        shooterDamaged,
        phit,
    } = opts;

    const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
    const toPct = (energy: number, max: number) => (max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0);
    const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

    // Read shield level (0..1000 fixed-point percent)
    let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

    // “Shielded” only if a base OR shields are UP and >0%
    const treatedAsShielded = targetIsBase || (targetShieldsUp && shieldPct > 0);

    // powfac halves only when actually shielded
    const powfac = treatedAsShielded ? 40 : 80;

    // distance falloff
    // Parity with FORTRAN PHADAM: 0.90 + 0.02 * ran()
    const base = 0.90 + 0.02 * ran(); // controls fall off over distance

    let localHita = Math.pow(base, Math.max(0, distance));

    // device penalty on attacker
    if (shooterDamaged) localHita *= 0.8;

    // --- shield penetration and drain ---
    // use pre-drain for penetration
    let through = localHita;
    if (treatedAsShielded) {
        // only the fraction not covered by shields goes through
        through = (1000 - shieldPct) * localHita * 0.001;

        // shield drain uses absorption factor of max(shield%*0.001, 0.1)
        const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
        const drain = (localHita * powfac * phit * absorptionFactor + 10) * 0.03;
        shieldPct = clamp(shieldPct - drain, 0, 1000);
    }

    // final hull/energy damage
    const hita = Math.max(0, through * powfac * phit);

    // write back shields in caller's units
    const newShieldEnergy = fromPct(shieldPct, rawShieldMax);

    return { hita, newShieldEnergy };
}


export function maybeApplyShipCriticalParity(
    target: Player,
    baseHita: number
): {
    hita: number;          // final hit after halve + optional jitter
    critdv: number;        // device index chosen (-1 if none)
    critdm: number;        // device damage amount applied
    droppedShields: boolean;
    isCrit: boolean;
} {
    const ship = target.ship;
    if (!ship) {
        // No ship: cannot do device crit logic; just pass through unchanged.
        return { hita: Math.max(0, Math.round(baseHita)), critdv: -1, critdm: 0, droppedShields: false, isCrit: false };
    }

    // --- DECWAR crit threshold:
    // if (baseHita * (rand + 0.1)) < 1700 -> NO CRIT
    const rana = ran();
    if (baseHita * (rana + 0.1) < 1700) {
        return { hita: Math.max(0, Math.round(baseHita)), critdv: -1, critdm: 0, droppedShields: false, isCrit: false };
    }

    // --- CRIT path: halve, device damage = halved amount
    let hita = Math.floor(baseHita / 2);

    const deviceKeys = Object.keys(ship.devices) as Array<keyof typeof ship.devices>;
    if (deviceKeys.length === 0) {
        // still a crit, but no device to damage
        // jitter still applies because it's a crit
        const jitter = Math.floor((ran() - 0.5) * 1000); // ±500 on crits only
        hita = Math.max(0, hita + jitter);
        return { hita, critdv: -1, critdm: 0, droppedShields: false, isCrit: true };
    }

    const critdv = iran(deviceKeys.length);
    const device = deviceKeys[critdv];

    const critdm = Math.max(0, hita);
    ship.devices[device] = (ship.devices[device] ?? 0) + critdm;

    // if it's the shields device, drop shields immediately
    let droppedShields = false;
    if (/shield/i.test(String(device))) {
        ship.shieldsUp = false;
        ship.shieldEnergy = 0;
        droppedShields = true;
    }

    // DECWAR: add ±500 jitter on crits
    const jitter = Math.floor((ran() - 0.5) * 1000);
    hita = Math.max(0, hita + jitter);

    return { hita, critdv, critdm, droppedShields, isCrit: true };
}

function applyInstallationPhaserToShip(opts: {
    attackerPlanet: Planet; target: Player; phit: number; distance: number;
}) {
    const { attackerPlanet, target, phit, distance } = opts;
    if (!target.ship) return { hita: 0, killed: false };

    const s = target.ship;

    const core = phadamCore({
        targetIsBase: false,
        targetShieldsUp: Boolean(s.shieldsUp),
        rawShieldEnergy: s.shieldEnergy,
        rawShieldMax: MAX_SHIELD_ENERGY,
        distance,
        shooterDamaged: false,   // planet devices can’t be “damaged”
        // Scale same as ship phasers for consistent visible damage
        phit: phit / PHADAM_PHIT_DIVISOR,
    });

    s.shieldEnergy = core.newShieldEnergy;

    let hita = core.hita;
    // Optional global hull scale (legacy/user-visible)
    if (PHASER_HULL_SCALE !== 1) {
        hita = Math.round(hita * PHASER_HULL_SCALE);
    }

    // Small ship-only jitter in *user* units (±25)
    if ((target instanceof Player) && (target as Player).ship && hita > 0) {
        const jitterUser = Math.floor((ran() - 0.5) * 50); // -25..+25
        hita = Math.max(0, hita + jitterUser);
    }

    s.energy -= hita;
    s.damage += hita / 2;

    const killed = s.energy <= 0 || s.damage >= SHIP_FATAL_DAMAGE;
    return { hita, killed };
}

// counts-in signature: use the sweep's numply for DECWAR-true scaling
export function planetPhaserDefense(triggeringPlayer: Player, counts?: { numply: number }): void {
    if (!triggeringPlayer.ship) return;
    const isRomulanMove = !!triggeringPlayer.ship.romulanStatus?.isRomulan;
    const moverSide = triggeringPlayer.ship.side;
    const numply = Math.max(1, counts?.numply ?? 1);

    for (const planet of planets) {
        if (planet.isBase) continue; // bases handled elsewhere
        // Need at least some builds to have guns (classic feel)
        if ((planet.builds ?? 0) <= 0) continue;

        // Activation rules:
        const isNeutral = planet.side === "NEUTRAL";
        const isEnemy = planet.side !== "NEUTRAL" && planet.side !== moverSide;

        if (!isRomulanMove) {
            if (!isEnemy && !isNeutral) continue;          // own side's planets do NOT activate
            if (isNeutral && ran() < 0.5) continue; // 50% chance to skip neutrals
        } else {
            // Romulan activates both sides; neutrals still 50%
            if (isNeutral && ran() < 0.5) continue;
        }

        // DECWAR PLNATK: phit = (50 + 30*builds) / numply  (builds in 0..5)
        const phit = (50 + 30 * (planet.builds ?? 0)) / Math.max(numply, 1);

        // scan for enemy, visible ships in range 2
        for (const p of players) {
            if (!p.ship) continue;
            // if cloaked and not revealed, skip
            if (p.ship.romulanStatus?.cloaked && !p.ship.romulanStatus?.isRevealed) continue;
            // never shoot same-side ships
            if (planet.side !== "NEUTRAL" && p.ship.side === planet.side) continue;

            const dist = chebyshev(planet.position, p.ship.position);
            if (dist > PLANET_PHASER_RANGE) continue;

            // fire!
            const { hita, killed } = applyInstallationPhaserToShip({
                attackerPlanet: planet,
                target: p,
                phit,
                distance: dist
            });

            if (hita <= 0) continue;

            // Team scoring: credit owner side via existing API; skip neutral
            if (planet.side !== "NEUTRAL") {
                (pointsManager as any).addDamageToEnemies?.(hita, /*by*/ undefined, planet.side);
                // Kill bonus exactly once per victim hull
                if (killed && p.ship && !p.ship.__killCredited) {
                    p.ship.__killCredited = true;
                    (pointsManager as any).addEnemiesDestroyed?.(1, /*by*/ undefined, planet.side);
                }
            }

            // Player messaging (pridis/makhit analogue)
            const coords = ocdefCoords(p.settings.ocdef, p.ship.position, planet.position);
            addPendingMessage(p,
                `ALERT: Planet at ${coords} fires phasers! You take ${Math.round(hita)} damage.`);

            // If the victim died, handle removal like elsewhere
            if (killed) {
                if (p.ship) {
                    emitShipDestroyed(
                        p.ship.name,
                        p.ship.side,
                        { v: p.ship.position.v, h: p.ship.position.h },
                        /* by */ undefined,
                        "planet"
                    );
                }
                removePlayerFromGame(p);
            }
        }
    }
}

export function formatPhaserHit({
    attacker,
    target,
    damage,
    attackerPos,
    targetShieldPercent,
    outputLevel
}: {
    attacker: string;
    target: string;
    damage: number;
    attackerPos: { v: number, h: number };
    targetShieldPercent: number;
    outputLevel: OutputSetting;
}): string {
    const dmg = Math.round(damage);
    const shields = Math.round(targetShieldPercent);

    switch (outputLevel) {
        case "LONG":
            return `${attacker} @${attackerPos.v}-${attackerPos.h} makes ${dmg} unit phaser hit on ${target}, ${shields >= 0 ? "+" : ""}${shields}%`;
        case "MEDIUM":
            return `${attacker[0]} @${attackerPos.v}-${attackerPos.h} ${dmg}P ${target[0]}, ${shields >= 0 ? "+" : ""}${shields}%`;
        case "SHORT":
            return `${attacker[0]} ${attackerPos.v}-${attackerPos.h} ${dmg}P ${target[0]} ${shields >= 0 ? "+" : ""}${shields}`;
    }
    return `${attacker} @${attackerPos.v}-${attackerPos.h} makes ${dmg} unit phaser hit on ${target}, ${shields >= 0 ? "+" : ""}${shields}%`;
}

export function formatPhaserBaseHit({
    player,
    base,
    damage
}: {
    player: Player;
    base: Planet;
    damage: number;
}): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const dmg = Math.round(damage);
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, base.position);
    const attacker = player.ship.name;
    const output = player.settings.output;

    switch (output) {
        case "LONG":
            return `${attacker} fires phasers and hits ${base.side} base at ${coords} for ${dmg} units`;
        case "MEDIUM":
            return `${attacker?.[0]} PH ${base.side[0]}B @${coords} ${dmg}`;
        case "SHORT":
            return `${attacker?.[0]} > ${base.side[0]}B ${coords} ${dmg}`;
        default:
            return `${attacker} fires phasers and hits ${base.side} base at ${coords} for ${dmg} units`;
    }
}

export function formatPhaserPlanetHit(player: Player, planet: Planet): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, planet.position);
    const name = player.ship.name;
    switch (player.settings.output) {
        case "SHORT":
            return `${name?.[0]} > P ${coords} ${planet.builds}B`;
        case "MEDIUM":
            return `${name} hit planet @${coords}, builds left: ${planet.builds}`;
        case "LONG":
            return `${name} fired phasers at planet located at ${coords}. Remaining builds: ${planet.builds}`;
    }
    return `${name} hit planet @${coords}, builds left: ${planet.builds}`;
}

export function formatPhaserBaseDestroyed({ player, base }: { player: Player; base: Planet }): string {
    if (!player.ship) return "The phaser malfunctioned.";
    const coords = ocdefCoords(player.settings.ocdef, player.ship.position, base.position);
    const output = player.settings.output;
    switch (output) {
        case "SHORT":
            return `☠ ${base.side[0]}B ${coords}`;
        case "MEDIUM":
            return `${base.side} base destroyed at ${coords}`;
        case "LONG":
            return `The ${base.side} base at ${coords} has been destroyed!`;
    }
    return `${base.side} base destroyed at ${coords}`;
}

export function sendFormattedMessageToObservers({
    origin,
    attacker,
    target,
    damage,
    targetShieldPercent,
    formatFunc
}: {
    origin: { v: number, h: number };
    attacker: string;
    target: string;
    damage: number;
    targetShieldPercent: number;
    formatFunc: (opts: {
        attacker: string;
        target: string;
        damage: number;
        attackerPos: { v: number, h: number };
        targetShieldPercent: number;
        outputLevel: OutputSetting;
    }) => string;
}): void {
    for (const other of players) {
        if (!other.radioOn) continue;
        if (!other.ship) continue;

        if (chebyshev(origin, other.ship.position) > 10) continue;

        const msg = formatFunc({
            attacker,
            target,
            damage,
            attackerPos: origin,
            targetShieldPercent,
            outputLevel: other.settings.output
        });

        addPendingMessage(other, msg);
    }
}

function preparePhaserShot(
    attacker: Player,
    requestedPhit: number | undefined,
    extraCost: number = 0
): { phit: number; energySpent: number } {
    // Default PHACON phit (FORTRAN: 200 when unspecified)
    let phit = (requestedPhit ?? 0) > 0 ? requestedPhit! : 200;

    // FORTRAN parity: debit = phit + extraCost (no ×10)
    let energyCost = Math.floor(phit) + Math.max(0, Math.floor(extraCost));

    const ship = attacker.ship!;
    if (ship.energy < energyCost) {
        // Scale phit down to fit available energy after paying extraCost
        const availableForPhit = Math.max(0, ship.energy - Math.max(0, Math.floor(extraCost)));
        phit = Math.max(0, Math.floor(availableForPhit));   // <-- no /10
        energyCost = Math.floor(phit) + Math.max(0, Math.floor(extraCost));
    }

    // Deduct
    ship.energy = Math.max(0, ship.energy - energyCost);

    return { phit, energySpent: energyCost };
}
######## planet.ts
import { GRID_WIDTH, GRID_HEIGHT, NUMBER_OF_PLANETS, Side, DEFAULT_BASE_ENERGY } from './settings.js';
import { findObjectAtPosition, ocdefCoords, Position } from './coords.js';
import { planets, bases } from './game.js';
import { getRandom } from './util/random.js';
import { getNearbyAlliedShips } from './ship.js';
import { addPendingMessage } from './communication.js';
import { Player } from './player.js';
import { players } from './game.js';

interface CaptureLock {
    status: boolean;
    time: number;
}

export class Planet {
    public position: Position;
    public side: Side;
    public builds: number;
    public isBase: boolean;
    public energy: number;   // base
    public name: string;
    public hasCriedForHelp: boolean;
    public captureLock: CaptureLock;
    //public captureProgress: { by: Side, progress: number, player: Player } | undefined;   // NOT CLEAR CHECK USAGE

    constructor(v: number, h: number) {
        this.position = { v: v, h: h };
        this.side = "NEUTRAL";
        this.builds = 0;
        this.isBase = false;
        this.energy = 0;
        this.name = "unknown";
        this.hasCriedForHelp = false;
        this.captureLock = { status: false, time: 0 };
        //this.captureProgress = undefined;   // NOT CLEAR CHECK USAGE
    }

    makeBase(side: Side): void {
        const baseArray = side === "FEDERATION" ? bases.federation : bases.empire;
        this.isBase = true;
        this.side = side;
        this.energy = DEFAULT_BASE_ENERGY;
        baseArray.push(this);
    }

    callForHelp(v: number, h: number, side: Side): void {
        const allies = getNearbyAlliedShips(v, h, side, 10);

        for (const player of allies) {
            if (!player.ship) continue;
            const coords = ocdefCoords(player.settings.ocdef, player.ship.position, { v: v, h: h });
            const message = `Starbase at ${coords} under attack! Assist immediately.`;
            addPendingMessage(player, message);
        }
    }

    static getBases(side: Side | "ALL"): Planet[] {
        if (side === "ALL") {
            return [...bases.federation, ...bases.empire];
        }
        return side === "FEDERATION" ? bases.federation : bases.empire;
    }

    static generate(count: number = NUMBER_OF_PLANETS): Planet[] {
        const planets: Planet[] = [];
        for (let i = 0; i < count; i++) {
            let v: number, h: number;
            let conflict: boolean;
            let tries = 0;

            do {
                v = Math.floor(getRandom() * GRID_HEIGHT + 1);    // REPLACE FOR SEED
                h = Math.floor(getRandom() * GRID_WIDTH + 1); // REPLACE FOR SEED
                conflict = findObjectAtPosition(v, h) !== null;
                tries++;
            } while (conflict && tries < 500);

            if (conflict) {
                console.warn(`Could not safely place planet ${i + 1} after ${tries} attempts.`);
                continue;
            }

            const planet = new Planet(v, h);
            planet.name = `PL${i + 1}`;
            planet.side = "NEUTRAL";
            planets.push(planet);
        }

        return planets;
    }

    static generateBases(): void {
        const promotePlanetsToBases = (side: Side, planets: Planet[], max: number = 10) => {
            function shuffle(array: Planet[]) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(getRandom() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
                return array;
            }
            // Filter owned planets not already bases
            const eligiblePlanets = planets.filter(p => !p.isBase);

            // Randomize selection
            const shuffled = shuffle(eligiblePlanets);

            let bases = 0;
            for (const planet of shuffled) {
                if (bases >= max) break;
                planet.makeBase(side);
                bases++;
            }
        };

        promotePlanetsToBases("FEDERATION", planets);
        promotePlanetsToBases("EMPIRE", planets);
    }
}


// Counts-in BASBLD (exact DECWAR parity): pass {numply, numsid} from the sweep
export function baseEnergyRegeneration(triggeringPlayer: Player, counts: { numply: number; numsid: number }) {
    const isRomulan = !!triggeringPlayer.ship?.romulanStatus?.isRomulan;
    let n: number;
    if (isRomulan) {
        // n = floor(50 / (numply + 1)), both sides heal
        n = Math.floor(50 / (Math.max(0, counts.numply) + 1));
    } else {
        // n = floor(25 / numsid(team)), opposite side heals
        const safeNumsid = Math.max(1, counts.numsid);
        n = Math.floor(25 / safeNumsid);
    }
    const sidesToRegen: ("FEDERATION" | "EMPIRE")[] =
        isRomulan
            ? ["FEDERATION", "EMPIRE"]
            : triggeringPlayer.ship!.side === "FEDERATION" ? ["EMPIRE"] : ["FEDERATION"];
    for (const side of sidesToRegen) {
        const list = side === "FEDERATION" ? bases.federation : bases.empire;
        for (const base of list) {
            if (base.energy > 0) {
                base.energy = Math.min(base.energy + n, 1000);
            }
        }
    }
}

######## planets.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";


export function planetsCommand(player: Player, command: Command): void {
    const newArgs = ["PLANETS", ...command.args];
    listCommand(player, { ...command, args: newArgs });
}
######## player.ts
import { Socket } from 'net';
import { Ship } from './ship.js';
import { sendMessageToClient } from './communication.js';
import { players, removePlayerFromGame } from './game.js';
import { Side, ScanSetting, PromptSetting, OCDEF, ICDEF, OutputSetting, MAX_SHIELD_ENERGY, LS_CRITICAL_DAMAGE } from './settings.js';
import { AuthSession } from './util/auth.js';
import { findEmptyLocation } from './coords.js';
import { emitShipLeft, emitShipDestroyed } from './api/events.js';
import { iran } from './util/random.js';


const suffocationMessages = [
    "Life support failed. Your crew drew their final breaths and fell silent.",
    "Oxygen tanks empty. The ship now drifts, silent and lifeless.",
    "You hear one final gasp... then only the hum of dead systems remains.",
    "Without life support, the crew could not survive. All hands lost.",
    "No air. No hope. Just a hulk in space, and the echo of a failed mission."
];

export class Player {
    public auth: AuthSession;
    public joinTime: number;
    public stardate: number;
    public lastActivity: number;
    public socket: Socket;
    public isAdmin: boolean;
    public isOnHold: boolean;
    public inputBuffer: string;
    public pendingMessages: string[] = [];
    public multiLine: boolean;
    public ship: Ship | null;
    public gagList: Set<string>;
    public radioOn: boolean;
    //public alive: boolean;
    public history: string[];
    public historyIndex: number;
    public ready: boolean;
    public commandQueue: string[];
    public processingCommand: boolean;
    public currentCommandTimer: NodeJS.Timeout | null = null;
    public knownEnemyBases: { x: number; y: number; side: Side }[];
    public points: {
        damageToEnemies: number;
        enemiesDestroyed: number;
        damageToBases: number;
        planetsCaptured: number;
        basesBuilt: number;
        damageToRomulans: number;
        starsDestroyed: number;
        planetsDestroyed: number;
    };
    public settings: {
        scan: ScanSetting;
        prompt: PromptSetting;
        ocdef: OCDEF;
        icdef: ICDEF;
        output: OutputSetting;
        name: string | null;
    }
    public currentPrompt?: string;

    public callBack?: (who: Player, resp: string) => void;

    constructor(socket: Socket) {
        this.auth = {
            ip: socket.remoteAddress ?? 'unknown',
            email: undefined,
            code: undefined,
            authed: false,
            createdAt: Date.now()
        };
        this.socket = socket;
        this.isAdmin = false;
        this.joinTime = Date.now();
        this.stardate = 0;
        this.lastActivity = Date.now();
        this.isOnHold = false;
        this.inputBuffer = '';
        this.pendingMessages = [];
        this.multiLine = false;
        this.ship = this.createShip();
        this.gagList = new Set();
        this.radioOn = true;
        //this.alive = false;
        this.history = [];
        this.historyIndex = -1;
        this.ready = false;
        this.commandQueue = [];
        this.processingCommand = false;
        this.currentCommandTimer = null;
        this.knownEnemyBases = [];
        this.points = {
            damageToEnemies: 0,
            enemiesDestroyed: 0,
            damageToBases: 0,
            planetsCaptured: 0,
            basesBuilt: 0,
            damageToRomulans: 0,
            starsDestroyed: 0,
            planetsDestroyed: 0,
        };
        this.settings = {
            scan: "LONG",
            prompt: "NORMAL",
            ocdef: "ABSOLUTE",
            icdef: "ABSOLUTE",
            output: "LONG",
            name: null
        }
        this.currentPrompt = undefined;
    }

    getPrompt(): string {
        if (!this.ship) {
            return '??> ';
        }

        if (this.currentPrompt) {
            return `${this.currentPrompt}`;
        }

        if (!players.includes(this)) {
            return 'PG> ';
        }

        // NORMAL prompt style
        if (this.settings.prompt === 'NORMAL') {
            return 'Command: ';
        }

        // INFORMATIVE prompt style
        const flags: string[] = [];
        const ship = this.ship;

        // S: shields down or <10%
        if (ship.shieldsUp && ship.shieldEnergy < 0.1 * MAX_SHIELD_ENERGY) {
            flags.push('S');
        }

        // E: energy < 1000 (yellow alert)
        if (ship.energy < 1000) {
            flags.push('E');
        }

        // D: total device damage > 2000
        const totalDamage = Object.values(ship.devices)
            .reduce((sum, d) => sum + d, 0);
        if (totalDamage > 2000) {
            flags.push('D');
        }

        if (ship.devices.lifeSupport >= LS_CRITICAL_DAMAGE && ship.lifeSupportFailureTimer != null) {
            flags.push(`${ship.lifeSupportFailureTimer}L`);
        }

        // Combine flags; leave blank if none
        const prefix = flags.length ? flags.join('') : '';
        return `${prefix}> `;
    }

    toggleRadio(state: boolean): void {
        this.radioOn = state;
        sendMessageToClient(this, `Radio turned ${state ? "on" : "off"}.`);
    }

    gagShip(inputName: string): void {
        const resolved = Ship.resolveShipName(inputName);
        if (!resolved) {
            sendMessageToClient(this, `Unknown ship: ${inputName} `);
            return;
        }

        if (this.ship && this.ship.name === resolved) {
            sendMessageToClient(this, `You cannot gag yourself.`);
            return;
        }

        this.gagList.add(resolved.toUpperCase());
        sendMessageToClient(this, `Radio messages from ${resolved} will be ignored.`);
    }

    ungagShip(inputName: string): void {
        const resolved = Ship.resolveShipName(inputName);
        if (!resolved) {
            sendMessageToClient(this, `Unknown ship: ${inputName} `);
            return;
        }

        const removed = this.gagList.delete(resolved.toUpperCase());
        if (removed) {
            sendMessageToClient(this, `Radio messages from ${resolved} will now be received.`);
        } else {
            sendMessageToClient(this, `${resolved} was not gagged.`);
        }
    }

    updateLifeSupport(): void {
        if (!this.ship) return;
        if (this.ship.docked) return;              // parity: no drain while docked
        const damage = this.ship.devices?.lifeSupport ?? 0;

        if (damage >= LS_CRITICAL_DAMAGE) {
            // LS is inoperative
            if (this.ship.lifeSupportFailureTimer == null) {
                this.ship.lifeSupportFailureTimer = 60; // Start 60-stardate countdown
                sendMessageToClient(this, "WARNING: Life support failure. You must dock or repair within 5 stardates.");
            } else {
                this.ship.lifeSupportFailureTimer--;
                if (this.ship.lifeSupportFailureTimer > 0) {
                    sendMessageToClient(this, `Life support failure: ${this.ship.lifeSupportFailureTimer} stardates remaining.`);
                } else {
                    sendMessageToClient(this, suffocationMessages[iran(suffocationMessages.length)]);
                    if (this.ship) {
                        emitShipDestroyed(
                            this.ship.name,
                            this.ship.side,
                            { v: this.ship.position.v, h: this.ship.position.h },
                          /* by */ undefined,
                            "other"
                        );
                    }
                    removePlayerFromGame(this);
                }
            }
        } else {
            // LS repaired — reset countdown
            if (this.ship.lifeSupportFailureTimer !== null) {
                sendMessageToClient(this, "Life support repaired. Countdown cancelled.");
            }
            this.ship.lifeSupportFailureTimer = null;
        }
    }


    addToHistory(line: string): void {
        const trimmed = line.trim();
        if (trimmed.length === 0) return;
        if (trimmed.toUpperCase().startsWith("TE")) return;

        this.history.push(trimmed);
        if (this.history.length > 20) {
            this.history.shift();
        }

        this.historyIndex = -1; // reset browsing on new entry
    }

    getNextHistory(): string | undefined {
        const len = this.history.length;
        if (len === 0) return undefined;
        // return this.history[len - 1];
        //Move backward in history
        this.historyIndex--;

        if (this.historyIndex < 0) {
            this.historyIndex = len - 1; // loop back to most recent
        }

        return this.history[this.historyIndex];
    }


    quitGame(): void {
        emitShipLeft(this, "logout"); // or "logout"/"timeout"/"idle"
        const idx = players.findIndex(p => p === this);
        if (idx !== -1) players.splice(idx, 1);

        this.socket?.end();
        this.socket?.destroy();
    }

    createShip(): Ship | null {
        const ship = new Ship(this);
        ship.side = "NEUTRAL";
        ship.name = "NEUTRAL";
        this.stardate = 0;
        const pos = findEmptyLocation();
        if (pos) {
            ship.position = pos;
        } else {
            return null;
        }
        return ship;
    }
}

######## points.ts
import { Command } from "./command.js";
import { sendMessageToClient } from "./communication.js";
import { matchesPattern } from "./util/util.js";
import { Player } from './player.js';
import { Side, settings } from './settings.js';
import { pointsManager } from './game.js';

// PointsManager is assumed to be in a separate file (game.js), but included here for completeness
export type PointCategory =
  | 'damageToEnemies'
  | 'enemiesDestroyed'
  | 'damageToBases'
  | 'planetsCaptured'
  | 'basesBuilt'
  | 'damageToRomulans'
  | 'starsDestroyed'
  | 'planetsDestroyed';

type Points = Record<PointCategory, number>;

export class PointsManager {
  // === Primary totals (points) ===
  private teamTotals: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private turnTotals: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private playerTotals: Map<Player, number> = new Map();

  // === Lightweight counters for UI/compat ===
  private shipsCommissioned: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private enemiesDestroyed: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private planetsCaptured: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private planetsDestroyed: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private starsDestroyed: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  // === DECWAR buckets that the POINTS UI expects ===
  private damageToEnemies: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private damageToBases: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private basesBuilt: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  private damageToRomulans: Record<Side, number> = { FEDERATION: 0, EMPIRE: 0, ROMULAN: 0, NEUTRAL: 0 } as any;
  // === Per-category human-unit tallies for the POINTS UI (FORTRAN categories) ===
  private categoryTotals: Record<Side, Record<PointCategory, number>> = {
    FEDERATION: { damageToEnemies: 0, enemiesDestroyed: 0, damageToBases: 0, planetsCaptured: 0, basesBuilt: 0, damageToRomulans: 0, starsDestroyed: 0, planetsDestroyed: 0 },
    EMPIRE: { damageToEnemies: 0, enemiesDestroyed: 0, damageToBases: 0, planetsCaptured: 0, basesBuilt: 0, damageToRomulans: 0, starsDestroyed: 0, planetsDestroyed: 0 },
    ROMULAN: { damageToEnemies: 0, enemiesDestroyed: 0, damageToBases: 0, planetsCaptured: 0, basesBuilt: 0, damageToRomulans: 0, starsDestroyed: 0, planetsDestroyed: 0 },
    NEUTRAL: { damageToEnemies: 0, enemiesDestroyed: 0, damageToBases: 0, planetsCaptured: 0, basesBuilt: 0, damageToRomulans: 0, starsDestroyed: 0, planetsDestroyed: 0 },
  };

  // SIDE-OWNED sources (bases, captured planets, auto-defenses)
  creditInstallationDamage(ownerSide: Side, amount: number) {
    if (ownerSide === "NEUTRAL" || amount <= 0) return;
    this.teamTotals[ownerSide] = (this.teamTotals[ownerSide] ?? 0) + amount;
    this.turnTotals[ownerSide] = (this.turnTotals[ownerSide] ?? 0) + amount;
    // Installation fire counts as "damage to enemies" in FORTRAN
    this.categoryTotals[ownerSide].damageToEnemies += amount;
  }
  creditInstallationKill(ownerSide: Side, _bonus: number) {
    if (ownerSide === "NEUTRAL") return;
    // FORTRAN: +500 per enemy destroyed (installation-originated)
    const award = 500;
    this.teamTotals[ownerSide] = (this.teamTotals[ownerSide] ?? 0) + award;
    this.turnTotals[ownerSide] = (this.turnTotals[ownerSide] ?? 0) + award;
    this.enemiesDestroyed[ownerSide] = (this.enemiesDestroyed[ownerSide] ?? 0) + 1;
    this.categoryTotals[ownerSide].enemiesDestroyed += 1;
  }

  // SHIP-OWNED sources (we know the attacker)
  creditShipDamage(attacker: Player, amount: number) {
    const side = attacker.ship?.side as Side | undefined;
    if (!side || side === "NEUTRAL" || amount <= 0) return;
    this.playerTotals.set(attacker, (this.playerTotals.get(attacker) ?? 0) + amount);
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + amount;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + amount;
    this.categoryTotals[side].damageToEnemies += amount;
  }

  /**
   * Ship → BASE damage (FORTRAN "Damage to bases" bucket; 1:1 human units).
   * Use when a player's attack damages an enemy *base* (not a ship).
   */
  creditBaseDamageByShip(attacker: Player, amount: number) {
    const side = attacker.ship?.side as Side | undefined;
    if (!side || side === "NEUTRAL" || amount <= 0) return;
    this.playerTotals.set(attacker, (this.playerTotals.get(attacker) ?? 0) + amount);
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + amount;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + amount;
    this.categoryTotals[side].damageToBases += amount;
  }
  creditShipKill(attacker: Player, _victimSide: Side, _bonus: number) {
    const side = attacker.ship?.side as Side | undefined;
    if (!side || side === "NEUTRAL") return;
    // FORTRAN: +500 per enemy ship destroyed
    this.playerTotals.set(attacker, (this.playerTotals.get(attacker) ?? 0) + 500);
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + 500;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + 500;
    this.enemiesDestroyed[side] = (this.enemiesDestroyed[side] ?? 0) + 1;
    this.categoryTotals[side].enemiesDestroyed += 1;
  }

  /** @deprecated use creditInstallationDamage/creditShipDamage instead. */
  addDamageToEnemies(amount: number, by: Player | undefined, side: Side) {
    if (by) return this.creditShipDamage(by, amount);
    return this.creditInstallationDamage(side, amount);
  }

  // Damage specifically to enemy bases is tracked in its own bucket (FORTRAN).
  addDamageToBases(amount: number, by: Player | undefined, side: Side) {
    if (amount <= 0) return;
    if (by) {
      this.creditBaseDamageByShip(by, amount);
      return;
    }
    if (!side || side === "NEUTRAL") return;
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + amount;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + amount;
    this.categoryTotals[side].damageToBases += amount;
  }

  /**
   * Romulan damage (FORTRAN: "Damage to Romulans" — scale 1).
   * Must credit team/turn (and player when attributed) exactly like normal damage.
   */
  addDamageToRomulans(amount: number, by: Player | undefined, side: Side) {
    if (amount <= 0) return;
    const s: Side | undefined = by?.ship?.side ?? side;
    if (!s || s === "NEUTRAL") return;
    // bucket (for POINTS columns)
    this.damageToRomulans[s] = (this.damageToRomulans[s] ?? 0) + amount;
    // per-player attribution (if a ship dealt the damage)
    if (by) {
      this.playerTotals.set(by, (this.playerTotals.get(by) ?? 0) + amount);
    }
    // team and turn totals (scale 1 like other damage)
    this.teamTotals[s] = (this.teamTotals[s] ?? 0) + amount;
    this.turnTotals[s] = (this.turnTotals[s] ?? 0) + amount;
  }

  // FORTRAN: Bases built (1000 points each) — award immediately and track category
  addBasesBuilt(count: number, side: Side) {
    if (count <= 0 || side === "NEUTRAL") return;
    this.basesBuilt[side] = (this.basesBuilt[side] ?? 0) + count;
    const award = 1000 * count;
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + award;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + award;
    this.categoryTotals[side].basesBuilt += count;
  }


  // (optional) getters for POINTS UI
  getTeamTotals() { return { ...this.teamTotals }; }
  getTurnTotals() { return { ...this.turnTotals }; }
  getPlayerTotal(p: Player) { return this.playerTotals.get(p) ?? 0; }

  // === Back-compat shims ===
  // Keep behavior minimal & predictable; callers can migrate gradually to explicit APIs.

  // Used by: capture flow UI; records count only (no points by itself here).
  addPlanetsCaptured(count: number, _by: Player | undefined, side: Side) {
    if (!side || side === "NEUTRAL" || count === 0) return;
    this.planetsCaptured[side] = (this.planetsCaptured[side] ?? 0) + count;
    this.categoryTotals[side].planetsCaptured += count;
    // FORTRAN: +100 per successful capture
    const award = 100 * count;
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) + award;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) + award;
  }

  // Used by: nova/kill paths; increments kill COUNTER only (points should be credited where the kill is decided).
  addEnemiesDestroyed(count: number, by: Player | undefined, side: Side) {
    if (by) {
      // prefer explicit path for points; this shim only keeps a counter for UI
      this.enemiesDestroyed[by.ship!.side as Side] = (this.enemiesDestroyed[by.ship!.side as Side] ?? 0) + count;
      this.categoryTotals[by.ship!.side as Side].enemiesDestroyed += count;
    } else if (side && side !== "NEUTRAL") {
      this.enemiesDestroyed[side] = (this.enemiesDestroyed[side] ?? 0) + count;
      this.categoryTotals[side].enemiesDestroyed += count;
    }
  }


  // Nova star collapse counter; no points here (adjust if you want stars to grant points).
  addStarsDestroyed(count: number, by: Player | undefined, side: Side) {
    if (!side || side === "NEUTRAL") return;
    if (count <= 0) return; // counts only (protect against passing -50 etc.)
    this.starsDestroyed[side] = (this.starsDestroyed[side] ?? 0) + count;
    this.categoryTotals[side].starsDestroyed += count;
    // credit the player's raw bucket so BUZZARD column reflects it
    if (by) {
      by.points.starsDestroyed = (by.points.starsDestroyed ?? 0) + count;
    }
    // FORTRAN: -50 per star destroyed
    const penalty = 50 * count;
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) - penalty;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) - penalty;
  }

  addPlanetsDestroyed(count: number, by: Player | undefined, side: Side) {
    if (!side || side === "NEUTRAL") return;
    if (count <= 0) return; // counts only (protect against passing -100 / -1000)
    this.planetsDestroyed[side] = (this.planetsDestroyed[side] ?? 0) + count;
    this.categoryTotals[side].planetsDestroyed += count;
    // credit the player's raw bucket so BUZZARD column reflects it
    if (by) {
      by.points.planetsDestroyed = (by.points.planetsDestroyed ?? 0) + count;
    }
    // FORTRAN: -100 per planet destroyed
    const penalty = 100 * count;
    this.teamTotals[side] = (this.teamTotals[side] ?? 0) - penalty;
    this.turnTotals[side] = (this.turnTotals[side] ?? 0) - penalty;
  }


  addRomulansDestroyed(count: number, by: Player | undefined, side: Side) {
    if (count === 0) return;
    const s = by ? (by.ship?.side as Side | undefined) : side;
    if (!s || s === "NEUTRAL") return;
    // Counter for UI (if you show it) and +500 each to totals
    this.categoryTotals[s].enemiesDestroyed += 0; // keep enemy-ship counter separate
    const award = 500 * count;
    this.teamTotals[s] = (this.teamTotals[s] ?? 0) + award;
    this.turnTotals[s] = (this.turnTotals[s] ?? 0) + award;
  }

  // UI helpers used by points panel
  // Return the eight raw DECWAR buckets from categoryTotals (single source of truth).
  getPointsForSide(side: Side): any {
    const c = this.categoryTotals[side];
    return {
      damageToEnemies: c.damageToEnemies,
      enemiesDestroyed: c.enemiesDestroyed,
      damageToBases: c.damageToBases,
      planetsCaptured: c.planetsCaptured,
      basesBuilt: c.basesBuilt,
      damageToRomulans: c.damageToRomulans,
      starsDestroyed: c.starsDestroyed,
      planetsDestroyed: c.planetsDestroyed,
      // extras shown by your UI but not part of FORTRAN point math
      total: this.teamTotals[side] ?? 0,
      turnTotal: this.turnTotals[side] ?? 0,
      shipsCommissioned: this.shipsCommissioned[side] ?? 0,
    };
  }
  getShipsCommissioned(side: Side): number {
    return this.shipsCommissioned[side] ?? 0;
  }
  incrementShipsCommissioned(side: Side) {
    if (!side || side === "NEUTRAL") return;
    this.shipsCommissioned[side] = (this.shipsCommissioned[side] ?? 0) + 1;
  }
}


// Types for points command
interface Score {
  label: string;
  points: Points;
  ships: number;
  side?: Side; // Tracks side for team scores
}

export function pointsCommand(player: Player, command: Command): void {
  if (!player.ship) {
    sendMessageToClient(player, "You must be in a ship to use this command.");
    return;
  }

  const keywords: string[] = [];
  const filters = ["Me", "I", "Federation", "Human", "Empire", "Klingon", "Romulan", "All"];

  for (const arg of command.args) {
    let matched = false;
    for (const pattern of filters) {
      if (matchesPattern(arg, pattern)) {
        keywords.push(pattern.toUpperCase());
        matched = true;
        break;
      }
    }
    if (!matched) {
      sendMessageToClient(player, `Invalid filter: ${arg}`);
      return;
    }
  }

  const scores: Score[] = [];

  // Default to individual score if no keywords
  if (keywords.length === 0 || keywords.includes("ALL") || keywords.includes("ME") || keywords.includes("I")) {
    scores.push({
      label: player.ship.name,
      points: player.points,
      ships: 1,
      side: player.ship.side
    });
  }

  // Federation score
  if (keywords.includes("ALL") || keywords.includes("FEDERATION") || keywords.includes("HUMAN")) {
    scores.push({
      label: "FEDERATION",
      points: pointsManager.getPointsForSide("FEDERATION"),
      ships: pointsManager.getShipsCommissioned("FEDERATION"),
      side: "FEDERATION"
    });
  }

  // Empire score
  if (keywords.includes("ALL") || keywords.includes("EMPIRE") || keywords.includes("KLINGON")) {
    scores.push({
      label: "EMPIRE",
      points: pointsManager.getPointsForSide("EMPIRE"),
      ships: pointsManager.getShipsCommissioned("EMPIRE"),
      side: "EMPIRE"
    });
  }

  // Romulan score
  if (keywords.includes("ALL") || keywords.includes("ROMULAN")) {
    scores.push({
      label: "ROMULAN",
      points: pointsManager.getPointsForSide("ROMULAN"),
      ships: pointsManager.getShipsCommissioned("ROMULAN"),
      side: "ROMULAN"
    });
  }

  const output = formatScores(scores, player);
  sendMessageToClient(player, output);
}

function formatScores(scores: Score[], player: Player): string {
  if (scores.length < 1 || scores.length > 4) {
    return "";
  }

  // Scaling factors per DECWAR help text
  const pointScales: Record<PointCategory, number> = {
    damageToEnemies: 1,
    enemiesDestroyed: 500,
    damageToBases: 1,
    planetsCaptured: 100,
    basesBuilt: 1000,
    damageToRomulans: 1,
    starsDestroyed: -50,
    planetsDestroyed: -100
  };

  // Point-related headers
  const pointHeaders: { label: string; key: keyof Points }[] = [
    { label: "Damage to enemies", key: "damageToEnemies" },
    { label: "Enemies destroyed", key: "enemiesDestroyed" },
    { label: "Damage to bases", key: "damageToBases" },
    { label: "Planets captured", key: "planetsCaptured" },
    { label: "Bases built", key: "basesBuilt" },
    { label: "Damage to Romulans", key: "damageToRomulans" },
    { label: "Stars destroyed", key: "starsDestroyed" },
    { label: "Planets destroyed", key: "planetsDestroyed" }
  ];

  // Filter headers with non-zero values
  const activeHeaders = pointHeaders.filter(header =>
    scores.some(score => score.points[header.key] !== 0)
  );

  // Fixed headers
  const fixedHeaders = ["", "Total points:", "", "Number of ships:", "Pts. / player:", "Pts. / stardate:"];
  const headers = [...activeHeaders.map(h => h.label), ...fixedHeaders];
  const maxLabelLength = Math.max(...scores.map(s => s.label.length), ...headers.map(h => h.length));
  const colWidth = 15;
  const formatNum = (n: number): string => n.toFixed(0).padStart(6); // DECWAR uses integers

  // Build header row
  let result = " ".repeat(maxLabelLength);
  for (const score of scores) {
    result += score.label.padStart(colWidth);
  }
  result += "\r\n";

  // Build data rows
  for (const header of headers) {
    if (header === "") {
      result += "\r\n";
      continue;
    }
    result += header.padEnd(maxLabelLength);
    for (const score of scores) {
      let value: string;
      switch (header) {
        case "Total points:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          value = formatNum(total);
          break;
        }
        case "Number of ships:": {
          value = formatNum(score.ships);
          break;
        }
        case "Pts. / player:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          const ships = score.ships;
          value = formatNum(ships > 0 ? Math.floor(total / ships) : 0); // Integer division
          break;
        }
        case "Pts. / stardate:": {
          const total = activeHeaders.reduce((sum, h) => sum + score.points[h.key] * pointScales[h.key], 0);
          let turns: number;
          if (score.side && score.side === player.ship?.side && score.ships === 1) {
            // Individual player
            turns = player.stardate;
          } else if (score.side) {
            // Team
            const sideKey = score.side.toLowerCase() as keyof typeof settings.teamTurns;
            turns = settings.teamTurns[sideKey] || 0;
          } else {
            turns = 0;
          }
          value = formatNum(turns > 0 ? Math.floor(total / turns) : 0); // Integer division
          break;
        }
        default: {
          const pointHeader = activeHeaders.find(h => h.label === header);
          value = pointHeader ? formatNum(score.points[pointHeader.key] * pointScales[pointHeader.key]) : "0".padStart(6);
          break;
        }
      }
      result += value.padStart(colWidth);
    }
    result += "\r\n";
  }

  return `\r\n${result}\r\n`;
}
######## pregame.ts
// pregame command dispatcher for DECWAR-style game
import { Player } from './player.js';
import { Command, CommandHandler, tokenize } from './command.js';
import { sendMessageToClient } from './communication.js';
import { generateGalaxy } from './game.js';
import { ran, iran } from './util/random.js';

// Import only the valid pre-game handlers
import { activateCommand } from './activate.js';
import { gripeCommand } from './gripe.js';
import { helpCommand } from './help.js';
import { newsCommand } from './news.js';
import { timeCommand } from './time.js';
import { usersCommand } from './users.js';
import { quitCommand } from './quit.js';
import { findEmptyLocation } from './coords.js';
import {
    FEDERATION_SHIPS,
    EMPIRE_SHIPS,
    Side,
    settings
} from './settings.js';
import { Ship } from './ship.js';
import { generateAccessCode, isValidEmail } from './util/auth.js';
import { sendEmail } from './util/send-email.js';
import { addEmailToMailchimp } from './util/email.js';
import { setRandomSeed } from './util/random.js';
import { players } from './game.js';
import { pointsManager } from './game.js';
import { emitShipJoined } from './api/events.js';

// Map of pre-game command keys to their handlers
const pgCommands = new Map<string, CommandHandler>([
    ['AC', activateCommand],    // ACTIVATE
    ['GR', gripeCommand],       // GRIPE
    ['HE', helpCommand],        // HELP
    ['NE', newsCommand],        // NEWS
    ['TI', timeCommand],        // TIME
    ['US', usersCommand],       // USERS
    ['QU', quitCommand],       // QUIT
]);

/**
 * Parses and executes pre-game (lobby) commands.
 * Routes input to the pgCommands map.
 */
export function parseAndExecutePGCommand(player: Player, input: string): void {
    if (!player) {
        sendMessageToClient(player, `Unknown player (pgCommand)`);
        return;
    }

    try {
        const parsed = tokenize(input);

        if (Array.isArray(parsed.tokens) && parsed.tokens.length > 0) {
            for (const commandTokens of parsed.tokens) {
                const commandKey = commandTokens[0].toUpperCase();
                const commandObject = new Command(
                    commandKey,
                    commandTokens.slice(1),
                    input
                );

                // Find the first handler whose key matches the start of the input
                let matchedHandler: CommandHandler | null = null;
                for (const [key, handler] of pgCommands) {
                    if (key[0] == commandKey.toUpperCase()[0]) {  // note matches 1 letter, make sure this stays legit
                        matchedHandler = handler;
                        break;
                    }
                }

                if (matchedHandler) {
                    matchedHandler(player, commandObject);
                    // Handlers are responsible for showing prompts/messages.
                } else {
                    sendMessageToClient(
                        player,
                        `Unknown pre-game command: ${commandKey}`
                    );
                }
            }
        }
    } catch (error: unknown) {
        sendMessageToClient(
            player,
            `Error parsing pre-game command: ${error instanceof Error ? error.message : String(error)}`
        );
    }
}

export function sendGameInfo(player: Player): void {
    // external setu06 !There are Romulans in this game.!
    // external setu07 !There are Black holes in this game.!
    sendMessageToClient(player, `Romulans are ${settings.romulans ? "" : "NOT "}in this game.`);
    sendMessageToClient(player, `Black holes are ${settings.blackholes ? "" : "NOT "}in this game.`);
    sendMessageToClient(player,
        `Currently there are ${players.filter(p => p.ship?.side === "FEDERATION").length} Federation ships and ${players.filter(p => p.ship?.side === "EMPIRE").length} Empire ships.\r\n`);
}

export function promptForEmail(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = `ENTER EMAIL FOR ACCESS: `;
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed === "theq") {
            pl.auth.authed = true;
            if (settings.generated) {
                sendGameInfo(pl);
                promptForLevel(pl, 0);
            } else {
                promptForRegularOrTournament(pl, 0);
            }
            // sendMessageToClient(pl, "Welcome back to the game Captain!");
            // if (pl.ship.side != "NEUTRAL") {
            //     promptForShip(pl, 0);
            // } else {
            //     promptForSide(pl, 0);
            // }
        } else if (isValidEmail(trimmed)) {
            pl.auth.email = trimmed;
            pl.auth.code = generateAccessCode();
            pl.auth.createdAt = Date.now();

            sendEmail({
                to: trimmed,
                subject: 'DECWARJS Access Code',
                text: `Welcome to DECWARJS!\n\nYour one-time login code is: ${pl.auth.code}`
            }).catch(err => {
                console.error(`Failed to send email to ${trimmed}:`, err);
                // Optionally notify the player:
                sendMessageToClient(pl, "Email error. Please try again later.");
                return;
            });
            addEmailToMailchimp(trimmed);
            promptForAccessCode(pl, 0);
            // }
        } else {
            sendMessageToClient(pl, "Invalid email.");
            promptForEmail(pl, iter + 1);
            sendMessageToClient(player, "", false, true);
        }

    };
}

export function promptForAccessCode(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "ACCESS CODE: ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed === pl.auth.code) {
            pl.auth.authed = true;
            if (settings.generated) {
                sendGameInfo(pl);
                promptForLevel(pl, 0);
            } else {
                promptForRegularOrTournament(pl, 0);
            }
        } else {
            sendMessageToClient(pl, "Invalid access code, check email for code.");
            promptForAccessCode(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function promptForRegularOrTournament(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Regular or Tournament game? ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("R")) {
            setRandomSeed(Date.now().toString());
            generateGalaxy();
            promptForLevel(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("T")) {
            promptForSeed(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter R or T. ");
            promptForRegularOrTournament(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}
export function promptForSeed(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Tournament name or number: ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.length >= 1) {
            setRandomSeed(trimmed);
            promptForRomulanEmpire(pl, 0);
        } else {
            sendMessageToClient(pl, "Invalid entry.");
            promptForSeed(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function promptForLevel(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = `Are you:\r\n1 Beginner\r\n2 Intermediate\r\n3 Expert\r\n\r\nWhich? `;
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (["1", "2", "3"].includes(trimmed)) {
            const level = parseInt(trimmed);

            if (level === 1) {
                // Beginner settings
                pl.settings.prompt = "NORMAL";
                pl.settings.scan = "LONG";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "ABSOLUTE";
                pl.settings.output = "MEDIUM";
            } else if (level === 2) {
                // Intermediate settings
                pl.settings.prompt = "INFORMATIVE";
                pl.settings.scan = "LONG";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "RELATIVE";
                pl.settings.output = "MEDIUM";
            } else if (level === 3) {
                // Expert settings
                pl.settings.prompt = "INFORMATIVE";
                pl.settings.scan = "SHORT";
                pl.settings.ocdef = "BOTH";
                pl.settings.icdef = "ABSOLUTE";
                pl.settings.output = "SHORT";
            }
            sendMessageToClient(pl, "Medium output format.\r\nNormal command prompt.\r\nLong SCAN format.\r\nAbsolute coordinates are default for input.\r\nBoth coordinates are default for output.\r\n");

            chooseSide(pl);
        } else {
            sendMessageToClient(pl, "Invalid choice. Please enter 1, 2, or 3.");
            promptForLevel(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}

export function chooseSide(player: Player): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to choose a side.");
        return;
    }

    // 1) Compute current balance
    const fedCount = players.filter(p => p.ship!.side === 'FEDERATION').length;
    const empCount = players.filter(p => p.ship!.side === 'EMPIRE').length;

    // 2) Auto‑assign if one side is under‑manned by 2 or more
    if (fedCount + 2 <= empCount) {
        player.ship.side = 'FEDERATION';
        sendMessageToClient(player,
            `Auto-balancing: placing you on Federation (F=${fedCount}, E=${empCount})\r\n`,
            false, true
        );
        return promptForShip(player, 0);
    }
    if (empCount + 2 <= fedCount) {
        player.ship.side = 'EMPIRE';
        sendMessageToClient(player,
            `Auto-balancing: placing you on Empire (F=${fedCount}, E=${empCount})\r\n`,
            false, true
        );
        return promptForShip(player, 0);
    }

    promptForSide(player, 0);
}

function promptForSide(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts to choose side. Please try again later.");
        return;
    }
    player.currentPrompt = 'Which side do you wish to join?\r\n(Federation or Empire) ';
    player.callBack = (pl, resp) => {
        if (!pl.ship) {
            sendMessageToClient(pl, "You must be in a ship to choose a side.");
            return;
        }
        const choice = resp.trim().toUpperCase();
        let desired: 'FEDERATION' | 'EMPIRE' | null = null;
        if (choice.startsWith('F')) desired = 'FEDERATION';
        else if (choice.startsWith('E')) desired = 'EMPIRE';
        else if (choice == "") desired = getBalancedSide();  // game chooses side

        if (!desired) {
            return promptForSide(pl, iter + 1);
        }
        pl.ship.side = desired;
        const formattedSide = desired.charAt(0).toUpperCase() + desired.slice(1).toLowerCase();
        sendMessageToClient(pl, `\r\nYou will join the ${formattedSide}.\r\n\r\n`, false, true);
        promptForShip(pl, 0);
    }
    sendMessageToClient(player, "", false, true);
}

export function promptForShip(player: Player, iter: number): void {
    const side = player.ship?.side ?? "NEUTRAL";
    if (side == "NEUTRAL") {
        console.log("Player in promptForShip must choose a side first.");
        return;
    }

    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts to choose ship. Please try again later.");
        return;
    }
    const available = getAvailableShips(side);
    if (available.length === 0) {
        sendMessageToClient(player, `Sorry, no ${side} ships are currently free.`);
        return;
    }

    player.currentPrompt = `These vessels are available:\r\n\r\n${available
        .map(name => name.charAt(0).toUpperCase() + name.slice(1).toLowerCase())
        .join("\r\n")}\r\n\r\nWhich vessel do you desire? `;


    player.callBack = (pl, resp) => {
        let actualShipName;
        const choice = resp ? resp.trim().toUpperCase() : '';

        if (choice == "") {
            actualShipName = getRandomShip(pl.ship!.side);
            if (actualShipName) {
                sendMessageToClient(player, `You will captain the ${actualShipName}`);
            } else {
                sendMessageToClient(player, `Sorry, no ${pl.ship!.side} ships are currently free.`);
                promptForShip(pl, iter + 1);
                return;
            }
        } else {
            const freshAvailable = getAvailableShips(pl.ship!.side); // Recheck in case others claimed
            actualShipName = freshAvailable.find(ship => ship.startsWith(choice));
        }

        if (!actualShipName) {
            // Invalid input or ship no longer available
            if (!choice || !available.some(ship => ship.startsWith(choice))) {
                sendMessageToClient(player, 'That is not a valid ship name.');
            } else {
                sendMessageToClient(player, 'That ship is no longer in inventory.');
            }
            promptForShip(pl, iter + 1); // Recurse to re-prompt
            return;
        }

        const side = pl.ship!.side;
        pl.ship = new Ship(pl);
        // Successful selection
        pl.ship.name = actualShipName;
        pl.ship.side = side;
        pl.ship.position = findEmptyLocation() || { v: 1, h: 1 };
        if (side == "FEDERATION") {
            pointsManager.incrementShipsCommissioned('FEDERATION');
        } else if (side == "EMPIRE") {
            pointsManager.incrementShipsCommissioned('EMPIRE');
        }
        emitShipJoined(player, "launch"); // or "assign"/"reconnect"

        players.push(player);
        sendMessageToClient(player, `\r\nDECWARJS game #${settings.gameNumber}, ${settings.tournamentSeed}\r\n\r\n`, false, true);
    };

    sendMessageToClient(player, "", false, true); // Trigger the prompt
}

export function getAvailableShips(side: Side): string[] {
    const masterList = side === "FEDERATION" ? FEDERATION_SHIPS : EMPIRE_SHIPS;
    const taken = players.map(p => p.ship?.name ?? "Unknown");
    return masterList.filter(name => !taken.includes(name));
}

function getBalancedSide(): "EMPIRE" | "FEDERATION" {
    const fedCount = players.filter(p => p.ship!.side === "FEDERATION").length;
    const empCount = players.filter(p => p.ship!.side === "EMPIRE").length;

    if (fedCount < empCount) {
        return "FEDERATION";
    } else if (empCount < fedCount) {
        return "EMPIRE";
    } else {
        return ran() < 0.5 ? "FEDERATION" : "EMPIRE";
    }
}

function getRandomShip(side: Side): string | null {
    if (side == "NEUTRAL") return null;
    const available = getAvailableShips(side);
    if (available.length === 0) return null;
    const idx = iran(available.length);
    return available[idx];
}

export function promptForRomulanEmpire(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Is the Romulan Empire involved in this conflict? (Yes or No) ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("Y")) {
            settings.romulans = true;
            promptForBlackholes(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("N")) {
            settings.romulans = false;
            promptForBlackholes(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter Y or N. ");
            promptForRomulanEmpire(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}


export function promptForBlackholes(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Do you want black holes? (Yes or No) ";

    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (trimmed.toUpperCase().startsWith("Y")) {
            settings.blackholes = true;

            generateGalaxy();

            promptForLevel(pl, 0);
        } else if (trimmed.toUpperCase().startsWith("N")) {
            settings.blackholes = false;
            generateGalaxy();
            promptForLevel(pl, 0);
        } else {
            sendMessageToClient(pl, "Please enter Y or N. ");
            promptForBlackholes(pl, iter + 1);
        }
    };
    sendMessageToClient(player, "", false, true);
}
######## quit.ts
import { sendMessageToClient } from "./communication.js";
import { Player } from "./player.js";
import { matchesPattern } from "./util/util.js";


/**
 * QUIT — Resign from the game. Destroys the ship and ends the session.
 */
export function quitCommand(player: Player): void {
    confirmQuit(player, 0);
}


function confirmQuit(player: Player, iter: number): void {
    if (iter > 4) {
        sendMessageToClient(player, "Too many attempts. Please try again later.");
        return;
    }
    player.currentPrompt = "Are you sure you want to quit? (Y/N): ";
    player.callBack = (pl, resp) => {
        const trimmed = resp.trim();
        if (matchesPattern(trimmed, "Yes")) {
            quit(pl);
        } else if (matchesPattern(trimmed, "No")) {
            sendMessageToClient(player, "", false, true);
        } else {
            //sendMessageToClient(pl, "Invalid response. Please enter Yes or No.");
            player.currentPrompt = "Are you sure you want to quit? (Y/N): ";
            sendMessageToClient(player, "", false, true);
            confirmQuit(pl, iter + 1);
        }
    };
}


function quit(player: Player): void {
    //  const score = player.score?.total ?? 0;
    const output = player.settings?.output ?? "MEDIUM";

    // Format message based on OutputSetting
    if (output === "SHORT") {
        sendMessageToClient(player, `Quit`, true, false);
    } else if (output === "LONG") {
        sendMessageToClient(player, "You have chosen to resign from your post as captain.", true, false);
    } else {
        // MEDIUM
        sendMessageToClient(player, "You have quit the game.", true, false);
    }

    // Remove player and disconnect
    player.quitGame();
}
######## radio.ts
import { Command } from "./command.js";
import { Player } from "./player.js";
import { sendMessageToClient, } from "./communication.js";

export function radioCommand(player: Player, command: Command): void {
    const args = command.args;
    const action = args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use RADIO.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    switch (action) {
        case "ON":
            player.toggleRadio(true);
            return;
        case "OFF":
            player.toggleRadio(false);
            return;
        case "G":
        case "GAG":
            if (!args[1]) {
                sendMessageToClient(player, "Specify a ship to gag. Example: RADIO GAG LEXINGTON");
            } else {
                player.gagShip(args[1].toUpperCase());
            }
            return;
        case "U":
        case "UNGAG":
            if (!args[1]) {
                sendMessageToClient(player, "Specify a ship to ungag. Example: RADIO UNGAG LEXINGTON");
            } else {
                player.ungagShip(args[1].toUpperCase());
            }
            return;
        case undefined:
            sendMessageToClient(player, "No RADIO command specified. Use RADIO ON/OFF/GAG/UNGAG or RADIO <message>.");
            return;
    }
}
######## repair.ts
import { Player } from './player.js';
import { sendMessageToClient, putClientOnHold, releaseClient } from './communication.js';
import {
    MAX_SHIP_ENERGY,
    MAX_SHIELD_ENERGY,
    ENERGY_REPAIR_AMOUNT,
    ENERGY_REPAIR_COST,
    SHIELD_REPAIR_AMOUNT,
    SHIELD_REPAIR_COST,
    OutputSetting,
} from './settings.js';
import { DeviceName } from './ship.js';
import { Command } from './command.js';
//import { starbasePhaserDefense } from './base.js'; TODO: Add this back in

export function repairCommand(player: Player, command: Command, done?: () => void): void {
    if (!player.ship) {
        sendMessageToClient(player, "You cannot repair — you have no ship.");
        done?.();
        return;
    }

    const mode: OutputSetting = player.settings.output ?? "LONG";

    const defaultRepair = player.ship.docked ? 100 : 50;
    const repairAmount = command.args.length > 0 ? parseInt(command.args[0], 10) : defaultRepair;

    if (isNaN(repairAmount) || repairAmount <= 0) {
        sendMessageToClient(player, "Invalid repair amount. Usage: RE [<units>]");
        done?.();
        return;
    }

    const damagedDevices = Object.entries(player.ship.devices)
        .filter(entry => entry[1] > 0) as [DeviceName, number][];

    if (
        damagedDevices.length === 0 &&
        player.ship.energy >= MAX_SHIP_ENERGY &&
        player.ship.shieldEnergy >= MAX_SHIELD_ENERGY
    ) {
        sendMessageToClient(player, "All systems are fully operational. No repairs needed.");
        done?.();
        return;
    }

    const delaySeconds = (repairAmount * 0.08) * (player.ship.docked ? 0.5 : 1);
    putClientOnHold(player, "Repairing...");

    const timer = setTimeout(() => {
        const repaired: string[] = [];
        let totalDeviceRepair = 0;

        if (!player.ship) {
            sendMessageToClient(player, "You cannot repair — you have no ship.");
            done?.();
            return;
        }

        for (const [device, damage] of damagedDevices) {
            const repair = Math.min(repairAmount, damage);
            player.ship.devices[device] -= repair;
            totalDeviceRepair += repair;

            if (mode === "SHORT") {
                sendMessageToClient(player, `${device}+${repair}`);
            } else if (mode === "MEDIUM") {
                sendMessageToClient(player, `${device} repaired ${repair}`);
            } else {
                sendMessageToClient(player, `${device} repaired ${repair} units.`);
            }
        }

        if (player.ship.shieldEnergy < MAX_SHIELD_ENERGY) {
            if (player.ship.energy >= SHIELD_REPAIR_COST) {
                player.ship.energy -= SHIELD_REPAIR_COST;
                const restored = Math.min(SHIELD_REPAIR_AMOUNT, MAX_SHIELD_ENERGY - player.ship.shieldEnergy);
                player.ship.shieldEnergy += restored;
                repaired.push("shields");
            } else {
                if (mode !== "SHORT") {
                    sendMessageToClient(player, "Insufficient energy to repair shields.");
                }
            }
        }

        if (player.ship.energy < MAX_SHIP_ENERGY && player.ship.energy >= ENERGY_REPAIR_COST) {
            const restored = Math.min(ENERGY_REPAIR_AMOUNT, MAX_SHIP_ENERGY - player.ship.energy);
            player.ship.energy += restored;
            repaired.push("energy");
        }

        if (totalDeviceRepair > 0 || repaired.length > 0) {
            if (mode === "SHORT") {
                sendMessageToClient(player, `+${totalDeviceRepair} ${repaired.join(", ")}`);
            } else if (mode === "MEDIUM") {
                sendMessageToClient(player, `Repair complete: ${totalDeviceRepair} units. Restored: ${repaired.join(", ")}`);
            } else {
                sendMessageToClient(player, `Repair completed. Devices repaired: ${totalDeviceRepair} units. Restored: ${repaired.join(", ")}`);
            }
        } else {
            sendMessageToClient(player, "Repair completed. No systems needed repair.");
        }

        releaseClient(player);
        done?.();
    }, delaySeconds * 1000);

    player.currentCommandTimer = timer;
    // starbasePhaserDefense(player);

    if (mode !== "SHORT") {
        sendMessageToClient(player, `Beginning repair of ${repairAmount} units... (${delaySeconds.toFixed(1)}s)`);
    }
}

/**
 * Auto-repair that runs after every time-consuming move (FORTRAN REPAIR with il=3).
 * Silently subtracts the normal per-turn repair from EACH damaged device.
 * Note: FORTRAN repsiz=300 corresponds to 30 real units; we use 30 here.
 * Docking does NOT accelerate this path (il==3 is not promoted to docked speed).
 */
export function autoRepairTick(player: Player): void {
    if (!player.ship) return;
    const NORMAL_TURN_REPAIR = 30; // DECWAR manual: "normal repair rate of 30 units per turn"
    let any = false;
    for (const [device, dmg] of Object.entries(player.ship.devices)) {
        const cur = typeof dmg === "number" ? dmg : 0;
        if (cur > 0) {
            const newVal = Math.max(0, cur - NORMAL_TURN_REPAIR);
            // @ts-expect-error: DeviceName index is valid at runtime
            player.ship.devices[device] = newVal;
            any = true;
        }
    }
    // No messages and no pause (matches FORTRAN REPAIR il=3 behavior).
}

######## romulan.ts
// romulan.ts — FORTRAN-parity Romulan (ROMDRV/ROMTOR/ROMSTR/PHAROM/TOROM/DEADRO)

import { ran, iran } from './util/random.js';
import { Player } from "./player.js";
import { NullSocket } from "./util/nullsocket.js";
import { GRID_HEIGHT, GRID_WIDTH, settings } from "./settings.js";
import { players, bases, stars, planets, pointsManager, checkEndGame } from "./game.js";
import { addPendingMessage } from "./communication.js";
import { queueCommands } from "./command.js";
import { gameEvents } from "./api/events.js";

// Switchable speech targeting policy (set default you believe matches FORTRAN)
type TauntPolicy = "NEAREST_ONLY" | "SINGLE_SHIP_OR_SIDE_OR_ALL" | "SIDE_PREFERENCE";
const ROMULAN_TAUNT_POLICY: TauntPolicy = "SINGLE_SHIP_OR_SIDE_OR_ALL";

function pickTellAudience(recipients: Player[]): { kind: "SHIP" | "SIDE" | "ALL"; value?: string } {
    // Defensive
    const r = recipients.filter(p => p.ship);
    if (r.length === 0) return { kind: "ALL" };

    switch (ROMULAN_TAUNT_POLICY) {
        case "NEAREST_ONLY": {
            // Always taunt the single nearest target ship (even if many are around)
            const nearest = r.reduce((best, p) => {
                const d = chebyshev(p.ship!.position, romulan!.ship!.position);
                return !best || d < best.d ? { p, d } : best;
            }, null as null | { p: Player; d: number });
            return { kind: "SHIP", value: nearest!.p.ship!.name };
        }
        case "SIDE_PREFERENCE": {
            // If any FEDs are present, taunt FED side; else if any EMPIRE present, taunt EMPIRE; else ALL
            const hasFed = r.some(p => p.ship!.side === "FEDERATION");
            const hasEmp = r.some(p => p.ship!.side === "EMPIRE");
            if (hasFed && !hasEmp) return { kind: "SIDE", value: "FEDERATION" };
            if (hasEmp && !hasFed) return { kind: "SIDE", value: "EMPIRE" };
            if (r.length === 1) return { kind: "SHIP", value: r[0].ship!.name };
            return { kind: "ALL" };
        }
        case "SINGLE_SHIP_OR_SIDE_OR_ALL":
        default: {
            if (r.length === 1) return { kind: "SHIP", value: r[0].ship!.name };
            const sides = new Set(r.map(p => p.ship!.side));
            if (sides.size === 1) return { kind: "SIDE", value: [...sides][0] };
            return { kind: "ALL" };
        }
    }
}
import { chebyshev, bresenhamLine, findEmptyLocation, findObjectAtPosition } from "./coords.js";
import { Planet } from "./planet.js";
import { applyPhaserDamage } from "./phaser.js";
import { torpedoDamage } from "./torpedo.js";
import { Ship } from "./ship.js";
import { Star } from "./star.js";
import { Blackhole } from "./blackhole.js";
import { triggerNovaAt } from "./nova.js";
import { emitNovaTriggered } from "./api/events.js";
import type { GridCoord } from "./api/events.js";


// ----- constants (FORTRAN-aligned) -----
const KRANGE = 10;                  // search/notify/attack window (FORTRAN krange=10)
const TORP_SHOTS = 3;               // ROMTOR loop id=1..3
const PHA_PHIT = 0.4;               // FORTRAN 200 -> 0.4 (removed 10x integer trick)
const PHA_BASE_PAUSE_MS = 750;      // (slwest+1)*750 in FORTRAN; we scale by active players
const TORP_BASE_PAUSE_MS = 1000;    // (slwest+1)*1000 in FORTRAN

// ----- small helpers -----
const activePlayersPlusOne = () =>
    Math.max(1, players.filter(p => p.ship && p.ship.energy > 0).length + 1);


type ScoringAPI = {
    incrementShipsCommissioned?(side: string): void;
    /**
     * FORTRAN parity: decrement star-destruction reserve when a Romulan torp
     * successfully detonates a star into a nova. Original does: rsr(KNSDES) -= 500
     */
    decrementStarDestruction?(amount: number): void;
};

// ----- Romulan singleton state -----
export let romulan: Player | null = null;
let erom = 0;                 // FORTRAN erom (Romulan “energy” tracked separately)
let romcnt = 0;               // FORTRAN romcnt (spawn cadence counter)
let rppausUntil = 0;          // phaser pause timestamp (ms)
let rtpausUntil = 0;          // torpedo pause timestamp (ms)

// ----- spawn cadence like ROMDRV -----
export function maybeSpawnRomulan(): void {
    if (!settings.generated) return;
    if (romulan && romulan.ship) return;

    romcnt += 1;

    const numply = Math.max(1, players.filter(p => p.ship && p.ship.energy > 0).length);

    // slow start: wait until roughly half a sweep has gone by
    if (romcnt * 2 < numply) return;

    // spawn only when enough cycles have passed AND a random gate opens
    if (romcnt >= numply * 3 && iran(5) === 5) {
        spawnRomulan();
        erom = iran(200) + 200; // 201..400

        // notify nearby players (iwhat=11 semantics simplified)
        if (romulan?.ship) {
            const rv = romulan.ship.position.v;
            const rh = romulan.ship.position.h;
            for (const p of players) {
                if (!p.ship) continue;
                if (chebyshev(p.ship.position, { v: rv, h: rh }) <= KRANGE) {
                    addPendingMessage(p, `Sensors: a Romulan vessel has appeared near ${rv}-${rh}!`);
                }
            }
        }
        romcnt = 0;
    }
}

// explicit spawn with placement
export function spawnRomulan(): void {
    if (romulan && romulan.ship) return;

    const pl = new Player(new NullSocket());
    pl.settings.name = "ROMULAN";
    if (pl.ship) {
        pl.ship.name = "ROMULAN";
        pl.ship.side = "ROMULAN";
        pl.ship.romulanStatus = { isRomulan: true, isRevealed: false, cloaked: true };
        pl.ship.energy = 0;          // not used for durability (we use erom)
        pl.ship.damage = 0;
        pl.ship.shieldEnergy = 0;

        const pos = findEmptyLocation();
        if (pos) {
            pl.ship.position = pos;
            players.push(pl);

            // optional scoring hook (no `any`)
            (pointsManager as unknown as ScoringAPI).incrementShipsCommissioned?.("ROMULAN");

            romulan = pl;
        }
    }
}

// ----- main per-tick update (ROMDRV core) -----
export function updateRomulan(): void {
    if (!romulan?.ship) return;

    // occasional speech
    if (iran(10) === 1) romulanSpeaks();

    // find nearest ship/base in range
    const target = findClosestTargetInRange();
    if (!target) return;

    // choose weapon by cooldowns (FORTRAN style)
    const now = Date.now();
    const phaReady = now >= rppausUntil;
    const torpReady = now >= rtpausUntil;

    if (!phaReady && !torpReady) {
        romulanApproachTick(); // close the gap while waiting to fire
        return;
    }

    romcnt = 0; // reset cadence when firing

    if (phaReady && torpReady) {
        if (iran(2) === 1) fireRomulanTorpedoes(target);
        else fireRomulanPhasers(target);
    } else if (phaReady) {
        fireRomulanPhasers(target);
    } else {
        fireRomulanTorpedoes(target);
    }
}

// ----- target selection like ROMDRV: ships first, then bases, within KRANGE -----
type Target =
    | { kind: "ship"; player: Player; distance: number }
    | { kind: "base"; planet: Planet; distance: number };

function findClosestTargetInRange(): Target | null {
    if (!romulan?.ship) return null;
    const rpos = romulan.ship.position;

    let best: Target | null = null;

    // enemy ships (FED/EMP)
    for (const p of players) {
        if (!p.ship) continue;
        if (p === romulan) continue;
        if (p.ship.side !== "FEDERATION" && p.ship.side !== "EMPIRE") continue;
        const d = chebyshev(p.ship.position, rpos);
        if (d > KRANGE) continue;
        if (!best || d < best.distance) best = { kind: "ship", player: p, distance: d };
    }

    // enemy bases
    for (const side of ["FEDERATION", "EMPIRE"] as const) {
        const list = side === "FEDERATION" ? bases.federation : bases.empire;
        for (const base of list) {
            const d = chebyshev(base.position, rpos);
            if (d > KRANGE) continue;
            if (!best || d < best.distance) best = { kind: "base", planet: base, distance: d };
        }
    }

    return best;
}

// ----- phaser path (PHADAM parity via applyPhaserDamage) -----
function fireRomulanPhasers(target: Target): void {
    if (!romulan?.ship) return;

    // base “calls for help” when first hit at full shields
    if (target.kind === "base" && target.planet.energy === 1000) {
        for (const p of players) {
            if (!p.ship) continue;
            if (p.ship.side === target.planet.side) {
                addPendingMessage(
                    p,
                    `Starbase ${target.planet.position.v}-${target.planet.position.h} is under Romulan phaser fire!`
                );
            }
        }
    }

    // Snapshot pre-state for ships so we can message correctly post-resolution.
    let preShieldsUp = false;
    let preShieldEnergy = 0;
    if (target.kind === "ship" && target.player.ship) {
        preShieldsUp = Boolean(target.player.ship.shieldsUp);
        preShieldEnergy = target.player.ship.shieldEnergy;
    }

    // fire (let phaser core handle distance/absorption)
    const res = applyPhaserDamage(
        romulan,
        target.kind === "ship" ? target.player : target.planet,
        PHA_PHIT
    );

    // message victim (distinguish true absorption from no-effect/miss)
    if (target.kind === "ship") {
        const dealt = Math.round(res.hita || 0);
        const postShieldEnergy = target.player.ship ? target.player.ship.shieldEnergy : 0;
        const absorbed =
            dealt === 0 &&
            preShieldsUp === true &&
            postShieldEnergy < preShieldEnergy; // drain actually happened

        if (dealt > 0) {
            addPendingMessage(target.player, `Romulan phasers hit you for ${dealt}!`);
        } else if (absorbed) {
            addPendingMessage(target.player, `Your shields absorbed the Romulan phasers.`);
        } else {
            addPendingMessage(target.player, `Romulan phasers had no effect.`);
        }

        // Optional debug to trace odd reports from the field
        console.log(
            `[ROM-PH] dealt=${dealt} preUp=${preShieldsUp} preSE=${preShieldEnergy} postSE=${postShieldEnergy}`
        );
    }

    const pause = PHA_BASE_PAUSE_MS * activePlayersPlusOne();
    rppausUntil = Date.now() + pause;
}

// ----- torpedo path (ROMSTR + ROMTOR parity) -----
function fireRomulanTorpedoes(target: Target): void {
    if (!romulan?.ship) return;

    // initial aim point
    let aim =
        target.kind === "ship" ? (target.player.ship ? target.player.ship.position : null) : target.planet.position;
    if (!aim) return;

    // ROMSTR: retarget to adjacent star if present
    aim = retargetToAdjacentStar(aim) ?? aim;

    // ROMTOR: 3 shots with reacquire + star retarget each time
    for (let shot = 1; shot <= TORP_SHOTS; shot += 1) {
        if (!aim) break;

        // --- FORTRAN-ish line-of-flight with small scatter/misfire ---
        // Add a tiny jitter to emulate ROMTOR's deflection/misfire feel
        const jv = (ran() - 0.5) < 0 ? 0 : 1; // ~50% nudge one step on v
        const jh = (ran() - 0.5) < 0 ? 0 : 1; // ~50% nudge one step on h
        const jittered = { v: Math.max(1, Math.min(GRID_HEIGHT, aim.v + jv)), h: Math.max(1, Math.min(GRID_WIDTH, aim.h + jh)) };

        const rpos = romulan.ship.position;
        let hit: { v: number; h: number } | null = null;
        let obj: unknown = null;
        for (const p of bresenhamLine(rpos.v, rpos.h, jittered.v, jittered.h)) {
            if (p.v === rpos.v && p.h === rpos.h) continue;
            const found = findObjectAtPosition(p.v, p.h);
            if (found?.obj) {
                hit = p;
                obj = found.obj;
                break;
            }
        }
        // If nothing in the way, treat as a harmless boundary fizzle
        if (!obj) {
            // small miss message to help field-debug "random novas"
            addPendingMessage(romulan, `Romulan torpedo missed (no obstruction in flight).`);
        }

        if (obj instanceof Star) {
            // FORTRAN ROMTOR parity:
            // If a star is hit, 80% chance to cause a nova centered on that star,
            // crediting the Romulan as the attacker. (snova + notifications)
            if (iran(100) < 80) {
                // emit event first so loggers/clients see the cause
                const at: GridCoord = { v: hit?.v ?? aim.v, h: hit?.h ?? aim.h };
                emitNovaTriggered(at, romulan);
                // run nova resolution (damage, displacement, star removal, chain reactions)
                triggerNovaAt(romulan, at.v, at.h);
            } else {
                // no nova: still give a small flavor message like the original did sometimes
                const vv = hit?.v ?? aim.v, hh = hit?.h ?? aim.h;
                addPendingMessage(romulan, `Romulan torpedo fizzles near the star at ${vv}-${hh}.`);
            }
        } else if (obj instanceof Planet) {
            if (obj.isBase) {
                // FORTRAN ROMTOR parity:
                // If the base is at full shields (1000), broadcast a distress call
                if (obj.energy === 1000) {
                    for (const p of players) {
                        if (!p.ship) continue;
                        if (p.ship.side === obj.side) {
                            addPendingMessage(
                                p,
                                `Starbase ${obj.position.v}-${obj.position.h} is under Romulan torpedo fire!`
                            );
                        }
                    }
                }
                torpedoDamage(romulan, obj);
            } else {
                // 25% chance to decrement; if builds < 0 after hit, planet is destroyed (FORTRAN parity)
                if (iran(100) >= 75) {
                    obj.builds = obj.builds - 1; // allow negative

                    if (obj.builds < 0) {
                        // Credit the ROMULAN column with a destroyed planet (−100 to Romulan total).
                        pointsManager.addPlanetsDestroyed(1, /*by*/ undefined, "ROMULAN");
                        // Remove planet
                        const pidx = planets.indexOf(obj);
                        if (pidx !== -1) planets.splice(pidx, 1);

                        // Also remove from base list if present (safety)
                        const ownerBases = obj.side === "FEDERATION" ? bases.federation : bases.empire;
                        const bIdx = ownerBases.indexOf(obj);
                        if (bIdx !== -1) ownerBases.splice(bIdx, 1);
                        obj.isBase = false;

                        // Event/log
                        gameEvents.emit({
                            type: "planet_hit",
                            payload: {
                                planet: { name: obj.name, side: obj.side, position: { ...obj.position } },
                                damage: 0,
                                destroyed: true,
                                by: { faction: "ROMULAN" },
                            },
                        });
                        addPendingMessage(romulan, `Romulan torpedo destroyed the planet at ${aim!.v}-${aim!.h}.`);
                        checkEndGame();
                    } else {
                        addPendingMessage(romulan, `Planet at ${aim!.v}-${aim!.h} infrastructure disrupted (−1 builds).`);
                    }
                } else {
                    addPendingMessage(romulan, `Planet at ${aim!.v}-${aim!.h} unaffected by torpedo.`);
                }
            }
        } else if (obj instanceof Ship) {
            const targetPlayer =
                players.find(p => p.ship === obj) ||
                players.find(p => p.ship && p.ship.position.v === aim!.v && p.ship.position.h === aim!.h);
            if (targetPlayer) torpedoDamage(romulan, targetPlayer);
        } else if (obj instanceof Blackhole) {
            addPendingMessage(romulan, `Romulan torpedo lost in a black hole near ${aim.v}-${aim.h}.`);
        }

        // reacquire nearest, then ROMSTR star retarget again
        const nxt = findClosestTargetInRange();
        if (!nxt) break;

        let nextPos: { v: number; h: number } | null = null;
        if (nxt.kind === "ship" && nxt.player.ship) nextPos = nxt.player.ship.position;
        if (nxt.kind === "base") nextPos = nxt.planet.position;
        if (!nextPos) break;

        aim = retargetToAdjacentStar(nextPos) ?? nextPos;
        // --- per-shot cooldown accumulation like FORTRAN ---
        const perShotPause = TORP_BASE_PAUSE_MS * activePlayersPlusOne();
        rtpausUntil = Math.max(rtpausUntil, Date.now()) + perShotPause;
    }
    // (No extra lump-sum pause; already accumulated per shot)
}

// ROMSTR: if a star is adjacent to aim, retarget to it
function retargetToAdjacentStar(pos: { v: number; h: number }): { v: number; h: number } | null {
    const vf = Math.max(1, pos.v - 1);
    const vl = Math.min(GRID_HEIGHT, pos.v + 1);
    const hf = Math.max(1, pos.h - 1);
    const hl = Math.min(GRID_WIDTH, pos.h + 1);

    for (let v = vf; v <= vl; v += 1) {
        for (let h = hf; h <= hl; h += 1) {
            if (stars.some(s => s.position.v === v && s.position.h === h)) return { v, h };
        }
    }
    return null;
}

// ----- movement helper (safe approach) -----
function moveToward(targetPos: { v: number; h: number }): void {
    if (!romulan?.ship) return;
    const rpos = romulan.ship.position;

    const dv = targetPos.v - rpos.v;
    const dh = targetPos.h - rpos.h;
    const dist = Math.max(Math.abs(dv), Math.abs(dh));

    // up to 4 steps, but don’t enter the target tile
    const steps = Math.max(1, Math.min(4, dist));
    const sv = Math.sign(dv);
    const sh = Math.sign(dh);

    let nv = rpos.v + sv * Math.max(0, steps - 1);
    let nh = rpos.h + sh * Math.max(0, steps - 1);

    // clamp to bounds
    nv = Math.max(1, Math.min(GRID_HEIGHT, nv));
    nh = Math.max(1, Math.min(GRID_WIDTH, nh));

    // simple path clearance
    const path = [...bresenhamLine(rpos.v, rpos.h, nv, nh)];
    path.shift(); // skip start
    let blocked = false;
    for (const p of path) {
        if (findObjectAtPosition(p.v, p.h)) {
            blocked = true;
            break;
        }
    }
    if (blocked) {
        nv = rpos.v + sv * Math.max(0, steps - 2);
        nh = rpos.h + sh * Math.max(0, steps - 2);
    }

    if (!findObjectAtPosition(nv, nh)) {
        romulan.ship.position = { v: nv, h: nh };
    }
}

// optional: call between attacks if you want the Romulan to “close distance”
export function romulanApproachTick(): void {
    const target = findClosestTargetInRange();
    if (!target) return;
    const tpos =
        target.kind === "ship" && target.player.ship
            ? target.player.ship.position
            : target.kind === "base"
                ? target.planet.position
                : null;
    if (tpos) moveToward(tpos);
}

// ----- “Romulan gets hit by …” (PHAROM/TOROM) -----
// id = distance in original (used in divisor)
export function applyRomulanPhaserHitFrom(
    phit: number,
    id: number
): { ihita: number; killed: boolean } {
    if (!romulan) return { ihita: 0, killed: false };

    // ihita = ((100 + iran(100)) * phit) / (10 * id)
    const denom = 10 * Math.max(1, id);
    const ihita = ((100 + iran(100)) * phit) / denom;

    // erom = erom - (ihita / 10)
    erom -= ihita / 10;

    if (erom <= 0) {
        destroyRomulan();
        return { ihita, killed: true };
    }
    return { ihita, killed: false };
}

export function applyRomulanTorpedoHitFrom(): { ihita: number; killed: boolean } {
    if (!romulan) return { ihita: 0, killed: false };

    // ihita = min(iran(4000), 2000)
    const ihita = Math.min(iran(4000), 2000);

    // erom = erom - (ihita / 10)
    erom -= ihita / 10;

    if (erom <= 0) {
        destroyRomulan();
        return { ihita, killed: true };
    }
    return { ihita, killed: false };
}

// ----- DEADRO parity -----
export function destroyRomulan(): void {
    if (!romulan?.ship) {
        romulan = null;
        return;
    }

    romulan.ship.romulanStatus.cloaked = true;

    const idx = players.indexOf(romulan);
    if (idx !== -1) players.splice(idx, 1);

    romulan = null;
    erom = 0;
    rppausUntil = 0;
    rtpausUntil = 0;
}

// ----- flavor (speech) -----
function romulanSpeaks(): void {
    if (!romulan?.ship) return;
    const rh = romulan.ship.position.h;
    const rv = romulan.ship.position.v;
    const recipients = players.filter(
        p => p !== romulan && p.ship && chebyshev(p.ship.position, { v: rv, h: rh }) <= KRANGE
    );
    if (recipients.length === 0) return;
    const audience = pickTellAudience(recipients);
    const single = audience.kind === "SHIP"; // controls singular/plural phrasing
    const msg = generateRomulanMessage(single);
    if (audience.kind === "SHIP") {
        queueCommands(romulan, `TELL ${audience.value}; ${msg}`);
    } else if (audience.kind === "SIDE") {
        queueCommands(romulan, `TELL ${audience.value}; ${msg}`);
    } else {
        queueCommands(romulan, `TELL ALL; ${msg}`);
    }
}

function generateRomulanMessage(single: boolean): string {
    const lead = single
        ? [
            "You have aroused my wrath, ",
            "You will witness my vengeance, ",
            "May you be attacked by a slime-devil, ",
            "I will reduce you to quarks, ",
        ]
        : ["Death to ", "Destruction to ", "I will crush ", "Prepare to die, "];

    const adjectives = ["mindless ", "worthless ", "ignorant ", "idiotic ", "stupid "];
    const species = ["sub-Romulan ", "human ", "klingon "];
    const objects = ["mutant", "cretin", "toad", "worm", "parasite"];

    const l = lead[iran(lead.length)];
    const a = adjectives[iran(adjectives.length)];
    const s = single ? "" : species[iran(species.length)];
    const o = objects[iran(objects.length)];

    return `${l}${a}${s}${o}${single ? "!" : "s!"}`;
}




######## scan.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
import {
    GRID_HEIGHT, GRID_WIDTH,
    SYMBOL_ROMULAN, SYMBOL_STAR, SYMBOL_BLACK_HOLE, SYMBOL_EMPTY,
    SYMBOL_WARNING, SYMBOL_BASE_FED, SYMBOL_BASE_EMP,
    SYMBOL_PLANET_NEU, SYMBOL_PLANET_FED, SYMBOL_PLANET_EMP, SYMBOL_PLANET_UNKNOWN,
    BASE_WARNING_DISTANCE, PLANET_WARNING_DISTANCE, BLACKHOLE_WARNING_DISTANCE,
    DEFAULT_SCAN_RANGE,
} from './settings.js';
import { addPlanetToMemory } from './memory.js';
import { Command } from './command.js';
import { Planet } from './planet.js';
import { planets, players, stars, blackholes } from './game.js';
import { matchesPattern } from './util/util.js';

export function scanCommand(player: Player, command: Command): void {
    scan(player, command, DEFAULT_SCAN_RANGE);
}

export function scan(player: Player, command: Command, range: number = DEFAULT_SCAN_RANGE): void {
    const args = command.args.map(arg => arg.toUpperCase());
    if (!player.ship) return;

    const { v, h } = player.ship.position;

    // ────── Parse arguments ──────
    let vDir = 0, hDir = 0;
    let vertical = range;
    let horizontal = range;
    let cornerMode = false;

    const nums = args.map(Number).filter(n => !isNaN(n));
    if (nums.length === 1) {
        vertical = horizontal = Math.min(nums[0], range);
    } else if (nums.length >= 2) {
        vertical = Math.min(nums[0], range);
        horizontal = Math.min(nums[1], range);
    }

    for (const arg of args) {
        if (!isNaN(Number(arg))) continue;
        if (matchesPattern(arg, "Up")) vDir = 1;  //matchesPattern
        else if (matchesPattern(arg, "Down")) vDir = -1;
        else if (matchesPattern(arg, "Right")) hDir = 1;
        else if (matchesPattern(arg, "Left")) hDir = -1;
        else if (matchesPattern(arg, "Center")) cornerMode = true;
    }

    const warningFlag = args.some(arg => matchesPattern(arg, "Warning"));
    const warningSectors = warningFlag ? getWarningSectors(player) : new Set<string>();

    // ────── Compute scan bounds ──────
    let vMin: number, vMax: number, hMin: number, hMax: number;

    if (cornerMode && nums.length >= 2) {
        const dv = Math.max(-range, Math.min(range, nums[0]));
        const dh = Math.max(-range, Math.min(range, nums[1]));

        vMin = Math.min(v, v + dv);
        vMax = Math.max(v, v + dv);
        hMin = Math.min(h, h + dh);
        hMax = Math.max(h, h + dh);
    } else {
        if (hDir < 0) {
            hMin = h - horizontal;
            hMax = h;
        } else if (hDir > 0) {
            hMin = h;
            hMax = h + horizontal;
        } else {
            hMin = h - horizontal;
            hMax = h + horizontal;
        }

        if (vDir < 0) {
            vMin = v - vertical;
            vMax = v;
        } else if (vDir > 0) {
            vMin = v;
            vMax = v + vertical;
        } else {
            vMin = v - vertical;
            vMax = v + vertical;
        }
    }

    hMin = Math.max(1, hMin);
    hMax = Math.min(GRID_WIDTH, hMax);
    vMin = Math.max(1, vMin);
    vMax = Math.min(GRID_HEIGHT, vMax);

    // ────── Build spatial maps for fast lookup ──────
    const coordKey = (v: number, h: number) => `${v},${h}`;

    const shipMap = new Map<string, Player>();
    for (const p of players) {
        if (p.ship) {
            shipMap.set(coordKey(p.ship.position.v, p.ship.position.h), p);
        }
    }

    const planetMap = new Map<string, Planet>();
    for (const planet of planets) {
        planetMap.set(coordKey(planet.position.v, planet.position.h), planet);
        addPlanetToMemory(player, planet);
    }

    const blackholeSet = new Set<string>(blackholes.map(bh => coordKey(bh.position.v, bh.position.h)));
    const starSet = new Set<string>(stars.map(s => coordKey(s.position.v, s.position.h)));

    // ────── Header ──────
    const header = [];
    for (let col = hMin; col <= hMax; col += 2) {
        header.push(String(col).padStart(2, " "));
    }
    sendMessageToClient(player, `   ${header.join("  ")}`);

    // ────── Grid ──────
    for (let rowV = vMax; rowV >= vMin; rowV--) {
        let line = `${String(rowV).padStart(2, " ")} `;

        for (let colH = hMin; colH <= hMax; colH++) {
            const key = coordKey(rowV, colH);
            let symbol = SYMBOL_EMPTY;

            const player = shipMap.get(key);
            const planet = planetMap.get(key);

            if (player) {    // why?  && !ship.ship.romulanStatus.cloaked) {
                if (player.ship && player.ship.name) {
                    if (player.ship.romulanStatus.isRomulan && !player.ship.romulanStatus.cloaked) {
                        symbol = SYMBOL_ROMULAN;
                    } else {
                        symbol = player.ship.name[0]
                    }
                } else {
                    symbol = `?`
                }
            } else if (planet) {
                if (planet.isBase) {
                    symbol = planet.side === "FEDERATION" ? SYMBOL_BASE_FED : SYMBOL_BASE_EMP;
                } else {
                    const side = planet.side;
                    symbol = side === "NEUTRAL" ? SYMBOL_PLANET_NEU :
                        side === "FEDERATION" ? SYMBOL_PLANET_FED :
                            side === "EMPIRE" ? SYMBOL_PLANET_EMP :
                                SYMBOL_PLANET_UNKNOWN;
                }
            } else if (starSet.has(key)) {
                symbol = SYMBOL_STAR;
            } else if (blackholeSet.has(key)) {
                symbol = SYMBOL_BLACK_HOLE;
            } else if (warningSectors.has(key)) {
                symbol = SYMBOL_WARNING;
            }

            if (symbol.length === 1) symbol = ` ${symbol}`;
            line += symbol;
        }

        line += ` ${String(rowV).padStart(2, " ")}`;
        sendMessageToClient(player, line);
    }

    // ────── Footer ──────
    sendMessageToClient(player, `   ${header.join("  ")}`);
}


// Identify sectors that should show warnings
function getWarningSectors(player: Player): Set<string> {
    const warningSet = new Set<string>();
    if (!player.ship) return warningSet;

    const side = player.ship.side;  // SHOULDN'T HAPPEN

    let warningDistance = PLANET_WARNING_DISTANCE;
    for (const planet of planets) {
        if (planet.isBase) {
            warningDistance = BASE_WARNING_DISTANCE;
        } else {
            warningDistance = PLANET_WARNING_DISTANCE;
        }
        if (planet.side !== side || planet.side === "NEUTRAL") {   // neutral is via Harris info
            for (let dh = -warningDistance; dh <= warningDistance; dh++) {
                for (let dv = -warningDistance; dv <= warningDistance; dv++) {
                    if (dh === 0 && dv === 0) continue;
                    warningSet.add(`${planet.position.v + dv},${planet.position.h + dh}`);
                }
            }
        }
    }

    for (const obj of [...blackholes]) {  // , ...stars
        for (let dh = -BLACKHOLE_WARNING_DISTANCE; dh <= BLACKHOLE_WARNING_DISTANCE; dh++) {
            for (let dv = -BLACKHOLE_WARNING_DISTANCE; dv <= BLACKHOLE_WARNING_DISTANCE; dv++) {
                if (dh === 0 && dv === 0) continue;
                warningSet.add(`${obj.position.v + dv},${obj.position.h + dh}`);
            }
        }
    }

    return warningSet;
}

######## server.ts
// server.ts (excerpt) — run your telnet server as usual, then:
import { startApiServer } from "./api/server.js";
import type { GameStateProvider } from "./api/provider.js";

import { planets, stars, blackholes, bases, players } from "./game.js";
import {
  toSummaryDTO,
  toPlayerDTO,
  toPlanetDTO,
  toStarDTO,
  toBlackholeDTO,
  toBaseDTO,
} from "./api/dto.js";
import type { Ship } from "./ship.js";
import { emitShipLeft } from "./api/events.js";

// Build the read-only provider against your live state
const provider: GameStateProvider = {
  getSummary: () =>
    toSummaryDTO({
      players,
      planets,
      stars,
      blackholes,
      federationBases: bases.federation,
      empireBases: bases.empire,
    }),

  listPlayers: () =>
    players
      .filter((p): p is Player & { ship: Ship } => Boolean(p.ship))
      .map(toPlayerDTO),

  listPlanets: () => planets.map(toPlanetDTO),
  listStars: () => stars.map(toStarDTO),
  listBlackholes: () => blackholes.map(toBlackholeDTO),
  listBases: () => [...bases.federation, ...bases.empire].map(toBaseDTO),
};

// Start the API if desired (env or explicit)
if (process.env.API_PORT) {
  startApiServer(provider);
}



import * as net from 'net';
import { config } from 'dotenv';
import { Player } from './player.js';
import { limbo } from './game.js';
import { queueCommands } from './command.js';
import { MAX_PLAYERS } from './settings.js';
import { swapPlayerForBackhole } from './gripe.js';
import { parseAndExecutePGCommand } from './pregame.js';
import { removePlayerFromGame } from './game.js';

config();

const IAC = 255;
//const IP = 244;
const SE = 240;
const DO = 253;
const DONT = 254;
const WILL = 251;
const WONT = 252;
const SB = 250;

const ECHO = 1;
const SUPPRESS_GO_AHEAD = 3;
const LINEMODE = 34;

export const clients: Map<net.Socket, Player> = new Map();

const server = net.createServer((socket) => {
  if (players.length >= MAX_PLAYERS) {
    socket.write("Server is full.\r\n");
    socket.end();
    return;
  }

  const player = new Player(socket);
  clients.set(socket, player);
  //players.push(player);

  // Negotiate raw mode: suppress line mode and client-side echo
  socket.write(Buffer.from([IAC, WILL, SUPPRESS_GO_AHEAD]));
  socket.write(Buffer.from([IAC, WILL, ECHO]));
  socket.write(Buffer.from([IAC, WONT, LINEMODE]));

  // Welcome and initial SUM command
  //socket.write(`[DECWARJS Version ${gameSettings.version}, ${gameSettings.date}]\r\n`);
  socket.write(`Now entering DECWARJS Pre-game; type\r\nACtivate to enter game.\r\n`);
  socket.write(player.getPrompt());
  //socket.write('\r\n' + player.getPrompt() + ' ');
  //parseAndExecuteCommand(player, 'SUM');

  let skipLF = false;

  socket.on('data', (chunk: Buffer) => {
    for (let i = 0; i < chunk.length; i++) {
      const byte = chunk[i];

      // Telnet IAC sequences — silently skip
      if (byte === IAC) {
        const command = chunk[i + 1];

        if (command === IAC) {
          // Literal 255
          i++; // skip extra 255
          continue;
        }

        if (
          command === DO || command === DONT ||
          command === WILL || command === WONT
        ) {
          // IAC DO/WILL/WONT/DONT option
          i += 2; // skip IAC, command, and option
          continue;
        }

        if (command === SB) {
          // IAC SB ... IAC SE
          i += 2; // skip IAC and SB and option
          // Skip until IAC SE
          while (i < chunk.length) {
            if (chunk[i] === IAC && chunk[i + 1] === SE) {
              i += 2;
              break;
            }
            i++;
          }
          continue;
        }

        // All other IAC commands (like IP, NOP, SE, etc.)
        i += 1; // skip IAC and command
        continue;
      }

      // Ctrl-C (ASCII 3)
      if (byte === 3) {
        handleControlC(player, socket);
        continue;
      }

      // Ctrl-U (ASCII 21) — clear entire input line
      if (byte === 21) {
        if (!player.ready) continue;
        const erase = '\b \b'.repeat(player.inputBuffer.length);
        socket.write(erase);
        player.inputBuffer = '';
        continue;
      }

      // Backspace/Delete (ASCII 8 or 127)
      if (byte === 8 || byte === 127) {
        if (player.inputBuffer.length > 0) {
          player.inputBuffer = player.inputBuffer.slice(0, -1);
          socket.write('\b \b');
        }
        continue;
      }

      // ESC key (ASCII 27) — recall next command from history
      if (byte === 27 && (chunk[i + 1] === undefined || chunk[i + 1] < 32)) {
        if (!player.ready) continue;
        const erase = '\b \b'.repeat(player.inputBuffer.length);
        socket.write(erase);
        const command = player.getNextHistory() || '';
        player.inputBuffer = command;
        socket.write(command);
        continue;
      }

      // Enter (CR or LF)
      if ((byte === 13 || (byte === 10 && !skipLF)) && !player.multiLine || (player.multiLine && byte === 0x1A)) {
        if (player.inputBuffer === '') {    // handle empty line by user
          socket.write('\r\n\r\n' + player.getPrompt());
          continue;
        }
        player.lastActivity = Date.now();
        if (byte === 13) skipLF = true;
        const line = player.inputBuffer.trim();
        player.inputBuffer = '';
        socket.write('\r\n\r\n');

        if (player.isOnHold) {
          socket.write(player.getPrompt());
          continue;
        }

        if (player.currentPrompt) {
          const cb = player.callBack;
          player.callBack = undefined;
          player.currentPrompt = undefined;
          cb?.(player, line);
        } else if (line) {
          if (players.includes(player)) { // why?
            player.addToHistory(line);
            queueCommands(player, line);
            //parseAndExecuteCommand(player, line);
          } else {
            parseAndExecutePGCommand(player, line);
          }
        }
        continue;
      }

      if (player.multiLine && (byte === 13 || byte === 10)) {
        player.inputBuffer += '\n';
        socket.write('\r\n');
        continue;
      }

      // Skip LF if part of CRLF
      if (byte === 10 && skipLF) {
        skipLF = false;
        continue;
      }

      // Printable characters (ASCII 32–126)
      if (byte >= 32 && byte <= 126) {
        if (!player.ready) {
          player.ready = true;
          //socket.write('\r\n' + player.getPrompt() + ' ');
        }

        const char = String.fromCharCode(byte);
        player.inputBuffer += char;
        socket.write(char);
      }
    }
  });


  socket.on('close', () => {
    emitShipLeft(player, "idle"); // or "logout"/"timeout"/"idle"
    clients.delete(socket);
  });

  socket.on('error', (err) => {
    emitShipLeft(player, "timeout"); // or "logout"/"timeout"/"idle"

    console.error('Socket error:', err.message);
    clients.delete(socket);
  });
});

function handleControlC(player: Player, socket: net.Socket): void {
  let atCommandPrompt: boolean = true;

  if (player.multiLine) {
    socket.write(`^C Use ^Z to end.\r\n`);
    return;
  }

  if (player.currentCommandTimer || player.commandQueue.length > 0) {
    atCommandPrompt = false;
  }


  player.inputBuffer = "";

  // 2. Cancel the current timer if any
  if (player.currentCommandTimer) {
    clearTimeout(player.currentCommandTimer);
    player.currentCommandTimer = null;
  }

  // 3. Clear the queued commands
  player.commandQueue = [];

  // 4. Reset processing flag (in case a command never called `done`)
  player.processingCommand = false;
  player.multiLine = false;
  player.currentPrompt = undefined;
  player.isOnHold = false;


  if (limbo.includes(player)) {
    swapPlayerForBackhole(player);
  }

  // 5. Notify user + reprint prompt
  if (atCommandPrompt) {
    if (player.ship && player.ship.condition == "RED") {
      socket.write("Use QUIT to terminate while under RED alert.\r\n");
      socket.write(`${player.getPrompt()} `);
    } else {
      removePlayerFromGame(player);
      socket.write(`^C\r\n${player.getPrompt()} `);
    }
  } else {
    if (player.ready) {
      socket.write('\r\x1b[K'); // Clear line
      socket.write('\x07\x07\x07\x07'); // Optional bells
      socket.write('Commands cancelled.\r\n');
      socket.write(`${player.getPrompt()} `);
    }
  }
}

const PORT = 23;
server.listen(PORT, () => console.log(`Telnet server running on port ${PORT}`));


// function isSocketActive(socket: net.Socket): boolean {
//     return !socket.destroyed && socket.writable;
// }

// Optional: try a no-op write to check silently
export function isSocketLive(socket: net.Socket): boolean {
  return (!socket.destroyed && socket.writable && socket.readable);
}
######## set.ts
import { ScanSetting, PromptSetting, ICDEF, OCDEF, OutputSetting } from './settings.js';
import { Player } from './player.js';
import { Command } from './command.js';
import { sendMessageToClient } from './communication.js';
//import { setPlayerSettings } from './db/userRecords.js';

// helper to match a user’s prefix against allowed options
function matchValue(input: string, options: readonly string[]): string | null {
    const upperInput = input.toUpperCase();
    const candidates = options.filter(opt => opt.startsWith(upperInput));
    return candidates.length === 1 ? candidates[0] : null;
}

export function setCommand(player: Player, command: Command): void {
    if (command.args.length < 2) {
        sendMessageToClient(player, "Usage: SET <setting> <value>");
        return;
    }

    // Allow unambiguous prefixes for setting names
    const settingArg = command.args[0];
    const selectedSetting = matchValue(settingArg, [
        "SCAN", "PROMPT", "OCDEF", "ICDEF", "NAME", "OUTPUT"
    ]);
    if (!selectedSetting) {
        sendMessageToClient(player, `Unknown setting: ${settingArg}`);
        return;
    }

    // Value argument
    const valueArg = command.args[1];
    const valueUpper = valueArg.toUpperCase();

    switch (selectedSetting) {
        case "SCAN": {
            const chosenScan = matchValue(valueUpper, ["LONG", "SHORT"]);
            if (chosenScan) {
                player.settings.scan = chosenScan as ScanSetting;
                sendMessageToClient(player, `SCAN set to ${chosenScan}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid SCAN value: ${valueArg}. Valid: Long, Short.`
                );
            }
            break;
        }

        case "PROMPT": {
            const chosenPrompt = matchValue(valueUpper, ["NORMAL", "INFORMATIVE"]);
            if (chosenPrompt) {
                player.settings.prompt = chosenPrompt as PromptSetting;
                sendMessageToClient(player, `PROMPT set to ${chosenPrompt}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid PROMPT value: ${valueArg}. Valid: Normal, Informative.`
                );
            }
            break;
        }

        case "OCDEF": {
            const chosenOC = matchValue(valueUpper, ["ABSOLUTE", "RELATIVE", "BOTH"]);
            if (chosenOC) {
                player.settings.ocdef = chosenOC as OCDEF;
                sendMessageToClient(
                    player,
                    `OCDEF set to ${chosenOC}.`
                );
            } else {
                sendMessageToClient(
                    player,
                    `Invalid OCDEF value: ${valueArg}. Valid: Absolute, Relative, Both).`
                );
            }
            break;
        }

        case "ICDEF": {
            const chosenIC = matchValue(valueUpper, ["ABSOLUTE", "RELATIVE"]);
            if (chosenIC) {
                player.settings.icdef = chosenIC as ICDEF;
                sendMessageToClient(
                    player,
                    `ICDEF set to ${chosenIC}.`
                );
            } else {
                sendMessageToClient(
                    player,
                    `Invalid ICDEF value: ${valueArg}. Valid: Absolute, Relative.`
                );
            }
            break;
        }

        case "NAME": {
            const newName = command.args.slice(1).join(" ");
            player.settings.name = newName;
            sendMessageToClient(
                player,
                `NAME set to ${newName}.`
            );
            break;
        }

        case "OUTPUT": {
            const chosenOutput = matchValue(valueUpper, ["LONG", "MEDIUM", "SHORT"]);
            if (chosenOutput) {
                player.settings.output = chosenOutput as OutputSetting;
                sendMessageToClient(player, `OUTPUT set to ${chosenOutput}.`);
            } else {
                sendMessageToClient(
                    player,
                    `Invalid OUTPUT value: ${valueArg}. Valid: Long, Medium, Short.`
                );
            }
            break;
        }

        default:
            // Shouldn't be reached
            sendMessageToClient(player, `Unknown setting: ${selectedSetting}`);
    }
    //setPlayerSettings(player); // TODO: implement
}

######## settings.ts
import { VERSION } from "./version.js";

export const GRID_WIDTH = 75;
export const GRID_HEIGHT = 75;
export const MAX_PLAYERS = 18;
export const NUMBER_OF_PLANETS = 60;
export const MAX_NUMBER_OF_PLAYERS = 18;
export const DEFAULT_BASE_ENERGY = 1000;
export const MAX_BUILDS_PER_PLANET = 5;
export const MAX_SHIP_ENERGY = 5000;
export const MAX_SHIELD_ENERGY = 2500;
export const MAX_TORPEDOES = 10;
export const BASE_WARNING_DISTANCE = 4;
export const PLANET_WARNING_DISTANCE = 2;
export const BLACKHOLE_WARNING_DISTANCE = 1;
export const DEFAULT_SCAN_RANGE = 10;
export const DEFAULT_SRS_RANGE = 7;
export const INITIAL_BASE_STRENGTH = 1000;
export const CAPTURE_DELAY_MIN_MS = 5000;
export const WARP_DELAY_MIN_MS = 2000;
export const WARP_DELAY_RANGE = 2000;
export const DOCK_DELAY_RANGE = 2000;
export const DOCK_DELAY_MIN_MS = 2000;
export const BUILD_DELAY_MIN_MS = 2000;
export const BUILD_DELAY_RANGE = 2000;
export const MAX_BASES_PER_TEAM = 10;
export const ENERGY_REPAIR_COST = 500;
export const SHIELD_REPAIR_COST = 300;
export const SHIELD_REPAIR_AMOUNT = 500;
export const ENERGY_REPAIR_AMOUNT = 1000;
export const DESTRUCTION_DAMAGE_THRESHOLD = 2500;
export const PHASER_COOLDOWN = 1000;
export const IMPULSE_DELAY_MS = 2000;
export const IMPULSE_DELAY_RANGE = 2000;
export const MAX_TORPEDO_RANGE = 10;
export const STARBASE_PHASER_RANGE = 4;
export const INACTIVITY_TIMEOUT = 60 * 1000 * 24 * 365;
export const LS_CRITICAL_DAMAGE = 300;


export type ScanSetting = "LONG" | "SHORT";
export type PromptSetting = "NORMAL" | "INFORMATIVE";
export type CoordMode = "ABSOLUTE" | "RELATIVE" | "COMPUTED";
export type ICDEF = "ABSOLUTE" | "RELATIVE";
export type OCDEF = "ABSOLUTE" | "RELATIVE" | "BOTH";
export type Condition = "RED" | "YELLOW" | "GREEN";
export type OutputSetting = "SHORT" | "MEDIUM" | "LONG";

export const SYMBOL_ROMULAN = "R";
export const SYMBOL_STAR = "*";
export const SYMBOL_BLACK_HOLE = " ";
export const SYMBOL_EMPTY = ".";
export const SYMBOL_WARNING = "!";
export const SYMBOL_BASE_FED = "<>";
export const SYMBOL_BASE_EMP = ")(";
export const SYMBOL_PLANET_NEU = "@";
export const SYMBOL_PLANET_FED = "@F";
export const SYMBOL_PLANET_EMP = "@E";
export const SYMBOL_PLANET_UNKNOWN = "@?";


export type Side = "NEUTRAL" | "FEDERATION" | "EMPIRE" | "ROMULAN";

export const FEDERATION_SHIPS: string[] = [
    "EXCALIBUR"
    , "FARRAGUT", "INTREPID", "LEXINGTON", "NIMITZ",
    "SAVANNAH", "TRENTON", "VULCAN", "YORKTOWN"
];

export const EMPIRE_SHIPS: string[] = [
    "BUZZARD",
    "COBRA", "DEMON", "GOBLIN", "HAWK",
    "JACKAL", "MANTA", "PANTHER", "WOLF"
];

export const SHIPNAMES: string[] = [...FEDERATION_SHIPS, ...EMPIRE_SHIPS];

export const settings = {
    stardate: 0,
    generated: false,
    winner: null as string | null,
    version: "0.3" + VERSION,
    date: "2025-06-08",
    allowRomulans: true,
    allowBlackHoles: true,
    outputDetail: "FULL",
    promptStyle: "DEFAULT",
    sensorScanDetail: "DEFAULT",
    coordInputDefault: "DEFAULT",
    coordOutputDefault: "DEFAULT",
    ttyType: "DEFAULT",
    allowGripe: true,
    gameNumber: 1,
    timeConsumingMoves: 0,
    tournamentSeed: "0",
    blackholes: true,
    romulans: true,
    teamTurns: {
        federation: 0,
        empire: 0,
        romulan: 0
    },
    dotime: 0
};
######## shield.ts
import { Command } from "./command.js";
import { Player } from "./player.js";
import { sendMessageToClient } from "./communication.js";
import { matchesPattern } from "./util/util.js";
import { emitShieldsToggled } from "./api/events.js";

export function shieldCommand(player: Player, command: Command): void {
    const action = command.args[0]?.toUpperCase();

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use SHIELD.");
        return;
    }

    if (!player.ship.isDeviceOperational("shield")) return;

    if (!action) {
        sendMessageToClient(player, "Usage: SHIELD [UP|DOWN|TRANSFER amount]");
        return;
    }


    if (matchesPattern(action, "Up")) {
        if (!player.ship) return;
        const wasUp = player.ship.shieldsUp;
        const before = player.ship.shieldEnergy;

        player.ship.raiseShields();

        if (!wasUp && player.ship.shieldsUp) {
            emitShieldsToggled(player, true, { before, after: player.ship.shieldEnergy });
        }
    } else if (matchesPattern(action, "Down")) {
        if (!player.ship) return;
        const wasUp = player.ship.shieldsUp;
        const before = player.ship.shieldEnergy;

        player.ship.lowerShields();

        if (wasUp && !player.ship.shieldsUp) {
            emitShieldsToggled(player, false, { before, after: player.ship.shieldEnergy });
        }
    } else if (matchesPattern(action, "Transfer")) {
        const energyAmount = command.args[1];

        if (!energyAmount || !/^-?\d+$/.test(energyAmount)) {
            sendMessageToClient(player, "Bad energy amount.");
            return;
        }

        const amount = parseInt(energyAmount, 10);
        if (amount > 0) {
            player.ship?.transferToShields(amount);
        } else {
            player.ship?.transferFromShields(-amount);
        }
    } else {
        sendMessageToClient(player, "Unknown SHIELD command. Try UP, DOWN, or TRANSFER.");
    }
}


######## ship.ts
import { addPendingMessage, sendMessageToClient, sendOutputMessage } from './communication.js';
import { isInBounds, Position, findEmptyLocation, chebyshev, findObjectAtPosition, ocdefCoords, isAdjacent } from './coords.js';
import { SHIPNAMES, Condition, MAX_TORPEDOES, MAX_SHIP_ENERGY, MAX_SHIELD_ENERGY } from './settings.js';
import { Player } from './player.js';
import { players, planets } from './game.js';
import { Planet } from './planet.js';
import { bases } from './game.js';
import { Side } from './settings.js';
import { ran, iran } from './util/random.js';


type DockableTarget = { position: { v: number; h: number } }; // minimal shape

function hasDockTarget(s: Ship): s is Ship & { dockTarget?: DockableTarget | null } {
    // This keeps it structural: only cares that the property exists
    return "dockTarget" in (s as object);
}

type Cooldowns = {
    phasersAvailableAt: [number, number]; // [bank1, bank2]
};

export type DeviceName =
    | "warp"
    | "impulse"
    | "torpedo"
    | "phaser"
    | "shield"
    | "computer"
    | "radio"
    | "tractor"
    | "lifeSupport";

export interface DeviceStatus {
    [deviceName: string]: number; // damage value
}

export class Ship {
    /** Internal: prevents awarding kill credit more than once per hull. */
    public __killCredited: boolean = false;
    public player: Player;
    public position: Position;
    public energy: number;
    public shieldsUp: boolean;
    public shieldEnergy: number;
    public name: string;
    public isDestroyed: boolean;
    public side: Side;
    public docked: boolean;
    public dockPlanet: Planet | null;
    public tractorPartner: Ship | null;
    public romulanStatus: {
        isRomulan: boolean;
        isRevealed: boolean;
        cloaked: boolean;
    };
    public torpedoes: number;
    public devices: {
        warp: number;
        impulse: number;
        torpedo: number;
        phaser: number;
        shield: number;
        computer: number;
        radio: number;
        tractor: number;
        lifeSupport: number;
    }
    lifeSupportFailureTimer: number | null = null;
    public condition: Condition;
    public damage: number;
    public cooldowns: Cooldowns;

    constructor(player: Player) {
        this.player = player;
        this.position = findEmptyLocation() || { v: 1, h: 1 };
        this.energy = MAX_SHIP_ENERGY;
        this.shieldsUp = true;
        this.shieldEnergy = MAX_SHIELD_ENERGY;
        this.docked = false;
        this.dockPlanet = null;
        this.name = "Unknown";
        this.isDestroyed = false;
        this.side = "NEUTRAL";
        this.tractorPartner = null;
        this.romulanStatus = {
            isRomulan: false,
            isRevealed: false,
            cloaked: false
        };
        this.torpedoes = MAX_TORPEDOES;
        this.devices = {
            warp: 0,
            impulse: 0,
            torpedo: 0,
            phaser: 0,
            shield: 0,
            computer: 0,
            radio: 0,
            tractor: 0,
            lifeSupport: 0
        };
        this.lifeSupportFailureTimer = null;
        this.condition = "GREEN";
        this.damage = 0;
        this.cooldowns = { phasersAvailableAt: [0, 0] };
    }

    raiseShields(): void {   // TODO factor in shield device damange?
        if (!this.shieldsUp && this.energy >= 100) {
            this.energy -= 100;
            this.shieldsUp = true;
            if (this.tractorPartner) {
                if (this.tractorPartner.tractorPartner) {
                    this.tractorPartner.tractorPartner = null;
                    addPendingMessage(this.tractorPartner.player, `Tractor beam was broken, ${this.name} raised shields.`);
                }
                this.tractorPartner = null;
                sendMessageToClient(this.player, `Tractor beam broken, Captain.`);
            }
            sendOutputMessage(this.player, {
                SHORT: "SH > UP",
                MEDIUM: "Shields raised.",
                LONG: "Defensive shields have been raised. Energy expenditure: 100 units."
            });

            sendOutputMessage(this.player, {
                SHORT: `SH > ${this.computeShieldStrength()}`,
                MEDIUM: `Shield strength: ${this.computeShieldStrength()}`,
                LONG: `Current shield strength is ${this.computeShieldStrength()}`
            });

        } else if (this.shieldsUp) {
            sendOutputMessage(this.player, {
                SHORT: "SH > UP ALRDY",
                MEDIUM: "Shields are already up.",
                LONG: "Shields are already raised; no action taken."
            });

        } else {
            sendOutputMessage(this.player, {
                SHORT: "SH > NO E",
                MEDIUM: "Insufficient energy to raise shields.",
                LONG: "Unable to raise shields due to inadequate ship energy reserves."
            });

        }
    }

    lowerShields(): void {
        if (this.shieldsUp) {
            this.shieldsUp = false;

            sendOutputMessage(this.player, {
                SHORT: "SH > DN",
                MEDIUM: "Shields lowered.",
                LONG: "Defensive shields have been lowered."
            });

            sendOutputMessage(this.player, {
                SHORT: `SH > ${this.computeShieldStrength()}`,
                MEDIUM: `Shield strength: ${this.computeShieldStrength()}`,
                LONG: `Current shield strength is ${this.computeShieldStrength()}`
            });

        } else {
            sendOutputMessage(this.player, {
                SHORT: "SH > DN ALRDY",
                MEDIUM: "Shields are already down.",
                LONG: "Shields are already lowered; no action taken."
            });
        }
    }

    transferToShields(amount: number): number {
        const maxShieldEnergy = MAX_SHIELD_ENERGY;
        const availableShipEnergy = Math.max(0, this.energy);
        const shieldRoom = Math.max(0, maxShieldEnergy - this.shieldEnergy);
        const requestedAmount = Math.max(0, amount);

        const transferable = Math.min(requestedAmount, availableShipEnergy, shieldRoom);

        if (transferable <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > MAX",
                MEDIUM: "Shields full or insufficient energy.",
                LONG: "Shield energy is already at maximum or ship lacks energy for transfer."
            });
            return 0;
        }

        this.shieldEnergy += transferable;
        this.energy -= transferable;

        sendOutputMessage(this.player, {
            SHORT: `+SH ${transferable}`,
            MEDIUM: `Transferred ${transferable} to shields.`,
            LONG: `Transferred ${transferable} units of energy from ship to shields.`
        });

        sendOutputMessage(this.player, {
            SHORT: `EN ${this.energy}`,
            MEDIUM: `Ship energy: ${this.energy}`,
            LONG: `Remaining ship energy: ${this.energy}`
        });

        sendOutputMessage(this.player, {
            SHORT: `SH ${this.shieldEnergy}`,
            MEDIUM: `Shield energy: ${this.shieldEnergy}`,
            LONG: `Current shield reserve: ${this.shieldEnergy}`
        });

        return transferable;
    }

    transferFromShields(amount: number): number {
        const maxShipEnergy = MAX_SHIP_ENERGY;
        const shipEnergy = this.energy;
        const roomInShip = maxShipEnergy - shipEnergy;

        if (isNaN(amount) || amount <= 0) {
            sendOutputMessage(this.player, {
                SHORT: `SH > BAD AMT`,
                MEDIUM: `Invalid amount: ${amount}`,
                LONG: `Invalid energy transfer amount: ${amount}. Operation cancelled.`
            });

            return 0;
        }

        if (roomInShip <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > SHIP FULL",
                MEDIUM: "Ship already at full energy.",
                LONG: "Cannot transfer from shields — ship's energy storage is already full."
            });
            return 0;
        }

        const transferable = Math.min(amount, this.shieldEnergy, roomInShip);

        if (transferable <= 0) {
            sendOutputMessage(this.player, {
                SHORT: "SH > NO SH",
                MEDIUM: "Not enough energy in shields.",
                LONG: "Insufficient shield energy available for transfer."
            });

            return 0;
        }

        this.shieldEnergy -= transferable;
        this.energy += transferable;

        sendOutputMessage(this.player, {
            SHORT: `-SH ${transferable}`,
            MEDIUM: `Transferred ${transferable} from shields.`,
            LONG: `Transferred ${transferable} units of energy from shields to ship.`
        });
        return transferable;
    }

    computeShieldStrength(): string {
        const percentage = (this.shieldEnergy / MAX_SHIELD_ENERGY) * 100;    //TODO SHIELD AND LEVEL?  is this correct?
        const strength = Math.max(0, Math.floor(percentage));
        return strength === 100
            ? `${strength}%`
            : `${this.shieldsUp ? '+' : '-'}${strength}%`;
    }

    computeShieldPercent(): number {
        const percent = (this.shieldEnergy / MAX_SHIELD_ENERGY) * 100;
        return this.shieldsUp ? Math.round(percent) : -Math.round(percent);
    }

    isDeviceOperational(device: keyof typeof this.devices): boolean {
        function isDeviceInoperative(ship: Ship, device: keyof typeof ship.devices): boolean {
            return ship.devices[device] >= 300;
        }

        function deviceMayFail(ship: Ship, device: keyof typeof ship.devices): boolean {
            const dmg = ship.devices[device];
            return dmg >= 300 || (dmg >= 100 && ran() < 0.25);
        }

        function deviceMalfunctionMessage(device: string): string {
            const messages: Record<string, string> = {
                warp: "ERROR: Warp drive malfunction.",
                impulse: "ERROR: Impulse engines not responding.",
                torpedo: "ERROR: Torpedo system inoperative.",
                phaser: "ERROR: Phaser banks offline.",
                shield: "ERROR: Shield generator offline.",
                computer: "ERROR: Computer too damaged to compute coordinates.",
                lifeSupport: "WARNING: Life support system failing.",
                radio: "ERROR: Radio system inoperative.",
                tractor: "Tractor beam not in operation at this time, sir.",
            };
            return messages[device] ?? `ERROR: ${device} system failure.`;
        }

        if (isDeviceInoperative(this, device)) {
            sendMessageToClient(this.player, deviceMalfunctionMessage(device));
            return false;
        }
        if (deviceMayFail(this, device)) {
            sendMessageToClient(this.player, deviceMalfunctionMessage(device));
            return false;
        }
        return true;
    }


    computeCondition(): Condition {
        // 1. RED if any enemy ship within 10-man distance
        for (const other of players) {
            if (other === this.player || !other.ship) continue;
            if (other.ship.side === this.side) continue;

            // if (chebyshev(this.position, other.ship.position) <= 10) {  // TODO PUT BACK
            //     return "RED";
            // }
        }

        // 2. YELLOW if moderately low energy or significant damage
        if (this.damage >= 1000 || this.energy < 1000) {
            return "YELLOW";
        }

        // 3. GREEN otherwise
        return "GREEN";
    }

    static resolveShipName(abbreviation: string): string | null {
        const upper = abbreviation.toUpperCase();
        return SHIPNAMES.find(name => name.startsWith(upper)) || null;
    }

    static findPlayerByName(name: string): Player | undefined {
        return [...players].find(p => p.ship && p.ship.name === name);
    }

    static findShipByPartialName(partialName: string): Ship | null {
        if (!partialName) return null;
        const name = partialName.toUpperCase();
        const ship = players.find(
            (player: Player) => player.ship && player.ship.name && player.ship.name.toUpperCase().startsWith(name)
        )?.ship;
        return ship || null;
    }
}

export function applyDeviceDamage(
    ship: Ship,
    totalDamage = 150,
    targetDevices?: DeviceName[]
): void {
    const devices = (targetDevices ?? Object.keys(ship.devices)) as DeviceName[];

    const hits = 2 + iran(2); // 2 or 3 hits
    const perDevice = Math.floor(totalDamage / hits);

    const damageMap: Partial<Record<DeviceName, number>> = {};

    for (let i = 0; i < hits; i++) {
        const target = devices[iran(devices.length)];
        ship.devices[target] += perDevice;
        damageMap[target] = (damageMap[target] ?? 0) + perDevice;
    }

    for (const device of Object.keys(damageMap) as DeviceName[]) {
        const value = ship.devices[device];
        const status = value >= 300 ? "destroyed" : "damaged";
        addPendingMessage(ship.player, `${device} ${status}`);
    }
}

export function getNearbyAlliedShips(v: number, h: number, side: string, range: number): Player[] {
    return players.filter(p => {
        if (!p.ship) return false;
        if (p.ship.side !== side) return false;
        if (!p.radioOn) return false;

        return chebyshev(p.ship.position, { v: v, h: h }) <= range;
    });
}

export function attemptDisplaceFromImpact(attacker: Player, target: Player): void {
    if (!target.ship || !attacker.ship) return;

    const from = attacker.ship.position;
    const to = target.ship.position;

    const dv = Math.sign(to.v - from.v); // impact direction on Y
    const dh = Math.sign(to.h - from.h); // impact direction on X


    const newV = to.v + dv;
    const newH = to.h + dh;

    if (!isInBounds(newV, newH)) return;

    // Do not displace if the space is occupied by any game object (ship, planet, base, etc.)
    if (!findObjectAtPosition(newV, newH, true)) return;

    // Displace the ship
    target.ship.position = { v: newV, h: newH };

    const coords = ocdefCoords(attacker.settings.ocdef, attacker.ship.position, { v: newV, h: newH });
    addPendingMessage(target, `You were displaced to ${coords} by the torpedo impact.`);
    sendMessageToClient(attacker, `${target.ship.name} was knocked to ${newV}-${newH}.`);
}



export function getAdjacentFriendlyPlanets(ship: Ship): Planet[] {
    const { v, h } = ship.position;
    const team = ship.side;

    const adjacent: Planet[] = [];

    for (const planet of planets) {
        if (
            planet.side === team &&
            isAdjacent({ v, h }, planet.position) &&
            !adjacent.some(obj =>
                obj.position.v === planet.position.v &&
                obj.position.h === planet.position.h
            )
        ) {
            adjacent.push(planet);
        }
    }

    return adjacent;
}

export function handleUndockForAllShipsAfterPortDestruction(destroyedPort: Planet): void {
    const side = destroyedPort.side;
    if (side !== "FEDERATION" && side !== "EMPIRE") return; // nothing to do for neutral

    // Alive friendly bases
    const friendlyBases = (side === "FEDERATION" ? bases.federation : bases.empire)
        .filter(b => b.isBase && b.energy > 0);

    // Friendly captured planets (if your game allows docking at them)
    const friendlyPlanets = planets.filter(pl => pl.side === side && !pl.isBase /* captured planet */);

    for (const p of players) {
        const ship = p.ship;
        if (!ship || !ship.docked) continue;
        if (ship.side !== side) continue; // only ships of the destroyed side are affected

        // If ship is still adjacent to ANY friendly base or friendly captured planet, it can remain docked.
        const stillAdjacentToFriendlyBase = friendlyBases.some(b => isAdjacent(ship.position, b.position));
        const stillAdjacentToFriendlyPlanet = friendlyPlanets.some(pl => isAdjacent(ship.position, pl.position));
        const canRemainDocked = stillAdjacentToFriendlyBase || stillAdjacentToFriendlyPlanet;

        if (!canRemainDocked) {
            // Force undock and set RED (BASKIL behavior)
            ship.docked = false;
            ship.condition = "RED";

            // Clear any tracked dock target if present
            if (hasDockTarget(ship)) {
                ship.dockTarget = undefined;
            }

            addPendingMessage(p, "Your docking port was destroyed. You are now UNDOCKED. Condition set to RED.");
        } else {
            // Optional retargeting if you track a dock target (safe no-op otherwise)
            // if (hasDockTarget(ship)) {
            //   const teamBases = ship.side === "FEDERATION" ? bases.federation : bases.empire;
            //   const nearbyBase = teamBases.find(b => isAdjacent(ship.position, b.position));
            //   const nearbyPlanet = planets.find(pl => pl.side === ship.side && isAdjacent(ship.position, pl.position));
            //   ship.dockTarget = nearbyBase ?? nearbyPlanet ?? ship.dockTarget;
            // }
        }
    }
}
######## srs.ts
import { DEFAULT_SRS_RANGE } from "./settings.js";
import { Player } from './player.js';
import { Command } from './command.js';
import { scan } from "./scan.js";

export function shortRangeScanCommand(player: Player, command: Command): void {
    scan(player, command, DEFAULT_SRS_RANGE);
}
######## star.ts
import { GRID_WIDTH, GRID_HEIGHT } from './settings.js';
import { stars } from './game.js';
import { findObjectAtPosition, Position } from './coords.js';
import { getRandom } from './util/random.js';

export class Star {
    position: Position;

    constructor(v: number, h: number) {
        this.position = { v, h };
    }

    static generate(count?: number): Star[] {
        if (typeof count !== 'number') {
            count = Math.floor(getRandom() * 21) + 40; // 40–60
        }
        let attempts = 0;

        while (stars.length < count && attempts < 1000) {
            const v = Math.floor(getRandom() * GRID_WIDTH) + 1;
            const h = Math.floor(getRandom() * GRID_HEIGHT) + 1;

            if (!findObjectAtPosition(v, h)) {
                stars.push(new Star(v, h));
            }

            attempts++;
        }
        return stars;
    }
}

######## starbase_phasers.ts
import { Player } from './player.js';
import { Side } from './settings.js';
import { Planet } from './planet.js';
import { bases, players, pointsManager, SHIP_FATAL_DAMAGE } from './game.js';
import { chebyshev } from './coords.js';
import { phadamCore } from './phaser.js';
import { maybeApplyShipCriticalParity } from './phaser.js';
import { applyDamage } from './torpedo.js';
import { MAX_SHIELD_ENERGY } from './settings.js';
import { addPendingMessage } from './communication.js';
import { Ship } from './ship.js';
import { getRandom } from './util/random.js'; // deterministic RNG used elsewhere
import { emitShieldsChanged } from './api/events.js';

type RomulanStatus = {
    isRomulan: boolean;
    isRevealed: boolean;
    cloaked: boolean;
};

// Match the phaser module’s PHADAM input scale (ships divide by 20 before core).
const PHADAM_PHIT_DIVISOR = 20;

// --- BASPHA parity: enemy bases fire once per sweep ------------------
function isVisibleToBase(p: Player): boolean {
    const s = p.ship;
    // Preserve prior behavior: players without a ship were treated as "visible"
    if (!s) return true;

    // Invisible only if truly cloaked and not currently revealed
    if (hasRomulanStatus(s)) {
        return !(s.romulanStatus.cloaked && !s.romulanStatus.isRevealed);
    }

    // No romulan status → visible
    return true;
}

function baseIsOperational(p: Planet): boolean {
    // Today: all registry entries are operational.
    // Future: add e.g. `return p.isBase && !p.destroyed;`
    return p.isBase === true;
}

function enemyBasesFor(side: Side): Planet[] {
    if (side === "ROMULAN") {
        return [...bases.federation, ...bases.empire].filter(baseIsOperational);
    }
    const enemySide: Side = (side === "FEDERATION") ? "EMPIRE" : "FEDERATION";
    const arr = (enemySide === "FEDERATION") ? bases.federation : bases.empire;
    return arr.filter(baseIsOperational);
}

export function basphaFireOnce(mover: Player, numply: number): void {
    if (!mover?.ship) return;

    // Fortran BASPHA: phit = floor(200 / numply)
    const basePhit = Math.max(1, Math.floor(200 / Math.max(1, numply)));

    const allTargets = players.filter(
        p => p?.ship && p.ship.energy > 0 && isVisibleToBase(p)
    );

    const basesToFire = enemyBasesFor(mover.ship.side);

    for (const base of basesToFire) {
        // Each base selects enemies of its own side (important if mover is ROMULAN)
        const targets = allTargets.filter(p => p.ship!.side !== base.side);

        for (const ship of targets) {
            const s = ship.ship!;
            if (s.romulanStatus?.cloaked) continue; // skip cloaked

            const distance = chebyshev(base.position, s.position);
            if (distance > 4) continue; // Fortran: ldis(..., 4)

            // PHADAM (base -> ship): targetIsBase=false, shooterDamaged=false
            const shieldsBefore = s.shieldEnergy;
            const targetShieldsUp = Boolean(s.shieldsUp);

            const core = phadamCore({
                targetIsBase: false,
                targetShieldsUp,
                rawShieldEnergy: s.shieldEnergy,
                rawShieldMax: MAX_SHIELD_ENERGY,
                distance,
                shooterDamaged: false,
                // Feed core-scale phit (same divisor used by ship/planet phasers)
                phit: basePhit / PHADAM_PHIT_DIVISOR,
            });

            let hita = core.hita;

            // Write back shield drain first
            s.shieldEnergy = core.newShieldEnergy;
            if (shieldsBefore !== s.shieldEnergy) {
                emitShieldsChanged(ship, shieldsBefore, s.shieldEnergy);
            }

            // Ship device crit BEFORE hull (threshold rule; jitter only on crits)
            if (hita > 0) {
                const crit = maybeApplyShipCriticalParity(ship, hita);
                if (crit.isCrit) {
                    hita = crit.hita;

                    const deviceKeys = Object.keys(s.devices);
                    const deviceName = deviceKeys[crit.critdv]?.toUpperCase?.() ?? "DEVICE";
                    if (crit.critdm > 0) {
                        addPendingMessage(ship, `BASE PHASERS CRIT: ${deviceName} damaged by ${crit.critdm}!`);
                    } else {
                        addPendingMessage(ship, `BASE PHASERS CRIT: ${deviceName} struck!`);
                    }
                } else {
                    // Non-crit: round like the Fortran path (no global jitter)
                    hita = Math.max(0, Math.round(hita));
                }
            }

            // Use pre-state to gate kill credit during this volley
            const wasAlive = s.energy > 0;

            // Apply hull/energy via shared resolver (so you keep one place for destruction rules)
            const res = applyDamage(base, ship, hita, getRandom());

            // === scoring parity (credit exactly this volley) ===
            const dealt = Math.max(0, Math.round(res.hita));
            try {
                // scoring: base category + kill-only-once
                (pointsManager as any).addDamageToBases?.(dealt, /*by*/ undefined, base.side);
                if (wasAlive && res.isDestroyed && ship.ship && !ship.ship.__killCredited) {
                    ship.ship.__killCredited = true;
                    (pointsManager as any).addEnemiesDestroyed?.(1, /*by*/ undefined, base.side);
                }
            } catch { /* okay if pointsManager is not present */ }
            // ===================================================
        }
    }
}

function hasRomulanStatus(s: Ship): s is Ship & { romulanStatus: RomulanStatus } {
    return typeof (s as unknown as { romulanStatus?: RomulanStatus }).romulanStatus !== "undefined";
}

######## status.ts

import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';
import { MAX_SHIELD_ENERGY, settings } from './settings.js';
import { Player } from './player.js';
import { ocdefCoords } from './coords.js';

/**
 * Syntax: STATUS [<codes>]
 * Codes: C (Condition), L (Location), T (Torpedoes), E (Energy),
 *        D (Damage), SH (Shields), RA (Radio), PH (Phasers cooldown)
 * No args: full report in order: Condition, Location, Torps, Energy,
 *          Damage, Shields, Radio.
 */
export function statusCommand(player: Player, command: Command): void {
    const args = command.args.map(a => a.toUpperCase());
    const mode: "SHORT" | "MEDIUM" | "LONG" = player.settings.output ?? "LONG";
    //const coordsMode = player.settings.ocdef ?? "ABSOLUTE";

    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use STATUS.");
        return;
    }

    const allFields = ['condition', 'location', 'torpedoes', 'energy', 'damage', 'shields', 'radio', 'phasers'];

    let fields: string[];
    if (args.length === 0) {
        fields = allFields;
    } else {
        fields = allFields.filter(field =>
            args.some(arg => arg.length > 1 && field.toLowerCase().startsWith(arg)) ? field : false
        );
    }

    console.log(fields);

    // Always display stardate first
    switch (mode) {
        case "SHORT":
            sendMessageToClient(player, `SD${settings.stardate}`);
            break;
        case "MEDIUM":
            sendMessageToClient(player, `SDate    ${settings.stardate}`);
            break;
        case "LONG":
        default:
            sendMessageToClient(player, `Stardate   ${settings.stardate}`);
            break;
    }

    const shortParts: string[] = [];
    const conditionStr = player.ship.computeCondition();

    for (const field of fields) {
        switch (field) {
            case 'condition': {
                const isDocked = player.ship.docked;
                const flag = conditionStr[0]; // R, Y, G
                const text = isDocked ? `D+${flag}` : flag;
                if (mode === "SHORT") shortParts.push(text);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Cond   ${conditionStr}`);
                else sendMessageToClient(player, `Condition  ${conditionStr}`);
                break;
            }
            case 'location': {
                const coordText = ocdefCoords(player.settings.ocdef, player.ship.position, player.ship.position);

                if (mode === "SHORT") shortParts.push(coordText);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Loc    ${coordText}`);
                else sendMessageToClient(player, `Location   ${coordText}`);
                break;
            }
            case 'torpedoes': {
                const t = `T${player.ship.torpedoes}`;
                if (mode === "SHORT") shortParts.push(t);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Torps    ${player.ship.torpedoes}`);
                else sendMessageToClient(player, `Torpedoes  ${player.ship.torpedoes}`);
                break;
            }
            case 'energy': {
                const e = `E${Math.round(player.ship.energy)}`;
                if (mode === "SHORT") shortParts.push(e);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Ener   ${player.ship.energy.toFixed(1)}`);
                else sendMessageToClient(player, `Energy     ${player.ship.energy.toFixed(1)}`);
                break;
            }
            case 'damage': {
                const d = `D${Math.round(player.ship.damage)}`;
                if (mode === "SHORT") shortParts.push(d);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Dam     ${player.ship.damage.toFixed(1)}`);
                else sendMessageToClient(player, `Damage     ${player.ship.damage.toFixed(1)}`);
                break;
            }
            case 'shields': {
                const curr = player.ship.shieldEnergy;
                const pct = Math.round((curr / MAX_SHIELD_ENERGY) * 100);
                const status = player.ship.shieldsUp ? "UP" : "DN";
                if (mode === "SHORT") shortParts.push(`SH+${pct}/${status}`);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Shlds  +${pct.toFixed(1)}% ${curr.toFixed(1)} units (${status})`);
                else sendMessageToClient(player, `Shields    +${pct.toFixed(1)}%   ${curr.toFixed(1)} units (${status})`);
                break;
            }
            case 'radio': {
                const r = player.radioOn ? "ROn" : "ROff";
                if (mode === "SHORT") shortParts.push(r);
                else if (mode === "MEDIUM") sendMessageToClient(player, `Radio  ${player.radioOn ? "On" : "Off"}`);
                else sendMessageToClient(player, `Radio      ${player.radioOn ? "On" : "Off"}`);
                break;
            }
            case 'phasers': {
                const now = Date.now();
                const [ph1, ph2] = player.ship.cooldowns.phasersAvailableAt;
                const nextReady = Math.min(ph1, ph2);
                const ready = now >= nextReady;
                if (mode === "SHORT") {
                    shortParts.push(ready ? "PHok" : `PH${Math.ceil((nextReady - now) / 1000)}s`);
                } else {
                    const message = ready
                        ? "Phasrs     ready"
                        : `Phasrs     cooling down (${Math.ceil((nextReady - now) / 1000)}s)`;
                    sendMessageToClient(player, message);
                }
                break;
            }
        }
    }

    if (mode === "SHORT") {
        sendMessageToClient(player, shortParts.join(" "));
    }
}

######## summary.ts
import { listCommandHelper } from "./list.js";
import { Command } from "./command.js";
import { Player } from './player.js';


export function summaryCommand(player: Player, command: Command): void {
    listCommandHelper(player, command, true);
}

######## targets.ts
import { listCommand } from "./list.js";
import { Player } from "./player.js";
import { Command } from "./command.js";

export function targetsCommand(player: Player, command: Command): void {
    const newArgs = ["ENEMY", ...command.args];
    const taggedCommand = { ...command, args: newArgs };

    listCommand(player, taggedCommand);
}
######## tell.ts
import { Player } from './player.js';
import { Command } from './command.js';
import { players } from './game.js';
import { addPendingMessage, sendMessageToClient } from './communication.js';
import { SHIPNAMES } from './settings.js';
import { matchesPattern } from './util/util.js';
// 👇 NEW: event emitter for chat/comms
import { emitCommsSent } from './api/events.js';

export function tellCommand(player: Player, command: Command): void {
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use TELL.");
        return;
    }

    if (!player.ship.isDeviceOperational("radio")) return;

    if (!command.raw.includes(';')) {
        sendMessageToClient(player, "TEll All|FEderation|HUman|EMpire|Klingon|ENemy|FRiendly|<shipnames>;<msg>");
        return;
    }

    const [targetPart, ...msgParts] = command.raw.split(";");
    const message = msgParts.join(";").trim();

    if (!player.radioOn) {
        sendMessageToClient(player, "Captain, your radio is off.");
        return;
    }

    if (!message) {
        sendMessageToClient(player, "Message required after semicolon.");
        return;
    }

    const targetTokens = targetPart.trim().split(/\s+/).slice(1).map(t => t.toUpperCase());
    let targetDesc = targetTokens.join(" ");
    let recipients = players.filter(p => p.ship);

    const keyword = targetTokens[0];

    // --- Handle broadcast group keywords ---
    const matchGroup =
        matchesPattern(keyword, "All") ? "ALL" :
            matchesPattern(keyword, "FEderation") ? "FEDERATION" :
                matchesPattern(keyword, "EMpire") ? "EMPIRE" :
                    matchesPattern(keyword, "Human") ? "HUMAN" :
                        matchesPattern(keyword, "Klingon") ? "KLINGON" :
                            matchesPattern(keyword, "ENemy") ? "ENEMY" :
                                matchesPattern(keyword, "FRiendly") ? "FRIENDLY" :
                                    null;

    if (matchGroup) {
        switch (matchGroup) {
            case "ALL":
                recipients = players.filter(p => p.ship);
                targetDesc = "ALL";
                break;
            case "FEDERATION":
            case "HUMAN":
                recipients = recipients.filter(p => p.ship && p.ship.side === "FEDERATION");
                targetDesc = matchGroup;
                break;
            case "EMPIRE":
            case "KLINGON":
                recipients = recipients.filter(p => p.ship && p.ship.side === "EMPIRE");
                targetDesc = matchGroup;
                break;
            case "ENEMY":
                recipients = recipients.filter(p => p.ship && player.ship && p.ship.side !== player.ship.side);
                targetDesc = "ENEMY";
                break;
            case "FRIENDLY":
                recipients = recipients.filter(p => p.ship && player.ship && p.ship.side === player.ship.side);
                targetDesc = "FRIENDLY";
                break;
        }
    } else {
        // --- Handle ship name targeting ---
        const matchedShips: Player[] = [];
        for (const target of targetTokens) {
            const matches = recipients.filter(p => p.ship?.name?.toUpperCase().startsWith(target));
            if (matches.length === 1) {
                matchedShips.push(matches[0]);
            } else if (SHIPNAMES.some(name => name.startsWith(target))) {
                sendMessageToClient(player, `Ship ${SHIPNAMES.find(name => name.startsWith(target))} not in game`);
            } else {
                sendMessageToClient(player, `Unknown target: ${target}`);
            }
        }
        recipients = matchedShips;
    }

    if (recipients.length === 0) {
        sendMessageToClient(player, `No reachable ${matchGroup}'s for TELL.`);
        return;
    }

    // --- Emit ONE comms event describing what was sent ---
    try {
        if (matchGroup) {
            let to:
                | { kind: "GLOBAL" }
                | { kind: "SIDE"; side: "FEDERATION" | "EMPIRE" };

            if (matchGroup === "ALL") {
                to = { kind: "GLOBAL" };
            } else if (matchGroup === "FEDERATION" || matchGroup === "HUMAN") {
                to = { kind: "SIDE", side: "FEDERATION" };
            } else if (matchGroup === "EMPIRE" || matchGroup === "KLINGON") {
                to = { kind: "SIDE", side: "EMPIRE" };
            } else if (matchGroup === "FRIENDLY") {
                // Narrow Side → "FEDERATION" | "EMPIRE"
                const mySide = player.ship!.side === "FEDERATION" ? "FEDERATION" : "EMPIRE" as const;
                to = { kind: "SIDE", side: mySide };
            } else { // ENEMY
                const enemySide = player.ship!.side === "FEDERATION" ? "EMPIRE" : "FEDERATION" as const;
                to = { kind: "SIDE", side: enemySide };
            }

            emitCommsSent(player, to, message);
        } else {
            // ship-directed: emit one event per explicit ship
            for (const r of recipients) {
                if (!r.ship) continue;
                emitCommsSent(player, { kind: "SHIP", shipName: r.ship.name, side: r.ship.side === "FEDERATION" ? "FEDERATION" : "EMPIRE" }, message);
            }
        }
    } catch {
        // never let telemetry break gameplay
    }

    // --- Deliver messages (unchanged behavior) ---
    for (const recipient of recipients) {
        if (recipient !== player) {
            if (recipient.radioOn) {
                addPendingMessage(recipient, `<< ${player.ship.name} (TELL): ${message}`);
            }
        }
    }
    sendMessageToClient(player, `>> To ${targetDesc}: ${message}`);
}

######## temp.ts

######## time.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
const gameStartTime = Date.now();

export function timeCommand(player: Player): void {
    const nowMs = Date.now();

    const secsSinceGameStart = (nowMs - gameStartTime) / 1000;
    const secsSinceJoin = (nowMs - player.joinTime) / 1000;
    const processUptimeSec = process.uptime();

    const currentTime = new Date(nowMs).toLocaleTimeString('en-US', {
        hour12: false
    });

    const timeLine = (label: string, value: string | number) => `  ${label.padEnd(22)}${value}`;
    // Add random 2 digits to stardate for a "fancy" stardate as a number
    // Galactic stardate is seconds since game start divided by 100, plus random 2 digits at the end
    //const baseStardate = secsSinceGameStart / 100;

    sendMessageToClient(player, timeLine("Stardate:", player.stardate));
    sendMessageToClient(player, timeLine("Game's elapsed time:", formatDuration(secsSinceGameStart)));
    sendMessageToClient(player, timeLine("Ship's elapsed time:", formatDuration(secsSinceJoin)));
    sendMessageToClient(player, timeLine("Current time (UTC):", currentTime));
    sendMessageToClient(player, timeLine("Job's total run time:", formatDuration(processUptimeSec)));
    sendMessageToClient(player, "");
}

export function formatDuration(totalSeconds: number): string {
    const days = Math.floor(totalSeconds / 86400);
    totalSeconds %= 86400;

    const hours = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;

    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const hms = [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        seconds.toString().padStart(2, '0')
    ].join(':');

    return days > 0
        ? `${days}d ${hms}`
        : hms;
}
######## torpedo.ts
import { Player } from './player.js';
import { ran } from './util/random.js';
import { Command } from './command.js';
import { pointsManager, SHIP_FATAL_DAMAGE, players, bases, planets, stars, blackholes, removePlayerFromGame, checkEndGame } from './game.js';
import {
    addPendingMessage,
    putClientOnHold,
    releaseClient,
    sendMessageToClient,
    sendMessageToOthers
} from './communication.js';
import {
    MAX_SHIELD_ENERGY,
    MAX_TORPEDO_RANGE,
    GRID_HEIGHT,
    GRID_WIDTH,
    CoordMode,
    OutputSetting
} from './settings.js';
import { Planet } from './planet.js';
import { isInBounds, bresenhamLine, chebyshev, ocdefCoords } from './coords.js';
import { handleUndockForAllShipsAfterPortDestruction } from './ship.js';
import { triggerNovaAt } from './nova.js';
import { Star } from './star.js';
import { Blackhole } from './blackhole.js';
import { maybeApplyShipCriticalParity } from './phaser.js';
import { Side } from './settings.js';
import { gameEvents } from './api/events.js';
import {
    emitShipDestroyed,
    attackerRef,
    emitPlanetHit,
    emitShipHullChanged,
    emitShieldsChanged,
    emitTorpedoEvent,
    emitRomulanDestroyed
} from './api/events.js';
import type { TorpedoEventPayload, GridCoord } from './api/events.js';
import { applyRomulanTorpedoHitFrom } from './romulan.js';

type ScoringAPI = {
    addDamageToBases?(amount: number, source: Player, side: Side): void;
    addEnemiesDestroyed?(count: number, source: Player, side: Side): void;
    addDamageToEnemies?(amount: number, source: Player, side: Side): void;
    addPlanetsDestroyed?(points: number, source: Player, side: Side): void;
};


type TorpedoCollision =
    | { type: "ship"; player: Player }
    | { type: "planet"; planet: Planet }
    | { type: "star"; star: Star }
    | { type: "blackhole"; blackhole: Blackhole }
    | { type: "target"; point: Point } // reached target with no collision
    | { type: "boundary"; point: Point } // reached grid boundary
    | null;

type Point = { v: number; h: number };

// Single source of truth for torpedo hull scaling (DECWAR vibe ≈ ×0.1)
const TORP_HULL_SCALE = 0.1;

// Default to LONG if not explicitly set
function getOutputSetting(p: Player): OutputSetting {
    return (p.settings.output ?? "LONG") as OutputSetting;
}

function formatTorpedoShipHit(opts: {
    attackerInitial: string;
    targetInitial: string;
    atkPos: { v: number; h: number };
    offset: string;                     // e.g. "+5,+1"
    beforePct: number;                  // one decimal (e.g. 81.2)
    damageUnits: number;                // one decimal
    deflected?: boolean;
    deflectTo?: { v: number; h: number } | null;
    deltaPct: number;                   // one decimal, often negative
    critDeviceName?: string;
    output: OutputSetting;
}): string {
    const {
        attackerInitial, targetInitial, atkPos, offset, beforePct,
        damageUnits, deflected, deflectTo, deltaPct, critDeviceName, output
    } = opts;

    const sign = deltaPct >= 0 ? "+" : "";
    const arrow = deflected && deflectTo ? ` -->${deflectTo.v}-${deflectTo.h},` : "";
    const critTextLong = critDeviceName ? `; ${critDeviceName} dam ${Math.round(damageUnits)}` : "";
    const critTextMed = critDeviceName ? `; ${critDeviceName} ${Math.round(damageUnits)}` : "";
    const critTextShort = critDeviceName ? `; ${critDeviceName[0]} ${Math.round(damageUnits)}` : "";

    switch (output) {
        case "LONG":
            // Full DECWAR-style with before% and arrow if deflected
            return `${attackerInitial}> ${targetInitial} @${atkPos.v}-${atkPos.h} ${offset}, +${beforePct}% ${damageUnits.toFixed(1)} unit T ${targetInitial} ${arrow} ${sign}${deltaPct}%${critTextLong}`;
        case "MEDIUM":
            // Keep coords and core numbers, drop some words
            return `${attackerInitial}> ${targetInitial} @${atkPos.v}-${atkPos.h} ${damageUnits.toFixed(1)}T ${sign}${deltaPct}%${critTextMed}`;
        case "SHORT":
        default:
            // Compact: initials, damage, and shield delta
            return `${attackerInitial}> ${targetInitial} ${Math.round(damageUnits)}T ${sign}${deltaPct}%${critTextShort}`;
    }
}

function clampPointWithinRange(start: Point, end: Point, maxChebyshev: number): Point {
    // Limit travel to MAX_TORPEDO_RANGE steps in Chebyshev metric
    const dv = end.v - start.v;
    const dh = end.h - start.h;
    const dist = Math.max(Math.abs(dv), Math.abs(dh));
    if (dist <= maxChebyshev) return { v: end.v, h: end.h };
    const scale = maxChebyshev / dist;
    const v = Math.round(start.v + dv * scale);
    const h = Math.round(start.h + dh * scale);
    return {
        v: Math.max(1, Math.min(GRID_HEIGHT, v)),
        h: Math.max(1, Math.min(GRID_WIDTH, h)),
    };
}

function traceTorpedoPath(player: Player, start: Point, target: Point): TorpedoCollision {

    if (!isInBounds(start.v, start.h) || !isInBounds(target.v, target.h)) {
        sendMessageToClient(player, `Start ${JSON.stringify(start)} or target ${JSON.stringify(target)} is outside grid boundaries`);
        return null;
    }

    const { v: endV, h: endH } = clampPointWithinRange(start, target, MAX_TORPEDO_RANGE);
    const points = bresenhamLine(start.v, start.h, endV, endH);
    let skipFirst = true;

    for (const { v, h } of points) {
        if (skipFirst) {
            skipFirst = false;
            continue; // Skip the attacker's own position
        }

        // Verify point is within grid (defensive check)
        if (!isInBounds(v, h)) {
            sendMessageToClient(player, `Bresenham point (${v}, ${h}) is outside grid boundaries`);
            return null;
        }

        // Check for ship
        const ship = players.find(p => p.ship && p.ship.position.v === v && p.ship.position.h === h);
        if (ship) return { type: "ship", player: ship };

        // Check for planet
        const planet = planets.find(p => p.position.h === h && p.position.v === v);
        if (planet) return { type: "planet", planet: planet };

        // Check for star
        const star = stars.find(star => star.position.v === v && star.position.h === h);
        if (star) {
            return { type: "star", star: star };
        }

        // Check for black hole
        const blackhole = blackholes.find(bh => bh.position.v === v && bh.position.h === h);
        if (blackhole) {
            return { type: "blackhole", blackhole: blackhole };
        }
    }

    // No collision, reached the travel limit/boundary
    const boundaryPoint = { v: endV, h: endH };
    // if (!isInBounds(boundaryPoint.v, boundaryPoint.h)) {
    //     throw new Error(`Boundary point ${JSON.stringify(boundaryPoint)} is outside grid boundaries`);
    // }
    return { type: "boundary", point: boundaryPoint };
}


function getTargetsFromCommand(player: Player, args: string[], mode: "ABSOLUTE" | "RELATIVE" | "COMPUTED", cursor: number, n: number): { v: number; h: number }[] | null {
    const targets: { v: number; h: number }[] = [];
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to fire torpedoes.");
        return null;
    }

    if (mode === "COMPUTED") {
        const matchedShips: { v: number; h: number }[] = [];
        while (cursor < args.length) {
            const partialName = args[cursor++].toUpperCase();
            const match = players.find(p => p.ship && p.ship.name && p.ship.name.toUpperCase().startsWith(partialName));
            if (!match) {
                sendMessageToClient(player, `No ship found matching '${partialName}'.`);
                return null;
            }
            if (match.ship) {
                matchedShips.push({ v: match.ship.position.v, h: match.ship.position.h });
            }
        }
        if (matchedShips.length === 0) {
            sendMessageToClient(player, "At least one valid ship name must be provided.");
            return null;
        }
        targets.push(...repeatOrTrim(matchedShips, n));
    } else {
        const coordPairs: { v: number, h: number; }[] = [];
        if (mode === "RELATIVE") {
            while (cursor + 1 < args.length) {
                const dv = parseInt(args[cursor++]);
                const dh = parseInt(args[cursor++]);
                if (isNaN(dv) || isNaN(dh)) {
                    sendMessageToClient(player, "Invalid RELATIVE coordinate offset.");
                    return null;
                }
                coordPairs.push({
                    v: player.ship.position.v + dv,
                    h: player.ship.position.h + dh
                });
            }
        } else {
            while (cursor + 1 < args.length) {
                const v = parseInt(args[cursor++]);
                const h = parseInt(args[cursor++]);
                if (isNaN(v) || isNaN(h)) {
                    sendMessageToClient(player, "Invalid coordinate pair.");
                    return null;
                }
                coordPairs.push({ v, h });
            }
        }
        if (coordPairs.length === 0) {
            sendMessageToClient(player, "At least one coordinate pair is required.");
            return null;
        }
        targets.push(...repeatOrTrim(coordPairs, n));
    }

    return targets;
}

function toCollisionPayload(coll: TorpedoCollision): TorpedoEventPayload["collision"] {
    if (!coll) return { kind: "none" as const };
    switch (coll.type) {
        case "ship":
            return {
                kind: "ship" as const,
                name: coll.player.ship!.name,
                side: coll.player.ship!.side,
                position: { ...coll.player.ship!.position },
            };
        case "planet":
            return coll.planet.isBase
                ? { kind: "base" as const, name: coll.planet.name, side: coll.planet.side, position: { ...coll.planet.position } }
                : { kind: "planet" as const, name: coll.planet.name, side: coll.planet.side, position: { ...coll.planet.position } };
        case "star":
            return { kind: "star" as const, position: { ...coll.star.position } };
        case "blackhole":
            return { kind: "blackhole" as const, position: { ...coll.blackhole.position } };
        case "boundary":
            return { kind: "boundary" as const, position: { ...coll.point } };
        case "target":
            return { kind: "none" as const };
        default:
            return { kind: "none" as const };
    }
}

function emitBasicTorpedoEvent(
    attacker: Player,
    from: Point,
    aim: Point,
    coll: TorpedoCollision | null,
    extra?: {
        result?: TorpedoEventPayload["result"];
        damage?: number;
        shieldsBefore?: number;
        shieldsAfter?: number;
        killed?: boolean;
        novaTriggered?: boolean;
        crit?: { device?: string; amount?: number } | null;
    }
) {
    if (!attacker.ship) return;
    const collision = toCollisionPayload(coll);
    emitTorpedoEvent({
        by: { shipName: attacker.ship.name, side: attacker.ship.side },
        from: { v: from.v, h: from.h },
        aim: { v: aim.v, h: aim.h },
        collision,
        result: (extra?.result ?? "fizzled") as TorpedoEventPayload["result"],
        damage: extra?.damage,
        shieldsBefore: extra?.shieldsBefore,
        shieldsAfter: extra?.shieldsAfter,
        killed: !!extra?.killed,
        novaTriggered: !!extra?.novaTriggered,
        crit: extra?.crit ?? null,
    });
}



export function torpedoCommand(player: Player, command: Command, done?: () => void): void {
    const args = command.args;
    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to fire torpedoes.");
        done?.();
        return;
    }

    if (!player.ship.isDeviceOperational("torpedo")) {
        done?.();
        return;
    }
    // if (Date.now() < player.ship.cooldowns.torpedoesReadyAt) {
    //     sendMessageToClient(player, "Torpedo tubes not yet reloaded.");
    //     done?.();
    //     return;
    // }

    if (args.length < 2) {
        sendMessageToClient(player, "Usage: TORPEDO [A|R|C] <1–3> <targets...>");
        done?.();
        return;
    }

    // Determine mode
    let mode: CoordMode;
    let cursor = 0;
    const modeArg = args[0].toUpperCase();

    if (["A", "ABSOLUTE"].includes(modeArg)) { mode = "ABSOLUTE"; cursor++; }
    else if (["R", "RELATIVE"].includes(modeArg)) { mode = "RELATIVE"; cursor++; }
    else if (["C", "COMPUTED"].includes(modeArg)) { mode = "COMPUTED"; cursor++; }
    else { mode = player.settings.icdef; }

    const n = parseInt(args[cursor++]);
    if (isNaN(n) || n < 1 || n > 3) {
        sendMessageToClient(player, "You must fire between 1 and 3 torpedoes.");
        done?.();
        return;
    }

    if (player.ship.torpedoes < n) {
        sendMessageToClient(player, "Not enough torpedoes.");
        done?.();
        return;
    }

    if (mode === "COMPUTED" && !player.ship.isDeviceOperational("computer")) {
        done?.();
        return;
    }

    const targets = getTargetsFromCommand(player, args, mode, cursor, n);
    if (!targets) {
        done?.();
        return;
    }

    for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.v === player.ship.position.v && target.h === player.ship.position.h) {
            sendMessageToClient(player, "Cannot target your own position.");
            continue;
        }
        const range = chebyshev(player.ship.position, target);
        if (range > MAX_TORPEDO_RANGE) {
            sendMessageToClient(player, formatTorpedoOutOfRange(player, target.v, target.h));
            continue;
        }

        const collision = traceTorpedoPath(player, player.ship.position, target);
        if (!collision) {
            continue;
        }


        let fired = false;
        switch (collision?.type) {
            case "ship": {
                const victim = collision.player;

                // --- SPECIAL CASE: ROMULAN uses separate 'erom' (not ship.energy/damage) ---
                if (victim.ship?.romulanStatus?.isRomulan) {
                    const atk = player.ship!;
                    // Capture position BEFORE any destroy-side effects
                    const rpos = victim.ship.position ? { ...victim.ship.position } : { v: target.v, h: target.h };
                    const { ihita, killed } = applyRomulanTorpedoHitFrom();
                    // Visible scaling (Romulan routines are ~×10 larger internally)
                    const shown = Math.max(1, Math.round(ihita / 10));

                    // Attacker feedback + normal torpedo event for loggers/UI
                    addPendingMessage(player, `Direct torpedo hit on ROMULAN for ${shown}!`);
                    emitBasicTorpedoEvent(
                        player,
                        atk.position,
                        target,
                        collision,
                        { result: "hit", damage: shown, killed }
                    );

                    if (killed) {
                        emitRomulanDestroyed(rpos, attackerRef(player));
                    }

                    fired = true;
                    break; // Skip normal ship damage path
                }
                // --- /ROMULAN SPECIAL CASE ---

                const energyBefore = victim.ship!.energy;
                const damageBefore = victim.ship!.damage;
                const shieldsBefore = victim.ship!.shieldEnergy;
                const atk = player.ship!;
                const vic = victim.ship!;
                const attackerInitial = atk.name?.[0] ?? '?';
                const targetInitial = vic.name?.[0] ?? '?';
                const beforePct = Math.round((Math.max(0, shieldsBefore) / Math.max(1, MAX_SHIELD_ENERGY)) * 1000) / 10; // one decimal
                const dv = vic.position.v - atk.position.v;
                const dh = vic.position.h - atk.position.h;
                const off = `${dh >= 0 ? "+" : ""}${dh},${dv >= 0 ? "+" : ""}${dv}`;


                const res = torpedoDamage(player, victim);

                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,
                    target,
                    collision,
                    {
                        result: res.deflected ? "deflected" : (res.hita > 0 ? "hit" : "no_effect"),
                        damage: res.hita,
                        shieldsBefore,
                        shieldsAfter: victim.ship!.shieldEnergy,
                        killed: !!res.isDestroyed,
                        crit: res.critdm ? { device: res.critDeviceName ?? "DEVICE", amount: res.critdm } : null
                    }
                );

                fired = true;

                // hull/energy aggregate
                emitShipHullChanged(
                    victim,
                    energyBefore,
                    victim.ship!.energy,
                    damageBefore,
                    victim.ship!.damage,
                    "torpedo",
                    player
                );

                // shields delta (only if changed)
                if (victim.ship && shieldsBefore !== victim.ship.shieldEnergy) {
                    emitShieldsChanged(victim, shieldsBefore, victim.ship.shieldEnergy);
                }

                const afterPct = Math.round((Math.max(0, vic.shieldEnergy) / Math.max(1, MAX_SHIELD_ENERGY)) * 1000) / 10;
                const deltaPct = Math.round((afterPct - beforePct) * 10) / 10; // likely negative
                const dmg = Math.round((res.hita + Number.EPSILON) * 10) / 10; // one decimal

                const line = formatTorpedoShipHit({
                    attackerInitial,
                    targetInitial,
                    atkPos: atk.position,
                    offset: off,
                    beforePct,
                    damageUnits: dmg,
                    deflected: !!res.deflected,
                    deflectTo: res.deflectTo ?? null,
                    deltaPct,
                    critDeviceName: res.critDeviceName,
                    output: getOutputSetting(player)
                });
                sendMessageToClient(player, line);

                // victim gets a shorter "you were hit" note (your choice)
                addPendingMessage(victim, `${atk.name} torpedo ${dmg} on you${res.critdm ? " (CRIT)" : ""}.`);

                if (res.isDestroyed) checkEndGame();
                break;
            }



            case "planet": {
                const p = collision.planet;
                const wasBase = p.isBase; // capture role before damage (torpedoDamage may flip it)

                // Distress like FORTRAN when base is first struck at full shields
                if (p.isBase && p.energy === 1000) {
                    for (const other of players) {
                        if (!other.ship) continue;
                        if (other.ship.side === p.side) {
                            addPendingMessage(other, `Starbase ${p.position.v}-${p.position.h} is under torpedo fire!`);
                        }
                    }
                }

                // (optional) capture before if you want it; event only needs after/damage
                // const energyBefore = p.energy;

                const res = torpedoDamage(player, p); // may collapse base and undock internally

                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,
                    target,
                    collision,
                    {
                        result: res.hita > 0 ? "hit" : "no_effect",
                        damage: res.hita,
                        shieldsBefore: p.isBase ? (/* before value if you cached it */ undefined) : undefined,
                        shieldsAfter: p.isBase ? p.energy : undefined,
                        killed: !!res.isDestroyed,
                        crit: res.critdm ? { device: "BASE", amount: res.critdm } : null
                    }
                );
                fired = true;

                // emit per-impact planet/base damage event
                emitPlanetHit(p, "torpedo", res.hita, res.isDestroyed, player);

                const coords = ocdefCoords(player.settings.ocdef, player.ship.position, p.position);
                const out = getOutputSetting(player);
                if (res.isDestroyed) {
                    // destruction messaging independent of current p.isBase (it may already be flipped)
                    sendMessageToClient(player, formatPlanetDestroyed(out, wasBase, coords));
                    checkEndGame();
                } else if (wasBase) {
                    // base was hit but survived this shot
                    sendMessageToClient(player, formatBaseHit(out, coords, res.hita, !!res.critdm));
                } else {
                    // Non-base planet (FORTRAN parity):
                    // 25% chance -> decrement builds; if builds < 0 after the hit, the planet is destroyed
                    if (ran() >= 0.75) {
                        p.builds = p.builds - 1; // allow negative so we can detect destruction when starting at 0

                        if (p.builds < 0) {
                            // Record one planet destroyed; PointsManager applies −100 internally.
                            pointsManager.addPlanetsDestroyed(1, player, player.ship.side);

                            const planetIdx = planets.indexOf(p);
                            if (planetIdx !== -1) planets.splice(planetIdx, 1);

                            const ownerBases = p.side === "FEDERATION" ? bases.federation : bases.empire;
                            const bIdx = ownerBases.indexOf(p);
                            if (bIdx !== -1) ownerBases.splice(bIdx, 1);
                            p.isBase = false;

                            emitPlanetHit(p, "torpedo", 0, /*destroyed*/ true, player);
                            sendMessageToClient(player, formatPlanetDestroyed(out, /*wasBase*/ false, coords, /*planetPenalty*/ true));
                            checkEndGame();
                            break;
                        } else {
                            sendMessageToClient(player, formatPlanetInfra(out, coords));
                        }
                    } else {
                        sendMessageToClient(player, formatPlanetNoEffect(out, coords));
                    }
                }
                break;
            }

            case "star": {
                const { v, h } = collision.star.position;

                // player-facing text
                sendMessageToClient(player, formatTorpedoExplosion(player, v, h));

                // outcome: 80% nova
                const didNova = ran() < 0.8;
                if (didNova) {
                    // emit event first for consistent telemetry with Romulan path
                    const at: GridCoord = { v, h };
                    gameEvents.emit({
                        type: "nova_triggered",
                        payload: { at, by: attackerRef(player) },
                    });
                    triggerNovaAt(player, v, h);
                }

                // authoritative torpedo event AFTER outcome is known
                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,  // from
                    target,                // aim (absolute, as you already computed)
                    collision,             // { type: "star", star: ... }
                    {
                        result: didNova ? "hit" : "no_effect", // "hit" = did something meaningful (nova)
                        damage: 0,                              // star/nova doesn’t deal torp “hull” damage directly
                        novaTriggered: didNova
                    }
                );

                fired = true;
                break;
            }

            case "blackhole":
                sendMessageToClient(player, formatTorpedoLostInVoid(player, collision.blackhole.position.v, collision.blackhole.position.h));
                fired = true;
                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,
                    target,
                    collision,
                    { result: "no_effect", damage: 0 }
                );
                break;

            case "boundary": {
                const { v, h } = collision.point;
                sendMessageToClient(player, `Torpedo flew off to ${ocdefCoords(player.settings.ocdef, player.ship.position, { v, h })} and detonated harmlessly.`);
                fired = true;
                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,
                    target,
                    collision,
                    { result: "out_of_range", damage: 0 }
                );
                break;
            }

            default:
                sendMessageToClient(player, `Torpedo failed to reach target.`);
                emitBasicTorpedoEvent(
                    player,
                    player.ship.position,
                    target,
                    null,
                    { result: "fizzled", damage: 0 }
                );
                fired = true;
                break;
        }


        if (i !== targets.length - 1) { // not last target
            if (fired) {
                player.ship.torpedoes--;
                sendMessageToOthers(player, formatTorpedoBroadcast(player, target.v, target.h));

                if (player.ship.romulanStatus.isRomulan) {
                    player.ship.romulanStatus.isRevealed = true;
                    setTimeout(() => {
                        if (player.ship)
                            player.ship.romulanStatus.isRevealed = false;
                    }, 5000);   // TODO is this right?
                }
            }
        } else { // last target
            const captureDelayMs = 2000 + ran() * 2000 + player.ship.devices.torpedo / 100;
            if (fired) {
                putClientOnHold(player, "");
                const timer = setTimeout(() => {
                    releaseClient(player);
                    if (player.ship) {
                        player.ship.torpedoes--;
                    }
                    sendMessageToOthers(player, formatTorpedoBroadcast(player, target.v, target.h));

                    if (player.ship && player.ship.romulanStatus.isRomulan) {
                        player.ship.romulanStatus.isRevealed = true;
                        setTimeout(() => {
                            if (player.ship) {
                                player.ship.romulanStatus.isRevealed = false;
                            }
                        }, 5000);   // TODO is this right?
                    }
                    done?.();
                }, captureDelayMs);
                player.currentCommandTimer = timer;
            } else {
                done?.();
                return;
            }
        }
    }
    done?.();
}



function repeatOrTrim<T>(items: T[], n: number): T[] {
    const result: T[] = [];
    for (let i = 0; i < n; i++) {
        result.push(i < items.length ? items[i] : items[items.length - 1]);
    }
    return result;
}

function formatTorpedoOutOfRange(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    const output = getOutputSetting(player);
    switch (output) {
        case "SHORT":
            return `F > ${coords} No impact`;
        case "MEDIUM":
            return `Torpedo did not reach ${coords} `;
        case "LONG":
        default:
            return `Torpedo launch aborted. Target at ${coords} is beyond maximum range.`;
    }
}
function formatTorpedoLostInVoid(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    const output = getOutputSetting(player);
    switch (output) {
        case "SHORT":
            return `F > ${coords} Vanished`;
        case "MEDIUM":
            return `Torpedo swallowed by black hole`;
        case "LONG":
        default:
            return `Torpedo lost at ${coords}. Possible gravitational anomaly encountered.`;
    }
}

function formatTorpedoExplosion(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });

    const output = getOutputSetting(player);
    switch (output) {
        case "SHORT":
            return `F > ${coords} BOOM`;
        case "MEDIUM":
            return `Explosion at ${coords}!`;
        case "LONG":
        default:
            return `Torpedo triggered explosion at ${coords}. Unstable celestial mass may have ignited.`;
    }
}


function formatTorpedoBroadcast(player: Player, v: number, h: number): string {
    const coords = ocdefCoords(player.settings.ocdef, player.ship?.position ?? { v: 0, h: 0 }, { v, h });
    const output = getOutputSetting(player);
    switch (output) {
        case "SHORT":
            return `F > ${coords} `;
        case "MEDIUM":
            return `Torpedo launched toward ${coords} `;
        case "LONG":
        default:
            return `${player.ship?.name ?? "Unknown"} has launched a torpedo toward ${coords}.`;
    }
}

// ---------------- Planet/Base impact formatters honoring OutputSetting -----
function formatPlanetNoEffect(output: OutputSetting, coords: string): string {
    switch (output) {
        case "SHORT": return `F > ${coords} no effect`;
        case "MEDIUM": return `Torpedo impact at ${coords} had no significant effect.`;
        case "LONG":
        default: return `Torpedo impact on planet @${coords} had no significant effect.`;
    }
}

function formatPlanetInfra(output: OutputSetting, coords: string): string {
    switch (output) {
        case "SHORT": return `F > ${coords} infra −1`;
        case "MEDIUM": return `Infrastructure disrupted at ${coords} (−1 builds).`;
        case "LONG":
        default: return `Torpedo impact on planet @${coords} disrupted infrastructure (−1 builds).`;
    }
}

function formatPlanetDestroyed(output: OutputSetting, wasBase: boolean, coords: string, penalized = false): string {
    if (wasBase) {
        switch (output) {
            case "SHORT": return `F > ${coords} BASE DESTROYED`;
            case "MEDIUM": return `Base destroyed @${coords}!`;
            case "LONG":
            default: return `Torpedo destroyed the base @${coords}!`;
        }
    } else {
        switch (output) {
            case "SHORT": return `F > ${coords} PLANET DESTROYED${penalized ? " (−1000)" : ""}`;
            case "MEDIUM": return `Planet destroyed @${coords}!${penalized ? " (−1000)" : ""}`;
            case "LONG":
            default: return `Torpedo destroyed the planet @${coords}!${penalized ? " (−1000)" : ""}`;
        }
    }
}

function formatBaseHit(output: OutputSetting, coords: string, dmg: number, crit: boolean): string {
    const d = Math.round(dmg);
    switch (output) {
        case "SHORT":
            return `F > ${coords} ${d > 0 ? `B −${d}` : `DEFLECT`}${crit ? " CRIT" : ""}`;
        case "MEDIUM":
            return d > 0
                ? `Base hit @${coords} for ${d}${crit ? " (CRIT)" : ""}.`
                : `Torpedo was deflected @${coords}${crit ? " (CRIT)" : ""}.`;
        case "LONG":
        default:
            return d > 0
                ? `Torpedo hit base @${coords} for ${d} damage${crit ? " (CRIT)" : ""}.`
                : `Torpedo was deflected @${coords}${crit ? " (CRIT)" : ""}.`;
    }
}
// --------------------------------------------------------------------------

// (no flat crit chance; we use thresholded crits in maybeApplyShipCriticalParity)
// Torpedo damage (TORDAM entry point) — parity-focused
// Torpedo damage (TORDAM entry point) — parity-focused
// --- Torpedo damage (TORDAM parity) ---------------------------------------
export function torpedoDamage(
    source: Player | Planet,
    target: Player | Planet
): {
    hita: number;
    isDestroyed: boolean;
    shieldStrength: number;
    shieldsUp: boolean;
    critdm: number;
    deflected?: boolean;
    deflectTo?: { v: number; h: number };
    critDeviceName?: string;
} {
    // Validate target state
    if (target instanceof Player) {
        const ship = target.ship;
        if (!ship || ship.energy <= 0 || ship.damage >= SHIP_FATAL_DAMAGE) {
            return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
        }
    } else if (target instanceof Planet) {
        // Only bases take torpedo damage
        if (!target.isBase || target.energy <= 0) {
            return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
        }
    } else {
        return { hita: 0, isDestroyed: false, shieldStrength: 0, shieldsUp: false, critdm: 0 };
    }

    const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
    const toPct = (energy: number, max: number) => (max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0);
    const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

    const isPlayer = target instanceof Player && !!target.ship;
    const isBase = target instanceof Planet && target.isBase;

    let rawShieldEnergy = isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy; // bases store 0..1000
    const rawShieldMax = isPlayer ? MAX_SHIELD_ENERGY : 1000;
    const shieldsUp = isPlayer ? !!target.ship!.shieldsUp : true; // bases always treated as shielded

    let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

    // Base torpedo hit (Fortran TORDAM): 4000..8000
    const hit = 4000.0 + 4000.0 * ran();
    const rana = ran();

    // Deflection test (ONLY when shields are actually up)
    if (shieldsUp && shieldPct > 0) {
        const rand = ran();
        const rand2 = rana - (shieldPct * 0.001 * rand) + 0.1;

        if (rand2 <= 0.0) {
            // Deflected: drain some shields (50 * rana on 0..1000 scale)
            let drain = 50.0 * rana;
            // Round so it never prints as 0 after Math.round
            if (drain > 0 && drain < 1) drain = 1;
            shieldPct = clamp(shieldPct - drain, 0, 1000);
            rawShieldEnergy = fromPct(shieldPct, rawShieldMax);

            if (isPlayer) {
                target.ship!.shieldEnergy = rawShieldEnergy;
                addPendingMessage(target, `Your shields deflected a torpedo (−${Math.round(drain)} shield).`);
            } else {
                (target as Planet).energy = rawShieldEnergy;
            }

            return {
                hita: 0,
                isDestroyed: false,
                shieldStrength: rawShieldEnergy,
                shieldsUp,
                critdm: 0,
                deflected: true,
                deflectTo: isPlayer
                    ? { v: target.ship!.position.v, h: target.ship!.position.h } // DECWAR shows the *cell the torp hops to*; we don't move it, so show victim cell
                    : { v: (target as Planet).position.v, h: (target as Planet).position.h }
            };
        }
    }

    // Damage through shields + drain
    let hita = hit;
    const prevShieldPct = shieldPct;

    // Absorption/drain ONLY when shields are up
    if (shieldsUp && shieldPct > 0) {
        // Portion that penetrates
        hita = hit * (1000.0 - shieldPct) * 0.001;

        // Drain shields
        const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
        shieldPct = shieldPct - (hit * absorptionFactor + 10.0) * 0.03;
        if (shieldPct < 0) shieldPct = 0;

        // Write back
        rawShieldEnergy = fromPct(shieldPct, rawShieldMax);
        if (isPlayer) {
            target.ship!.shieldEnergy = rawShieldEnergy;
        } else {
            (target as Planet).energy = rawShieldEnergy;
        }
    }

    // Base collapse crit/kill BEFORE hull
    let critdm = 0;
    let critDeviceName: string | undefined;
    if (isBase && shieldsUp && prevShieldPct > 0 && shieldPct === 0) {
        const rana2 = ran();
        const extra = 50 + Math.floor(100 * rana2); // 50..149
        (target as Planet).energy = Math.max(0, (target as Planet).energy - extra);
        critdm = 1;

        if (ran() < 0.10 || (target as Planet).energy <= 0) {
            // Base killed via collapse: award and remove
            // (ensure you have this import somewhere near the top of the file)
            // import { gameEvents } from "./api/events.js";

            if (source instanceof Player && source.ship) {
                const atkSide = source.ship.side;
                const tgtSide = (target as Planet).side;
                const sign = atkSide !== tgtSide ? 1 : -1;

                (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, source, atkSide);
            }

            // --- base removal / collapse (single emit) ---
            {
                const base = target as Planet;
                const prevSide = base.side; // capture before mutation

                // Remove from owning side's base list
                const arr = prevSide === "FEDERATION" ? bases.federation : bases.empire;
                const idx = arr.indexOf(base);
                if (idx !== -1) arr.splice(idx, 1);

                // Remove from global planets as well (no demotion)
                const pidx = planets.indexOf(base);
                if (pidx !== -1) planets.splice(pidx, 1);

                // BASKIL parity: undock/RED ships that were using this port
                handleUndockForAllShipsAfterPortDestruction(base);

                gameEvents.emit({
                    type: "planet_base_removed",
                    payload: {
                        planet: {
                            name: base.name,
                            previousSide: prevSide,
                            position: { ...base.position },
                            // informational only; object is removed
                            energy: 0,
                            builds: 0,
                        },
                        by: (source instanceof Player && source.ship)
                            ? { shipName: source.ship.name, side: source.ship.side }
                            : undefined,
                        reason: "collapse_torpedo",
                    },
                });
            }



            return {
                hita, // pre-scale raw hit for telemetry, but base is gone
                isDestroyed: true,
                shieldStrength: 0,
                shieldsUp: false,
                critdm,
            };
        }
    }

    // Ship critical (device damage) BEFORE hull — thresholded, no flat chance
    if (isPlayer) {
        const victim = target as Player; // narrow once

        const crit = maybeApplyShipCriticalParity(victim, hita);

        if (crit.isCrit) {
            // On crit: halve + ±500 jitter already applied inside helper
            hita = crit.hita;
            critdm = Math.max(critdm, Math.round(crit.critdm * TORP_HULL_SCALE));

            const deviceKeys = Object.keys(victim.ship!.devices);
            const deviceName = deviceKeys[crit.critdv]?.toUpperCase?.() ?? "DEVICE";

            // Show scaled device damage (same scale as hull), or omit number.
            const scaledCrit = Math.max(0, Math.round(crit.critdm * TORP_HULL_SCALE));
            addPendingMessage(
                victim,
                scaledCrit > 0
                    ? `CRITICAL HIT: ${deviceName} damaged (${scaledCrit}).`
                    : `CRITICAL HIT: ${deviceName} struck!`
            );
        } else {
            // Non-crit: integer hull like the original (no global jitter)
            hita = Math.max(0, Math.round(hita));
        }
    }

    // Scale raw torp impact into hull units (~×0.1) before applying/scoring
    const hull = Math.max(0, Math.round(hita * TORP_HULL_SCALE));

    // Apply to target
    const result = applyDamage(source, target, hull, rana) || {
        hita: hull,
        isDestroyed: false,
        shieldStrength: isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy,
        shieldsUp,
        critdm: 0,
    };

    // Award DAMAGE POINTS on the actual applied hull damage
    if (source instanceof Player && source.ship && result.hita > 0) {
        const atkSide = source.ship.side;

        if (isBase) {
            const sign = atkSide !== (target as Planet).side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToBases?.(result.hita * sign, source, atkSide);
        } else if (isPlayer) {
            const sign = atkSide !== target.ship!.side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(result.hita * sign, source, atkSide);
        }
    }

    // Kill bonuses (post-state)
    if (source instanceof Player && source.ship && result.isDestroyed) {
        const atkSide = source.ship.side;

        if (isPlayer) {
            // Award ship-kill bonus ONCE per victim hull.
            if (target.ship && !target.ship.__killCredited) {
                target.ship.__killCredited = true;
                const sign = atkSide !== target.ship!.side ? 1 : -1;
                (pointsManager as unknown as ScoringAPI).addDamageToEnemies?.(5000 * sign, source, atkSide);
            }
        } else if (isBase) {
            const sign = atkSide !== (target as Planet).side ? 1 : -1;
            (pointsManager as unknown as ScoringAPI).addDamageToBases?.(10000 * sign, source, atkSide);
        }
    }

    // Surface crit flag and shield fields
    result.critdm = Math.max(result.critdm || 0, critdm);
    result.shieldsUp = isPlayer ? !!target.ship!.shieldsUp : true;
    result.shieldStrength = isPlayer ? target.ship!.shieldEnergy : (target as Planet).energy;

    return result;
}




// /**
//  * TORDAM-parity core for torpedo impact against shields/hull.
//  * Internally uses 0..1000 shield scale and converts back to your storage.
//  */
// function tordamCore(params: {
//     rawShieldEnergy: number; // current stored shield/energy
//     rawShieldMax: number;    // players: MAX_SHIELD_ENERGY; bases: 1000
// }): { hita: number; newShieldEnergy: number } {
//     const { rawShieldEnergy, rawShieldMax } = params;

//     const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
//     const toPct = (energy: number, max: number) =>
//         max > 0 ? clamp((energy / max) * 1000, 0, 1000) : 0;
//     const fromPct = (pct: number, max: number) => clamp((pct / 1000) * max, 0, max);

//     // Torpedo base impact (Fortran: 4000..8000 range)
//     let hit = 4000 + 4000 * Math.random();

//     // Shields in 0..1000 scale
//     let shieldPct = toPct(rawShieldEnergy, rawShieldMax);

//     // If shields are up, absorb part of the hit and drain shields
//     // Absorb: hit = (1000 - shield%) * hit * 0.001
//     // Drain:  shield% -= (hit * amax1(shield%*0.001, 0.1) + 10) * 0.03
//     if (shieldPct > 0) {
//         hit = (1000 - shieldPct) * hit * 0.001;

//         const absorptionFactor = Math.max(shieldPct * 0.001, 0.1);
//         shieldPct = shieldPct - (hit * absorptionFactor + 10) * 0.03;
//         if (shieldPct < 0) shieldPct = 0;
//     }

//     const hita = hit; // final torpedo damage post-absorption
//     return { hita, newShieldEnergy: fromPct(shieldPct, rawShieldMax) };
// }

// Shared damage resolver for phasers / torpedoes
// --- Shared damage resolver (phasers/torpedoes) ---------------------------
export function applyDamage(
    source: Player | Planet,
    target: Player | Planet,
    hita: number,
    rana: number
): { hita: number; isDestroyed: boolean; shieldStrength: number; shieldsUp: boolean; critdm: number } {
    void rana;
    const critdm = 0;
    let isDestroyed = false;

    // Ships
    if (target instanceof Player && target.ship) {
        const wasAlive = target.ship.damage < SHIP_FATAL_DAMAGE;
        target.ship.energy -= hita;
        target.ship.damage += hita / 2;

        // Clamp to avoid negative telemetry
        if (target.ship.energy < 0) target.ship.energy = 0;

        if (target.ship.energy <= 0 || target.ship.damage >= SHIP_FATAL_DAMAGE) {
            isDestroyed = true;
            // Award kill credit if this hit destroyed the ship
            if (source instanceof Player && source.ship && wasAlive) {
                pointsManager.creditShipKill(source, target.ship.side, 500);
            }
            emitShipDestroyed(
                target.ship.name,
                target.ship.side,
                { v: target.ship.position.v, h: target.ship.position.h },
                source instanceof Player ? attackerRef(source) : undefined,
                "combat"
            );
            removePlayerFromGame(target);
        }

        return {
            hita,
            isDestroyed,
            shieldStrength: target.ship.shieldEnergy,
            shieldsUp: !!target.ship.shieldsUp,
            critdm,
        };
    }

    // Bases
    if (target instanceof Planet && target.isBase) {
        target.energy -= hita;
        if (target.energy < 0) target.energy = 0;


        if (target.energy <= 0) {
            isDestroyed = true;

            // capture before removal
            const prevSide = target.side;

            // remove from owner's base list
            const arr = prevSide === "FEDERATION" ? bases.federation : bases.empire;
            const idx = arr.indexOf(target);
            if (idx !== -1) arr.splice(idx, 1);

            // remove from global planets (no demotion)
            const pidx = planets.indexOf(target);
            if (pidx !== -1) planets.splice(pidx, 1);

            // undock ships that were using this port (BASKIL parity)
            handleUndockForAllShipsAfterPortDestruction(target);

            // emit with captured previous side
            gameEvents.emit({
                type: "planet_base_removed",
                payload: {
                    planet: {
                        name: target.name,
                        previousSide: prevSide,
                        position: { ...target.position }
                    },
                    reason: "collapse_torpedo"
                }
            });
        }


        return {
            hita,
            isDestroyed,
            shieldStrength: target.energy,
            shieldsUp: true,
            critdm,
        };
    }

    // Fallback (shouldn’t occur)
    return { hita, isDestroyed, shieldStrength: 0, shieldsUp: false, critdm };
}


######## tractor.ts
// DECWAR-style TRACTOR (TR) command implementation
import { Player } from './player.js';
import { Command } from './command.js';
import { addPendingMessage, sendMessageToClient, sendOutputMessage } from './communication.js';
import { SHIPNAMES } from './settings.js';
import { Ship } from './ship.js';
import { chebyshev } from './coords.js';

export function tractorCommand(player: Player, command: Command): void {
    const args = command.args;
    const arg = args[0]?.toUpperCase();


    if (!player.ship) {
        sendMessageToClient(player, "You must be in a ship to use TRACTOR.");
        return;
    }

    if (player.ship.tractorPartner) {
        sendMessageToClient(player, "Tractor beam already active, sir.");
        return;
    }

    if (!player.ship.isDeviceOperational("tractor")) return;

    // TRACTOR or TRACTOR OFF to release
    if (!arg || arg === "OFF") {
        if (player.ship.tractorPartner !== null) {
            const targetShip = player.ship.tractorPartner as Ship;
            targetShip.tractorPartner = null;
            const partnerPlayer = targetShip.player;
            player.ship.tractorPartner = null;
            sendOutputMessage(player, {
                SHORT: "Trac. Beam off",
                MEDIUM: "Trac. Beam off",
                LONG: "Tractor beam broken, Captain."
            });
            addPendingMessage(partnerPlayer, `${player.ship.name} has disengaged tractor beam.`);
        } else {
            sendMessageToClient(player, "No tractor beam is active.");
        }
        return;
    }

    // Match by prefix
    const matches = SHIPNAMES.filter(name => name.startsWith(arg));
    if (matches.length === 0) {
        sendMessageToClient(player, `No ship found matching "${arg}".`);
        return;
    }
    if (matches.length > 1) {
        sendMessageToClient(player, `Ambiguous ship name "${arg}". Matches: ${matches.join(", ")}`);
        return;
    }

    const targetName = matches[0];
    const target = Ship.findPlayerByName(targetName);

    if (!target || !target.ship) {
        sendMessageToClient(player, `${targetName} is not active.`);
        return;
    }

    if (!target || !target.ship) {
        sendMessageToClient(player, `${targetName} is not active.`);
        return;
    }
    if (target === player) {
        sendMessageToClient(player, "Beg your pardon, sir?  You want to apply a tractor beam to your own ship?");
        return;
    }
    if (player.ship.side !== target.ship.side) {
        sendMessageToClient(player, "Can not apply tractor beam to enemy ship.");
        return;
    }

    if (chebyshev(player.ship.position, target.ship.position) > 1) {
        sendMessageToClient(player, "Target ship is not adjacent.");
        return;
    }

    if (player.ship.tractorPartner) {
        sendMessageToClient(player, `Tractor beam activated, Captain.\r\nUse TRACTOR OFF to release.`);
        return;
    }

    if (player.ship.shieldsUp) {
        sendMessageToClient(player, "Both ships must have shields down to initiate tractor beam.");
        return;
    }

    if (target.ship.shieldsUp) {
        sendMessageToClient(player, `${target.ship.name} has his shields up.  Unable to apply tractor beam.`);
        return;
    }

    // Establish link 
    player.ship.tractorPartner = target.ship;
    target.ship.tractorPartner = player.ship;

    sendMessageToClient(player, `Tractor beam locked on to ${target.ship.name}.`);
    sendOutputMessage(player, {
        SHORT: "Trac. Beam on",
        MEDIUM: "Trac. Beam on",
        LONG: "Tractor beam activated, Captain."
    });
    addPendingMessage(target, `You are now being tractored by ${player.ship.name}.`);
}

export function disconnectTractor(ship: Ship): void {
    if (ship.tractorPartner) {
        if (ship.tractorPartner.tractorPartner) {
            addPendingMessage(ship.tractorPartner.player, `Tractor beam broken, ${ship.name} disconnected.`);
            ship.tractorPartner.tractorPartner = null;
        }
        ship.tractorPartner = null;
        sendMessageToClient(ship.player, `Tractor beam broken, Captain.`);
    }
}

export function disconnectTractorWithReason(ship: Ship, reason: string): void {
    if (ship.tractorPartner) {
        addPendingMessage(ship.player, `Tractor beam broken, disconnected by ${reason}.`);

        if (ship.tractorPartner.tractorPartner) {
            addPendingMessage(ship.tractorPartner.player, `Tractor beam broken, disconnected by ${reason}.`);
            ship.tractorPartner.tractorPartner = null;
        }
        ship.tractorPartner = null;
    }
}
######## tweak.ts
import { Player } from './player.js';
import { sendMessageToClient } from './communication.js';
import { Command } from './command.js';

export function tweakCommand(player: Player, command: Command): void {

    if (command.args[0] === "FEDERATION") {
        removeAllPlanetsAndBasesFromSide("FEDERATION");
    } else if (command.args[0] === "EMPIRE") {
        removeAllPlanetsAndBasesFromSide("EMPIRE");
    }
    sendMessageToClient(player, "Tweaked");
}



// // CODE TO TEST END OF GAME

// if (command.args[0] === "FEDERATION") {
//     removeAllPlanetsAndBasesFromSide("FEDERATION");
// } else if (command.args[0] === "EMPIRE") {
//     removeAllPlanetsAndBasesFromSide("EMPIRE");


// Removes all planets and all bases from a given side ("FEDERATION" or "EMPIRE")
import { Side } from './settings.js';
import { planets } from './game.js';
import { bases } from './game.js';

// Remove all planets and all bases belonging to the specified side
export function removeAllPlanetsAndBasesFromSide(side: Side): void {
    const sideKey = side === "FEDERATION" ? "federation" : side === "EMPIRE" ? "empire" : null;

    // bases.federation.length = 0;
    // bases.empire.length = 0;


    // Remove all planets on the specified side and all neutral planets
    for (let i = planets.length - 1; i >= 0; i--) {
        const planet = planets[i];
        if (planet.side === side || planet.side === "NEUTRAL") {
            planets.splice(i, 1);
        }
    }

    if (sideKey && bases[sideKey]) {
        bases[sideKey].length = 0;
    }

}

######## type.ts
import { sendOutputMessage } from './communication.js';
import { Player } from './player.js';
import { settings } from './settings.js';

export function typeCommand(player: Player): void {
    const { version, date, allowRomulans, allowBlackHoles } = settings;
    const { output, prompt, scan, icdef, ocdef } = player.settings;

    const short = `[v1.${version}] ${allowRomulans ? 'Romulans' : 'No Romulans'}, ${output} output, ${icdef} in, ${ocdef} out\r\n`;

    const medium = [
        `[DECWARJS Version 1.${version}, ${date}]`,
        `Romulans: ${allowRomulans ? 'enabled' : 'disabled'}.`,
        `Black holes: ${allowBlackHoles ? 'enabled' : 'disabled'}.`,
        `Output: ${output}`,
        `Prompt: ${prompt}`,
        `SCAN format: ${scan}`,
        `Input coords: ${icdef}`,
        `Output coords: ${ocdef}`
    ].join('\r\n') + '\r\n';

    const longLines: string[] = [
        `[DECWARJS Version 1.${version}, ${date}]`,
        `There ${allowRomulans ? 'are' : 'are no'} Romulans in this game.`,
        `There ${allowBlackHoles ? 'are' : 'are no'} Black holes in this game.\r\n`,
        `Current output switch settings:`,
        `${output === 'LONG' ? 'Long' : output === 'MEDIUM' ? 'Medium' : 'Short'} output format.`,
        `${prompt === 'INFORMATIVE' ? 'Informative' : 'Normal'} command prompt.`,
        `${scan === 'LONG' ? 'Long' : 'Short'} SCAN format.`,
        `${icdef === 'RELATIVE' ? 'Relative' : 'Absolute'} coordinates are default for input.`,
        ocdef === 'RELATIVE'
            ? 'Relative coordinates are default for output.'
            : ocdef === 'ABSOLUTE'
                ? 'Absolute coordinates are default for output.'
                : 'Both relative and absolute coordinates are shown for output.'
    ];

    const long = longLines.join('\r\n') + '\r\n';

    sendOutputMessage(player, {
        SHORT: short,
        MEDIUM: medium,
        LONG: long
    });
}

######## types/flat-file-db.d.ts
declare module 'flat-file-db' {
    interface DB {
        put(key: string, value: unknown): void;
        get(key: string): unknown;
        has(key: string): boolean;
        del(key: string): void;
        keys(): string[];
        close(): void;
        on(event: 'open', callback: () => void): void;
    }
    export default function flatfile(path: string): DB;
}
######## users.ts
import { Player } from './player.js';
import { players } from './game.js';
import { sendMessageToClient } from './communication.js';

export function usersCommand(requestingPlayer: Player): void {
    if (!players || players.length === 0) {
        sendMessageToClient(requestingPlayer, "No players are currently in the game.");
        return;
    }

    if (!requestingPlayer.ship) {
        sendMessageToClient(requestingPlayer, "You must be in a ship to use this command.");
        return;
    }

    const formatLine = (p: Player): string => {
        const ship = (p.ship?.name ?? "???").padEnd(10, ' ');
        const captain = (p.settings.name || ship).padEnd(15, ' ');
        const ip = (ip4Pretty(p.socket.remoteAddress || "virtual")).padEnd(15, ' ');
        return `${ship} ${captain} ${ip}`;
    };

    const federationPlayers = players.filter(p => p.ship?.side === "FEDERATION");
    const empirePlayers = players.filter(p => p.ship?.side === "EMPIRE");

    // let output = "Ship       Captain         Location\r\n";
    // output += "---------- --------------- ---------------\r\n";

    let output = "";

    for (const p of federationPlayers) {
        output += formatLine(p) + "\r\n";
    }

    if (empirePlayers.length > 0 && federationPlayers.length > 0) {
        output += "----\r\n";  // Divider
    }

    for (const p of empirePlayers) {
        output += formatLine(p) + "\r\n";
    }

    const romulanPlayers = players.filter(p => p.ship?.romulanStatus.isRomulan);
    if (romulanPlayers.length > 0) {
        output += "----\r\n";  // Divider
    }
    for (const p of romulanPlayers) {
        output += formatLine(p) + "\r\n";
    }

    sendMessageToClient(requestingPlayer, output);
}

function ip4Pretty(ip: string): string {
    if (ip.startsWith('::ffff:')) {
        return ip.replace('::ffff:', '');
    } else if (ip === '::1') {
        return "127.0.0.1";
    } else {
        return ip;
    }
}
######## util/admin.ts
import { Player } from "../player.js";
import { sendMessageToClient } from "../communication.js";
import { Command } from "../command.js";

export function promoteCommand(player: Player, command: Command) {
    if (command.args[0] === "theq") {
        player.isAdmin = true;
        sendMessageToClient(player, "You are now an admin.");
    } else {
        sendMessageToClient(player, "Unknown command");
    }
}
######## util/auth.ts
//import { playerCache } from '../game.js';
//import { Player } from '../player.js';
import { ran } from "./random.js";
// Auth session interface for player authentication

export interface AuthSession {
    ip: string;
    email?: string;
    code?: string;
    authed: boolean;
    createdAt: number;
}

export function generateAccessCode(): string {
    const part1 = Math.floor(1000 + ran() * 9000); // e.g., 4-digit
    const part2 = ran().toString(36).substring(2, 6).toUpperCase();
    return `${part1}-${part2}`;
}

export function isValidEmail(email: string): boolean {
    const trimmed = email.trim().toLowerCase();
    const emailRegex =
        /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/;
    return emailRegex.test(trimmed);
}

// export function emailHasSameIp(email: string, ip: string): Player | null {
//     return null; // TODO PUT BACK TODO
//     // const matchingPlayer = playerCache.find(p =>
//     //     p.auth.ip === ip &&
//     //     p.auth.email?.toLowerCase() === email.toLowerCase()
//     // );

//     // if (matchingPlayer) {
//     //     const idx = playerCache.indexOf(matchingPlayer);
//     //     playerCache.splice(idx, 1);
//     //     return matchingPlayer;
//     // }
//     // return null;
// }


// Export an empty object to ensure the file is treated as a module
export { };
######## util/clear.ts
import { Player } from '../player.js';
import { sendMessageToClient } from '../communication.js';

export function clearCommand(player: Player): void {
    sendMessageToClient(player, '\x1b[2J\x1b[H');
}


######## util/email.ts
import mailchimp from "@mailchimp/mailchimp_marketing";

export async function addEmailToMailchimp(email: string) {

    try {
        await sendEmailToMailchimp(email);
    } catch (err) {
        console.error("Mailchimp error:", err);
    }
}

// --- Main Function ---
export async function sendEmailToMailchimp(email: string): Promise<AddEmailResult | null> {
    if (!mailchimpApiKey) {
        console.error("Cannot add email: MAILCHIMP_API_KEY is missing.");
        return null;
    }

    try {
        const response = await mailchimp.lists.addListMember(listId, {
            email_address: email,
            status: "subscribed",
        });

        if (
            typeof response === "object" &&
            response &&
            "id" in response &&
            "email_address" in response &&
            "status" in response
        ) {
            return {
                id: response.id,
                email_address: response.email_address,
                status: String(response.status),
            };
        }

        console.warn("Unexpected Mailchimp response format:", response);
        return null;
    } catch (error: unknown) {
        const status = (error as { response?: { status?: unknown } })?.response?.status;
        const detail = (error as { response?: { body?: { detail?: string } }; message?: string })?.response?.body?.detail ||
            (error as { message?: string })?.message;

        console.error("Mailchimp API error:", {
            status,
            detail,
        });

        return null;
    }
}
interface AddEmailResult {
    id: string;
    email_address: string;
    status: string;
}

// Debug environment variable loading
// console.log("Environment check:", {
//   NODE_ENV: process.env.NODE_ENV,
//   MAILCHIMP_API_KEY_exists: 'MAILCHIMP_API_KEY' in process.env,
//   MAILCHIMP_API_KEY_length: process.env.MAILCHIMP_API_KEY?.length,
//   MAILCHIMP_API_KEY_first_chars: process.env.MAILCHIMP_API_KEY?.substring(0, 4) + '...'
// });

interface AddEmailResult {
    id: string;
    email_address: string;
    status: string;
}

// --- Configuration ---
const mailchimpApiKey = "13b7619d7fb05d56776b3a9db47bc26c-us20";//process.env.MAILCHIMP_API_KEY;
const mailchimpServer = "us20"; // Extract this from your API key suffix
const listId = "cc1961a126";

if (!mailchimpApiKey) {
    console.warn("MAILCHIMP_API_KEY environment variable is not set.");
} else {
    mailchimp.setConfig({
        apiKey: mailchimpApiKey,
        server: mailchimpServer,
    });

    // console.log("Mailchimp configured:", {
    //   server: mailchimpServer,
    //   apiKeyPresent: true,
    //   apiKeyLength: .length,
    // });
}


######## util/nullsocket.ts
import { Socket } from 'net';

export class NullSocket extends Socket {
    constructor() {
        super();

        // Optional: override any internal behavior if needed
        this.pause(); // ensure it doesn't try to read
    }

    override write(_data: unknown, _encoding?: unknown, _callback?: unknown): boolean {
        void _data;
        void _encoding;
        void _callback;
        return true;
    }

    override end(_data?: unknown, _encoding?: unknown, _callback?: unknown): this {
        void _data;
        void _encoding;
        void _callback;
        return this;
    }

    override destroy(_error?: Error): this {
        void _error;
        return this;
    }
}
######## util/random.ts
import seedrandom from 'seedrandom';
import type { PRNG } from 'seedrandom';
import { settings } from '../settings.js';
let rng: PRNG | null = null;

export function setRandomSeed(str: string): void {
    settings.tournamentSeed = str;
    rng = seedrandom(settings.tournamentSeed);
}

export function getRandom(): number {
    // Core random in [0,1).
    // If a seed is set, use the seeded PRNG; otherwise fall back to Math.random()
    // so unseeded games still behave like classic DECWAR (non-deterministic).
    return rng ? rng() : Math.random();
}

/**
 * Convenience: ran() -> float in [0,1)
 * Mirrors DECWAR's RAN(0) semantics.
 */
export function ran(): number {
    return getRandom();
}

/**
 * Convenience: iran(n) -> integer in [0, n-1]
 * Mirrors DECWAR's IRAN. If n <= 1, returns 0.
 */
export function iran(n: number): number {
    if (n <= 1) return 0;
    // Using getRandom() preserves determinism when seeded.
    return Math.floor(getRandom() * n);
}

/**
 * Optional helpers (handy in tests/tools)
 */
export function isSeeded(): boolean {
    return !!rng;
}

export function clearRandomSeed(): void {
    settings.tournamentSeed = '';
    rng = null;
}
######## util/restart.ts
import { Player } from "../player.js";
import { sendMessageToClient } from "../communication.js";
//import { restartGame } from "../game.js";


export function restartCommand(player: Player) {
    if (!player.isAdmin) {
        sendMessageToClient(player, "Unknown command.");
    } else {
        sendMessageToClient(player, "Restarting the game...");
        //restartGame();
    }
}

######## util/send-email.ts
import dotenv from 'dotenv';
import nodemailer from 'nodemailer';
import { google } from 'googleapis';

dotenv.config();

const {
    EMAIL,
    CLIENT_ID,
    CLIENT_SECRET,
    REFRESH_TOKEN
} = process.env;

const REDIRECT_URI = 'https://developers.google.com/oauthplayground';

const oAuth2Client = new google.auth.OAuth2(
    CLIENT_ID,
    CLIENT_SECRET,
    REDIRECT_URI
);
oAuth2Client.setCredentials({ refresh_token: REFRESH_TOKEN });

interface EmailOptions {
    to: string;
    subject: string;
    text: string;
}

export async function sendEmail({ to, subject, text }: EmailOptions): Promise<void> {
    const accessTokenResponse = await oAuth2Client.getAccessToken();
    const accessToken = accessTokenResponse?.token;

    if (!accessToken) {
        throw new Error('Unable to get access token');
    }

    // This typing works with nodemailer@6+
    const transporter = nodemailer.createTransport({
        // Nodemailer knows these fields; TS won't complain here
        host: 'smtp.gmail.com',
        port: 465,
        secure: true,
        auth: {
            type: 'OAuth2',
            user: EMAIL,
            clientId: CLIENT_ID!,
            clientSecret: CLIENT_SECRET!,
            refreshToken: REFRESH_TOKEN!,
            accessToken
        }
    } as nodemailer.TransportOptions); // <- KEY FIX

    await transporter.sendMail({
        from: `DECWAR <${EMAIL}>`,
        to,
        subject,
        text
    });
}

// Test it
// sendEmail({
//   to: 'erictfree@mac.com',
//   subject: 'Test Email from DECWAR',
//   text: 'This is a working Gmail OAuth2 email from Node + TypeScript'
// });

######## util/util.ts
/**
 * Checks if a string matches a pattern where the initial uppercase letters in the pattern
 * must be matched (case-insensitive), and remaining lowercase characters are optional (subsequence matching).
 * The match is case-insensitive, and uppercase letters are assumed to be at the start of the pattern.
 * Assumes non-empty strings for both inputs.
 * @param str - The string to check.
 * @param pattern - The pattern to match against, with uppercase letters at the start.
 * @returns True if the string matches the pattern, false otherwise.
 */
export function matchesPattern(str: string, pattern: string): boolean {
    // Find the number of initial uppercase letters in the pattern
    if (str.length > pattern.length) return false;

    let upperCaseCount = 0;
    const patternLen = pattern.length;
    for (; upperCaseCount < patternLen; upperCaseCount++) {
        const code = pattern.charCodeAt(upperCaseCount);
        if (code < 65 || code > 90) break; // not A-Z
    }

    // If str is too short, fail
    if (str.length < upperCaseCount) return false;

    // Compare initial uppercase letters (case-insensitive)
    for (let i = 0; i < upperCaseCount; i++) {
        if (str[i].toLowerCase() !== pattern[i].toLowerCase()) return false;
    }

    for (let i = upperCaseCount; i < str.length; i++) {
        if (str[i].toLowerCase() !== pattern[i].toLowerCase()) return false;
    }
    return true;
}
######## version.ts
// Auto-generated by generate-version.ts
export const VERSION = 'f9d5756';

